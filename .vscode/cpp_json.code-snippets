{
    "2VCCs.h": {
        "body": [
            "struct graph {",
            "\tint n;",
            "\tvector<vector<pii>> edges;",
            "\tgraph(int n): n(n), edges(n) {}",
            "\tvoid addEdge(int a, int b, int id) {",
            "\t\tedges[a].emplace_back(b, id);",
            "\t\tedges[b].emplace_back(a, id);",
            "\t}",
            "};",
            "int preCnt, metaN;",
            "vi pre, low, used, stk, lowMap, artMap;",
            "void pop(int stopId) {",
            "\twhile (size(stk)) {",
            "\t\tint id = stk.back();",
            "\t\tstk.pop_back();",
            "\t\tlowMap[id] = metaN;",
            "\t\tif (id == stopId) break;",
            "\t}",
            "\t++metaN;",
            "}",
            "void dfs(int idx, int par, graph &g) {",
            "\tpre[idx] = low[idx] = ++preCnt;",
            "\tbool hasFwd = false;",
            "\tfor (auto [next, id] : g.edges[idx]) {",
            "\t\tif (next != par && !used[id]) {",
            "\t\t\tused[id] = true, stk.push_back(id);",
            "\t\t\t// back edge",
            "\t\t\tif (pre[next] != -1) {",
            "\t\t\t\tlow[idx] = min(low[idx], pre[next]);",
            "\t\t\t\tcontinue;",
            "\t\t\t}",
            "\t\t\t// forward edge",
            "\t\t\tdfs(next, idx, g);",
            "\t\t\tlow[idx] = min(low[idx], low[next]);",
            "\t\t\tif (par == -1 && hasFwd ||",
            "\t\t\t\tpar != -1 && low[next] >= pre[idx]) {",
            "\t\t\t\t// idx is an articulation point",
            "\t\t\t\tif (artMap[idx] == -1) artMap[idx] = metaN++;",
            "\t\t\t\tpop(id);",
            "\t\t\t}",
            "\t\t\thasFwd = true;",
            "\t\t}",
            "\t}",
            "\tif (par == -1 && size(stk)) pop(-1);",
            "}",
            "pair<graph, vi> getMeta(graph &g, int numEdges) {",
            "\tint n = g.n;",
            "\tpreCnt = -1, metaN = 0;",
            "\tpre = vi(n, -1), low = vi(n), artMap = vi(n, -1);",
            "\tused = vi(numEdges), lowMap = vi(numEdges), stk = vi();",
            "\tfor (int i = 0; i < n; ++i)",
            "\t\tif (pre[i] == -1) dfs(i, -1, g);",
            "\tgraph meta = graph(metaN);",
            "\tvi seen(metaN, false);",
            "\tfor (int u = 0; u < n; ++u) {",
            "\t\tif (artMap[u] == -1) continue;",
            "\t\tfor (auto [v, id] : g.edges[u]) {",
            "\t\t\tif (!seen[lowMap[id]]) {",
            "\t\t\t\tseen[lowMap[id]] = true;",
            "\t\t\t\tmeta.addEdge(artMap[u], lowMap[id], -1);",
            "\t\t\t}",
            "\t\t}",
            "\t\tfor (auto [v, id] : g.edges[u]) seen[lowMap[id]] = false;",
            "\t}",
            "\t// use and return if needed:",
            "\t// gives a original node contribution to each meta node",
            "\t// articulation points are only counted toward their",
            "\t// individual meta nodes",
            "\tvi cont(metaN);",
            "\tfor (int u = 0; u < n; ++u)",
            "\t\tif (artMap[u] != -1) cont[artMap[u]] = 1;",
            "\t\telse ++cont[lowMap[g.edges[u].begin()->second]];",
            "\treturn {meta, cont};",
            "}"
        ],
        "prefix": [
            "hack_2VCCs"
        ]
    },
    "2sat.h": {
        "body": [
            "struct TwoSat {",
            "\tint N;",
            "\tvector<vi> gr;",
            "\tvi values; // 0 = false, 1 = true",
            "\tTwoSat(int n = 0): N(n), gr(2 * n) {}",
            "\tint addVar() { // (optional)",
            "\t\tgr.emplace_back();",
            "\t\tgr.emplace_back();",
            "\t\treturn N++;",
            "\t}",
            "\tvoid either(int f, int j) {",
            "\t\tf = max(2 * f, -1 - 2 * f);",
            "\t\tj = max(2 * j, -1 - 2 * j);",
            "\t\tgr[f].push_back(j ^ 1);",
            "\t\tgr[j].push_back(f ^ 1);",
            "\t}",
            "\tvoid setValue(int x) { either(x, x); }",
            "\tvoid atMostOne(const vi& li) { // (optional)",
            "\t\tif (sz(li) <= 1) return;",
            "\t\tint cur = ~li[0];",
            "\t\trep(i, 2, sz(li)) {",
            "\t\t\tint next = addVar();",
            "\t\t\teither(cur, ~li[i]);",
            "\t\t\teither(cur, next);",
            "\t\t\teither(~li[i], next);",
            "\t\t\tcur = ~next;",
            "\t\t}",
            "\t\teither(cur, ~li[1]);",
            "\t}",
            "\tvi val, comp, z;",
            "\tint time = 0;",
            "\tint dfs(int i) {",
            "\t\tint low = val[i] = ++time, x;",
            "\t\tz.push_back(i);",
            "\t\tfor (int e : gr[i])",
            "\t\t\tif (!comp[e]) low = min(low, val[e] ?: dfs(e));",
            "\t\tif (low == val[i]) do {",
            "\t\t\t\tx = z.back(), z.pop_back();",
            "\t\t\t\tcomp[x] = low;",
            "\t\t\t\tif (values[x >> 1] == -1) values[x >> 1] = x & 1;",
            "\t\t\t} while (x != i);",
            "\t\treturn val[i] = low;",
            "\t}",
            "\tbool solve() {",
            "\t\tvalues.assign(N, -1), val.assign(2 * N, 0), comp = val;",
            "\t\trep(i, 0, 2 * N) if (!comp[i]) dfs(i);",
            "\t\trep(i, 0, N) if (comp[2 * i] == comp[2 * i + 1]) return 0;",
            "\t\treturn 1;",
            "\t}",
            "};"
        ],
        "description": "Calculates a valid assignment to boolean variables a, b, c,... to a 2-SAT problem, so that an expression of the type $(a\\|\\|b)\\&\\&(!a\\|\\|c)\\&\\&(d\\|\\|!b)\\&\\&...$ becomes true, or reports that it is unsatisfiable.\nNegated variables are represented by bit-inversions (\\texttt{\\tilde{}x}).",
        "prefix": [
            "hack_2sat"
        ]
    },
    "3dHull.h": {
        "body": [
            "typedef Point3D<double> P3;",
            "struct PR {",
            "\tvoid ins(int x) { (a == -1 ? a : b) = x; }",
            "\tvoid rem(int x) { (a == x ? a : b) = -1; }",
            "\tint cnt() { return (a != -1) + (b != -1); }",
            "\tint a, b;",
            "};",
            "struct F {",
            "\tP3 q;",
            "\tint a, b, c;",
            "};",
            "vector<F> hull3d(const vector<P3>& A) {",
            "\tassert(sz(A) >= 4);",
            "\tvector<vector<PR>> E(sz(A), vector<PR>(sz(A), {-1, -1}));",
            "#define E(x, y) E[f.x][f.y]",
            "\tvector<F> FS;",
            "\tauto mf = [&](int i, int j, int k, int l) {",
            "\t\tP3 q = (A[j] - A[i]).cross((A[k] - A[i]));",
            "\t\tif (q.dot(A[l]) > q.dot(A[i])) q = q * -1;",
            "\t\tF f{q, i, j, k};",
            "\t\tE(a, b).ins(k), E(a, c).ins(j), E(b, c).ins(i);",
            "\t\tFS.push_back(f);",
            "\t};",
            "\trep(i, 0, 4) rep(j, i + 1, 4) rep(k, j + 1, 4)",
            "\t\tmf(i, j, k, 6 - i - j - k);",
            "\trep(i, 4, sz(A)) {",
            "\t\trep(j, 0, sz(FS)) {",
            "\t\t\tF f = FS[j];",
            "\t\t\tif (f.q.dot(A[i]) > f.q.dot(A[f.a])) {",
            "\t\t\t\tE(a, b).rem(f.c), E(a, c).rem(f.b), E(b, c).rem(f.a);",
            "\t\t\t\tswap(FS[j--], FS.back());",
            "\t\t\t\tFS.pop_back();",
            "\t\t\t}",
            "\t\t}",
            "\t\tint nw = sz(FS);",
            "\t\trep(j, 0, nw) {",
            "\t\t\tF f = FS[j];",
            "#define C(a, b, c) \\",
            "\tif (E(a, b).cnt() != 2) mf(f.a, f.b, i, f.c);",
            "\t\t\tC(a, b, c), C(a, c, b), C(b, c, a);",
            "\t\t}",
            "\t}",
            "\tfor (F& it : FS)",
            "\t\tif (",
            "\t\t\t(A[it.b] - A[it.a]).cross(A[it.c] - A[it.a]).dot(it.q) <=",
            "\t\t\t0)",
            "\t\t\tswap(it.c, it.b);",
            "\treturn FS;",
            "};"
        ],
        "description": "Computes all faces of the 3-dimension hull of a point set.\n*No four points must be coplanar*, or else random results will be returned.\nAll faces will point outwards.",
        "prefix": [
            "hack_3dHull"
        ]
    },
    "Angle.h": {
        "body": [
            "struct Angle {",
            "\tint x, y;",
            "\tint t;",
            "\tAngle(int x, int y, int t = 0): x(x), y(y), t(t) {}",
            "\tAngle operator-(Angle b) const {",
            "\t\treturn {x - b.x, y - b.y, t};",
            "\t}",
            "\tint half() const {",
            "\t\tassert(x || y);",
            "\t\treturn y < 0 || (y == 0 && x < 0);",
            "\t}",
            "\tAngle t90() const { return {-y, x, t + (half() && x >= 0)}; }",
            "\tAngle t180() const { return {-x, -y, t + half()}; }",
            "\tAngle t360() const { return {x, y, t + 1}; }",
            "};",
            "bool operator<(Angle a, Angle b) {",
            "\t// add a.dist2() and b.dist2() to also compare distances",
            "\treturn make_tuple(a.t, a.half(), a.y * (ll)b.x) <",
            "\t\tmake_tuple(b.t, b.half(), a.x * (ll)b.y);",
            "}",
            "// Given two points, this calculates the smallest angle between",
            "// them, i.e., the angle that covers the defined line segment.",
            "pair<Angle, Angle> segmentAngles(Angle a, Angle b) {",
            "\tif (b < a) swap(a, b);",
            "\treturn (",
            "\t\tb < a.t180() ? make_pair(a, b) : make_pair(b, a.t360()));",
            "}",
            "Angle operator+(Angle a, Angle b) { // point a + vector b",
            "\tAngle r(a.x + b.x, a.y + b.y, a.t);",
            "\tif (a.t180() < r) r.t--;",
            "\treturn r.t180() < a ? r.t360() : r;",
            "}",
            "Angle angleDiff(Angle a, Angle b) { // angle b - angle a",
            "\tint tu = b.t - a.t;",
            "\ta.t = b.t;",
            "\treturn {a.x * b.x + a.y * b.y, a.x * b.y - a.y * b.x,",
            "\t\ttu - (b < a)};",
            "}"
        ],
        "description": "A class for ordering angles (as represented by int points and\na number of rotations around the origin). Useful for rotational sweeping.\nSometimes also represents points or vectors.",
        "prefix": [
            "hack_Angle"
        ]
    },
    "BIT.h": {
        "body": [
            "template<class T> struct BIT {",
            "\tvector<T> s;",
            "\tint n;",
            "\tBIT(int n): s(n + 1), n(n) {}",
            "\tvoid update(int i, T v) {",
            "\t\tfor (i++; i <= n; i += i & -i) s[i] += v;",
            "\t}",
            "\tT query(int i) { // EXCLUSIVE interval [0, i)",
            "\t\tT ans = 0;",
            "\t\tfor (; i; i -= i & -i) ans += s[i];",
            "\t\treturn ans;",
            "\t} // INCLUSIVE-EXCLUSIVE interval [l, r)",
            "\tT query(int l, int r) { return query(r) - query(l); }",
            "\tint kth(T k) { // 0-indexed, returns n if k > sum of tree",
            "\t\tif (k < 0) return -1;",
            "\t\tint i = 0;",
            "\t\tfor (int pw = 1 << __lg(n); pw; pw >>= 1)",
            "\t\t\tif (i + pw <= n && s[i + pw] <= k) k -= s[i += pw];",
            "\t\treturn i;",
            "\t}",
            "};"
        ],
        "description": "Query [0, i) and [l, r) sums, and point updates.\nkth() returns the smallest index i s.t. query(i) > k.\nRight endpoint is exclusive.",
        "prefix": [
            "hack_BIT"
        ]
    },
    "BerlekampMassey.h": {
        "body": [
            "vector<ll> berlekampMassey(vector<ll> s) {",
            "\tint n = sz(s), L = 0, m = 0;",
            "\tvector<ll> C(n), B(n), T;",
            "\tC[0] = B[0] = 1;",
            "\tll b = 1;",
            "\trep(i, 0, n) {",
            "\t\t++m;",
            "\t\tll d = s[i] % mod;",
            "\t\trep(j, 1, L + 1) d = (d + C[j] * s[i - j]) % mod;",
            "\t\tif (!d) continue;",
            "\t\tT = C;",
            "\t\tll coef = d * modpow(b, mod - 2) % mod;",
            "\t\trep(j, m, n) C[j] = (C[j] - coef * B[j - m]) % mod;",
            "\t\tif (2 * L > i) continue;",
            "\t\tL = i + 1 - L;",
            "\t\tB = T;",
            "\t\tb = d;",
            "\t\tm = 0;",
            "\t}",
            "\tC.resize(L + 1);",
            "\tC.erase(C.begin());",
            "\tfor (ll& x : C) x = (mod - x) % mod;",
            "\treturn C;",
            "}"
        ],
        "description": "Recovers any $n$-order linear recurrence relation from the first\n$2n$ terms of the recurrence.\nUseful for guessing linear recurrences after brute-forcing the first terms.\nShould work on any field, but numerical stability for floats is not guaranteed.\nOutput will have size $\\le n$.",
        "prefix": [
            "hack_BerlekampMassey"
        ]
    },
    "Blossom.h": {
        "body": [
            "vi Blossom(vector<vi>& adj) {",
            "\tint n = adj.size(), T = -1;",
            "\tvi mate(n, -1), label(n), par(n), orig(n), aux(n, -1), q;",
            "\tauto lca = [&](int x, int y) {",
            "\t\tfor (T++;; swap(x, y)) {",
            "\t\t\tif (x == -1) continue;",
            "\t\t\tif (aux[x] == T) return x;",
            "\t\t\taux[x] = T;",
            "\t\t\tx = (mate[x] == -1 ? -1 : orig[par[mate[x]]]);",
            "\t\t}",
            "\t};",
            "\tauto blossom = [&](int v, int w, int a) {",
            "\t\twhile (orig[v] != a) {",
            "\t\t\tpar[v] = w;",
            "\t\t\tw = mate[v];",
            "\t\t\tif (label[w] == 1) label[w] = 0, q.push_back(w);",
            "\t\t\torig[v] = orig[w] = a, v = par[w];",
            "\t\t}",
            "\t};",
            "\tauto augment = [&](int v) {",
            "\t\twhile (v != -1) {",
            "\t\t\tint pv = par[v], nv = mate[pv];",
            "\t\t\tmate[v] = pv, mate[pv] = v, v = nv;",
            "\t\t}",
            "\t};",
            "\tauto bfs = [&](int root) {",
            "\t\tfill(all(label), -1), iota(all(orig), 0);",
            "\t\tq.clear(), q.push_back(root), label[root] = 0;",
            "\t\tfor (int i = 0; i < sz(q); i++) {",
            "\t\t\tint v = q[i];",
            "\t\t\tfor (auto x : adj[v])",
            "\t\t\t\tif (label[x] == -1) {",
            "\t\t\t\t\tlabel[x] = 1, par[x] = v;",
            "\t\t\t\t\tif (mate[x] == -1) return augment(x);",
            "\t\t\t\t\tlabel[mate[x]] = 0, q.push_back(mate[x]);",
            "\t\t\t\t} else if (label[x] == 0 && orig[v] != orig[x]) {",
            "\t\t\t\t\tint a = lca(orig[v], orig[x]);",
            "\t\t\t\t\tblossom(x, v, a), blossom(v, x, a);",
            "\t\t\t\t}",
            "\t\t}",
            "\t};",
            "\t// Time halves if you start with (any) maximal matching.",
            "\tfor (int i = 0; i < n; i++)",
            "\t\tif (mate[i] == -1) bfs(i);",
            "\treturn mate;",
            "}"
        ],
        "description": "General matching in $O(nm)$.",
        "prefix": [
            "hack_Blossom"
        ]
    },
    "CRT.h": {
        "body": [
            "ll crt(ll a, ll m, ll b, ll n) {",
            "\tif (n > m) swap(a, b), swap(m, n);",
            "\tll x, y, g = euclid(m, n, x, y);",
            "\tassert((a - b) % g == 0); // else no solution",
            "\tx = (b - a) % n * x % n / g * m + a;",
            "\treturn x < 0 ? x + m * n / g : x;",
            "}"
        ],
        "description": "Chinese Remainder Theorem.\n\n\\texttt{crt(a, m, b, n)} computes $x$ such that $x\\equiv a \\pmod m$, $x\\equiv b \\pmod n$.\nIf $|a| < m$ and $|b| < n$, $x$ will obey $0 \\le x < \\text{lcm}(m, n)$.\nAssumes $mn < 2^{62}$.",
        "prefix": [
            "hack_CRT"
        ]
    },
    "CaptainAmerica.h": {
        "body": [
            "#define all(x) x.begin(), x.end()",
            "#define rep(a, b, c) for (int a = b; a < c; a++)",
            "#define sz(x) (int)x.size()",
            "using namespace std;",
            "using ll = long long int;",
            "using vi = vector<int>;",
            "using pii = pair<int, int>;",
            "// template<int N>",
            "struct Dinic {",
            "\t// disable scaling when max flow/capacity is small, or",
            "\t// sometimes on random data",
            "\tconst static bool SCALING = false; // lol unit edges",
            "\tstruct Edge {",
            "\t\tint v, dual;",
            "\t\tll cap, res;",
            "\t\tconstexpr ll flow() { return max(cap - res, 0ll); }",
            "\t};",
            "\tint n, s, t;",
            "\tvector<int> lvl, q, blk, ptr;",
            "\tvector<vector<Edge>> adj;",
            "\tvector<pair<int, int>> edges;",
            "\tDinic(int n): n(n + 2), s(n++), t(n++), adj(n), q(n) {}",
            "\tint add(int u, int v, ll cap, ll flow = 0) {",
            "\t\tadj[u].push_back({v, int(adj[v].size()), cap, cap - flow});",
            "\t\tadj[v].push_back({u, int(adj[u].size()) - 1, 0, 0});",
            "\t\tedges.emplace_back(u, adj[u].size() - 1);",
            "\t\treturn edges.size() - 1; // this Edge's ID",
            "\t}",
            "\tll dfs(int u, ll in) {",
            "\t\tif (u == t || !in) return in;",
            "\t\tll flow = 0;",
            "\t\t// for (auto& e : adj[u]) {",
            "\t\tfor (int& i = ptr[u]; i < adj[u].size(); i++) {",
            "\t\t\tauto& e = adj[u][i];",
            "\t\t\tif (e.res && lvl[e.v] == lvl[u] - 1)",
            "\t\t\t\tif (ll out = dfs(e.v, min(in, e.res))) {",
            "\t\t\t\t\tflow += out, in -= out, e.res -= out;",
            "\t\t\t\t\tadj[e.v][e.dual].res += out;",
            "\t\t\t\t\tif (!in) return flow;",
            "\t\t\t\t\t// return flow;",
            "\t\t\t\t}",
            "\t\t}",
            "\t\t// blk[u] = 1;",
            "\t\treturn flow;",
            "\t}",
            "\tll flow() {",
            "\t\tll flow = 0;",
            "\t\tq[0] = t;",
            "\t\tfor (int B = SCALING * 30; B >= 0; B--) do {",
            "\t\t\t\tlvl = ptr = vector<int>(n);",
            "\t\t\t\tint qi = 0, qe = lvl[t] = 1;",
            "\t\t\t\twhile (qi < qe && !lvl[s]) {",
            "\t\t\t\t\tint u = q[qi++];",
            "\t\t\t\t\tfor (auto& e : adj[u])",
            "\t\t\t\t\t\tif (!lvl[e.v] && adj[e.v][e.dual].res >> B)",
            "\t\t\t\t\t\t\tq[qe++] = e.v, lvl[e.v] = lvl[u] + 1;",
            "\t\t\t\t}",
            "\t\t\t\tif (lvl[s]) flow += dfs(s, LLONG_MAX);",
            "\t\t\t\t// while (ll f = dfs(s, LLONG_MAX)) flow += f;",
            "\t\t\t} while (lvl[s]);",
            "\t\treturn flow;",
            "\t}",
            "\tEdge& get(int id) { // get Edge object from its ID",
            "\t\treturn adj[edges[id].first][edges[id].second];",
            "\t}",
            "\tvoid clear() {",
            "\t\tfor (auto& it : adj)",
            "\t\t\tfor (auto& e : it) e.res = e.cap;",
            "\t}",
            "\tbool leftOfMinCut(int u) { return lvl[u] == 0; }",
            "\t// d is a list of vertex demands, d[u] = flow in - flow out",
            "\t// negative if u is a source, positive if u is a sink",
            "\tbool circulation(vector<ll> d = {}) {",
            "\t\td.resize(n);",
            "\t\tvector<int> circEdges;",
            "\t\tDinic g(n);",
            "\t\tfor (int u = 0; u < n; u++)",
            "\t\t\tfor (auto& e : adj[u])",
            "\t\t\t\tif (e.cap) {",
            "\t\t\t\t\td[u] += e.flow(), d[e.v] -= e.flow();",
            "\t\t\t\t\tif (e.res) circEdges.push_back(g.add(u, e.v, e.res));",
            "\t\t\t\t}",
            "\t\tint tylerEdge = g.add(t, s, LLONG_MAX, 0);",
            "\t\tll flow = 0;",
            "\t\tfor (int u = 0; u < n; u++)",
            "\t\t\tif (d[u] < 0) g.add(g.s, u, -d[u]);",
            "\t\t\telse if (d[u] > 0) g.add(u, g.t, d[u]), flow += d[u];",
            "\t\tif (flow != g.flow()) return false;",
            "\t\tint i = 0; // reconstruct the flow into this graph",
            "\t\tfor (int u = 0; u < n; u++)",
            "\t\t\tfor (auto& e : adj[u])",
            "\t\t\t\tif (e.cap) {",
            "\t\t\t\t\tadj[e.v][e.dual].res -= e.flow();",
            "\t\t\t\t\tif (e.res) e.res -= g.get(circEdges[i++]).flow();",
            "\t\t\t\t\tadj[e.v][e.dual].res += e.flow();",
            "\t\t\t\t}",
            "\t\treturn true;",
            "\t}",
            "\tpair<bool, ll> maxFlowWithDemands() {",
            "\t\tif (!circulation()) return {false, 0};",
            "\t\tll init = 0;",
            "\t\tfor (auto& e : adj[s]) init += e.flow();",
            "\t\treturn {true, init + flow()};",
            "\t}",
            "};",
            "void solve() {",
            "\tint n, m;",
            "\tcin >> n >> m;",
            "\tll r, b;",
            "\tcin >> r >> b;",
            "\tmap<ll, ll> xf, yf;",
            "\tmap<ll, vector<ll>> adj;",
            "\tvector<pair<ll, ll>> pts;",
            "\tfor (int i = 0; i < n; i++) {",
            "\t\tll x, y;",
            "\t\tcin >> x >> y;",
            "\t\txf[x]++;",
            "\t\tyf[y]++;",
            "\t\tadj[x].push_back(y);",
            "\t\tpts.emplace_back(x, y);",
            "\t}",
            "\tmap<ll, ll> xd, yd;",
            "\tfor (auto [x, f] : xf) xd[x] = f;",
            "\tfor (auto [y, f] : yf) yd[y] = f;",
            "\tfor (int i = 0; i < m; i++) {",
            "\t\tll t, l, d;",
            "\t\tcin >> t >> l >> d;",
            "\t\tif (t == 1 && xd.count(l)) xd[l] = min(xd[l], d);",
            "\t\tif (t == 2 && yd.count(l)) yd[l] = min(yd[l], d);",
            "\t}",
            "\tDinic g(xf.size() + yf.size());",
            "\tmap<ll, int> xID, yID;",
            "\tint curr = 0;",
            "\tfor (auto [x, f] : xf) {",
            "\t\tll d = xd[x];",
            "\t\tll upper = (f + d) / 2;",
            "\t\tll lower = (f - d + 1) / 2;",
            "\t\txID[x] = curr++;",
            "\t\tif (lower > upper) {",
            "\t\t\tcout << -1 << '\\n';",
            "\t\t\treturn;",
            "\t\t}",
            "\t\tg.add(g.s, xID[x], upper, lower);",
            "\t}",
            "\tfor (auto [y, f] : yf) {",
            "\t\tll d = yd[y];",
            "\t\tll upper = (f + d) / 2;",
            "\t\tll lower = (f - d + 1) / 2;",
            "\t\tyID[y] = curr++;",
            "\t\tif (lower > upper) {",
            "\t\t\tcout << -1 << '\\n';",
            "\t\t\treturn;",
            "\t\t}",
            "\t\tg.add(yID[y], g.t, upper, lower);",
            "\t}",
            "\tvector<int> edges;",
            "\tfor (auto [x, y] : pts)",
            "\t\tedges.push_back(g.add(xID[x], yID[y], 1));",
            "\tauto [able, flow] = g.maxFlowWithDemands();",
            "\tif (!able) {",
            "\t\tcout << -1 << '\\n';",
            "\t\treturn;",
            "\t}",
            "\tchar rc = 'r', bc = 'b';",
            "\tif (r < b) swap(r, b), swap(rc, bc);",
            "\tcout << n * r - flow * (r - b) << '\\n';",
            "\tfor (int i : edges) cout << (g.get(i).flow() ? bc : rc);",
            "\tcout << '\\n';",
            "}",
            "int main() {",
            "\tcin.tie(0)->sync_with_stdio(0);",
            "\tcin.exceptions(cin.failbit);",
            "\t// int t; cin >> t; while (t--)",
            "\tsolve();",
            "\treturn 0;",
            "}"
        ],
        "prefix": [
            "hack_CaptainAmerica"
        ]
    },
    "CircleIntersection.h": {
        "body": [
            "typedef Point<double> P;",
            "bool circleInter(P a, P b, double r1, double r2,",
            "\tpair<P, P>* out) {",
            "\tif (a == b) return assert(r1 != r2), false;",
            "\tP vec = b - a;",
            "\tdouble d2 = vec.dist2(), sum = r1 + r2, dif = r1 - r2,",
            "\t\t\t\t p = (d2 + r1 * r1 - r2 * r2) / (d2 * 2),",
            "\t\t\t\t h2 = r1 * r1 - p * p * d2;",
            "\tif (sum * sum < d2 || dif * dif > d2) return false;",
            "\tP mid = a + vec * p,",
            "\t\tper = vec.perp() * sqrt(fmax(0, h2) / d2);",
            "\t*out = {mid + per, mid - per};",
            "\treturn true;",
            "}"
        ],
        "description": "Computes the pair of points at which two circles intersect. Returns false in case of no intersection.",
        "prefix": [
            "hack_CircleIntersection"
        ]
    },
    "CircleLine.h": {
        "body": [
            "template<class P>",
            "vector<P> circleLine(P c, double r, P a, P b) {",
            "\tP ab = b - a, p = a + ab * (c - a).dot(ab) / ab.dist2();",
            "\tdouble s = a.cross(b, c), h2 = r * r - s * s / ab.dist2();",
            "\tif (h2 < 0) return {};",
            "\tif (h2 == 0) return {p};",
            "\tP h = ab.unit() * sqrt(h2);",
            "\treturn {p - h, p + h};",
            "}"
        ],
        "description": "Finds the intersection between a circle and a line.\nReturns a vector of either 0, 1, or 2 intersection points.\nP is intended to be Point<double>.",
        "prefix": [
            "hack_CircleLine"
        ]
    },
    "CirclePolygonIntersection.h": {
        "body": [
            "typedef Point<double> P;",
            "#define arg(p, q) atan2(p.cross(q), p.dot(q))",
            "double circlePoly(P c, double r, vector<P> ps) {",
            "\tauto tri = [&](P p, P q) {",
            "\t\tauto r2 = r * r / 2;",
            "\t\tP d = q - p;",
            "\t\tauto a = d.dot(p) / d.dist2(),",
            "\t\t\t\t b = (p.dist2() - r * r) / d.dist2();",
            "\t\tauto det = a * a - b;",
            "\t\tif (det <= 0) return arg(p, q) * r2;",
            "\t\tauto s = max(0., -a - sqrt(det)),",
            "\t\t\t\t t = min(1., -a + sqrt(det));",
            "\t\tif (t < 0 || 1 <= s) return arg(p, q) * r2;",
            "\t\tP u = p + d * s, v = p + d * t;",
            "\t\treturn arg(p, u) * r2 + u.cross(v) / 2 + arg(v, q) * r2;",
            "\t};",
            "\tauto sum = 0.0;",
            "\trep(i, 0, sz(ps)) sum +=",
            "\t\ttri(ps[i] - c, ps[(i + 1) % sz(ps)] - c);",
            "\treturn sum;",
            "}"
        ],
        "description": "Returns the area of the intersection of a circle with a\nccw polygon.",
        "prefix": [
            "hack_CirclePolygonIntersection"
        ]
    },
    "CircleTangents.h": {
        "body": [
            "template<class P>",
            "vector<pair<P, P>> tangents(P c1, double r1, P c2, double r2) {",
            "\tP d = c2 - c1;",
            "\tdouble dr = r1 - r2, d2 = d.dist2(), h2 = d2 - dr * dr;",
            "\tif (d2 == 0 || h2 < 0) return {};",
            "\tvector<pair<P, P>> out;",
            "\tfor (double sign : {-1, 1}) {",
            "\t\tP v = (d * dr + d.perp() * sqrt(h2) * sign) / d2;",
            "\t\tout.push_back({c1 + v * r1, c2 + v * r2});",
            "\t}",
            "\tif (h2 == 0) out.pop_back();",
            "\treturn out;",
            "}"
        ],
        "description": "Finds the external tangents of two circles, or internal if r2 is negated.\nCan return 0, 1, or 2 tangents -- 0 if one circle contains the other (or overlaps it, in the internal case, or if the circles are the same);\n1 if the circles are tangent to each other (in which case .first = .second and the tangent line is perpendicular to the line between the centers).\n.first and .second give the tangency points at circle 1 and 2 respectively.\nTo find the tangents of a circle with a point set r2 to 0.",
        "prefix": [
            "hack_CircleTangents"
        ]
    },
    "ClosestPair.h": {
        "body": [
            "typedef Point<ll> P;",
            "pair<P, P> closest(vector<P> v) {",
            "\tassert(sz(v) > 1);",
            "\tset<P> S;",
            "\tsort(all(v), [](P a, P b) { return a.y < b.y; });",
            "\tpair<ll, pair<P, P>> ret{LLONG_MAX, {P(), P()}};",
            "\tint j = 0;",
            "\tfor (P p : v) {",
            "\t\tP d{1 + (ll)sqrt(ret.first), 0};",
            "\t\twhile (v[j].y <= p.y - d.x) S.erase(v[j++]);",
            "\t\tauto lo = S.lower_bound(p - d), hi = S.upper_bound(p + d);",
            "\t\tfor (; lo != hi; ++lo)",
            "\t\t\tret = min(ret, {(*lo - p).dist2(), {*lo, p}});",
            "\t\tS.insert(p);",
            "\t}",
            "\treturn ret.second;",
            "}"
        ],
        "description": "Finds the closest pair of points.",
        "prefix": [
            "hack_ClosestPair"
        ]
    },
    "CompressTree.h": {
        "body": [
            "typedef vector<pair<int, int>> vpi;",
            "vpi compressTree(LCA& lca, const vi& subset) {",
            "\tstatic vi rev;",
            "\trev.resize(sz(lca.time));",
            "\tvi li = subset, &T = lca.time;",
            "\tauto cmp = [&](int a, int b) { return T[a] < T[b]; };",
            "\tsort(all(li), cmp);",
            "\tint m = sz(li) - 1;",
            "\trep(i, 0, m) {",
            "\t\tint a = li[i], b = li[i + 1];",
            "\t\tli.push_back(lca.lca(a, b));",
            "\t}",
            "\tsort(all(li), cmp);",
            "\tli.erase(unique(all(li)), li.end());",
            "\trep(i, 0, sz(li)) rev[li[i]] = i;",
            "\tvpi ret = {pii(0, li[0])};",
            "\trep(i, 0, sz(li) - 1) {",
            "\t\tint a = li[i], b = li[i + 1];",
            "\t\tret.emplace_back(rev[lca.lca(a, b)], b);",
            "\t}",
            "\treturn ret;",
            "}"
        ],
        "description": "Given a rooted tree and a subset S of nodes, compute the minimal\nsubtree that contains all the nodes by adding all (at most $|S|-1$)\npairwise LCA's and compressing edges.\nReturns a list of (par, orig\\_index) representing a tree rooted at 0.\nThe root points to itself.",
        "prefix": [
            "hack_CompressTree"
        ]
    },
    "ContinuedFractions.h": {
        "body": [
            "typedef double d; // for N ~ 1e7; long double for N ~ 1e9",
            "pair<ll, ll> approximate(d x, ll N) {",
            "\tll LP = 0, LQ = 1, P = 1, Q = 0, inf = LLONG_MAX;",
            "\td y = x;",
            "\tfor (;;) {",
            "\t\tll lim =",
            "\t\t\t\t min(P ? (N - LP) / P : inf, Q ? (N - LQ) / Q : inf),",
            "\t\t\t a = (ll)floor(y), b = min(a, lim), NP = b * P + LP,",
            "\t\t\t NQ = b * Q + LQ;",
            "\t\tif (a > b) {",
            "\t\t\t// If b > a/2, we have a semi-convergent that gives us a",
            "\t\t\t// better approximation; if b = a/2, we *may* have one.",
            "\t\t\t// Return {P, Q} here for a more canonical approximation.",
            "\t\t\treturn (abs(x - (d)NP / (d)NQ) < abs(x - (d)P / (d)Q))",
            "\t\t\t\t? make_pair(NP, NQ)",
            "\t\t\t\t: make_pair(P, Q);",
            "\t\t}",
            "\t\tif (abs(y = 1 / (y - (d)a)) > 3 * N) return {NP, NQ};",
            "\t\tLP = P;",
            "\t\tP = NP;",
            "\t\tLQ = Q;",
            "\t\tQ = NQ;",
            "\t}",
            "}"
        ],
        "description": "Given $N$ and a real number $x \\ge 0$, finds the closest rational approximation $p/q$ with $p, q \\le N$.\nIt will obey $|p/q - x| \\le 1/qN$.\n\nFor consecutive convergents, $p_{k+1}q_k - q_{k+1}p_k = (-1)^k$.\n($p_k/q_k$ alternates between $>x$ and $<x$.)\nIf $x$ is rational, $y$ eventually becomes $\\infty$;\nif $x$ is the root of a degree $2$ polynomial the $a$'s eventually become cyclic.",
        "prefix": [
            "hack_ContinuedFractions"
        ]
    },
    "ConvexHull.h": {
        "body": [
            "typedef Point<ll> P;",
            "vector<P> convexHull(vector<P> pts) {",
            "\tif (sz(pts) <= 1) return pts;",
            "\tsort(all(pts));",
            "\tvector<P> h(sz(pts) + 1);",
            "\tint s = 0, t = 0;",
            "\tfor (int it = 2; it--; s = --t, reverse(all(pts)))",
            "\t\tfor (P p : pts) {",
            "\t\t\twhile (t >= s + 2 && h[t - 2].cross(h[t - 1], p) <= 0)",
            "\t\t\t\tt--;",
            "\t\t\th[t++] = p;",
            "\t\t}",
            "\treturn {h.begin(), h.begin() + t - (t == 2 && h[0] == h[1])};",
            "}"
        ],
        "description": "\\\\\\begin{minipage}{75mm}\nReturns a vector of the points of the convex hull in counter-clockwise order.\nPoints on the edge of the hull between two other points are not considered part of the hull.\n\\end{minipage}\n\\begin{minipage}{15mm}\n\\vspace{-6mm}\n\\includegraphics[width=\\textwidth]{content/geometry/ConvexHull}\n\\vspace{-6mm}\n\\end{minipage}",
        "prefix": [
            "hack_ConvexHull"
        ]
    },
    "CountPrimes.h": {
        "body": [
            "const int SQN = 320'000;",
            "bool notPrime[SQN];",
            "ll countprimes(ll n) {",
            "\tvector<ll> divs;",
            "\tfor (ll i = 1; i * i <= n; i++) {",
            "\t\tdivs.push_back(i);",
            "\t\tdivs.push_back(n / i);",
            "\t}",
            "\tsort(all(divs));",
            "\tdivs.erase(unique(all(divs)), end(divs));",
            "\tvector<ll> dp(sz(divs));",
            "\tfor (int i = 0; i < sz(divs); i++) dp[i] = divs[i] - 1;",
            "\tll sq = sqrt(n), sum = 0;",
            "\tauto idx = [&](ll x) -> int {",
            "\t\treturn x <= sq ? x - 1 : (sz(divs) - n / x);",
            "\t};",
            "\tfor (ll p = 2; p * p <= n; p++)",
            "\t\tif (!notPrime[p]) {",
            "\t\t\tll p2 = p * p;",
            "\t\t\tfor (ll i = sz(divs) - 1; i >= 0 && divs[i] >= p2; i--)",
            "\t\t\t\tdp[i] -= dp[idx(divs[i] / p)] - sum;",
            "\t\t\tsum += 1;",
            "\t\t\tfor (ll i = p * p; i < SQN && i * i <= n; i += p)",
            "\t\t\t\tnotPrime[i] = 1;",
            "\t\t}",
            "\treturn dp.back();",
            "}"
        ],
        "description": "Count primes in $O(N^\\frac{3}{4})$.",
        "prefix": [
            "hack_CountPrimes"
        ]
    },
    "DSU.h": {
        "body": [
            "struct DSU {",
            "\tvector<int> s;",
            "\tDSU(int n): s(n, -1) {}",
            "\tint find(int i) { return s[i] < 0 ? i : s[i] = find(s[i]); }",
            "\tbool join(int a, int b) {",
            "\t\ta = find(a), b = find(b);",
            "\t\tif (a == b) return false;",
            "\t\tif (s[a] > s[b]) swap(a, b);",
            "\t\ts[a] += s[b], s[b] = a;",
            "\t\treturn true;",
            "\t}",
            "\tint size(int i) { return -s[find(i)]; }",
            "\tbool same(int a, int b) { return find(a) == find(b); }",
            "};"
        ],
        "description": "Maintains union of disjoint sets.",
        "prefix": [
            "hack_DSU"
        ]
    },
    "DSURestorable.h": {
        "body": [
            "struct RestorableDSU {",
            "\tvector<int> s;",
            "\tvector<pair<int, int>> stk;",
            "\tRestorableDSU(int n): s(n, -1) {}",
            "\tint find(int i) { return s[i] < 0 ? i : find(s[i]); }",
            "\tbool join(int a, int b) {",
            "\t\ta = find(a), b = find(b);",
            "\t\tif (a == b) return false;",
            "\t\tif (s[a] > s[b]) swap(a, b);",
            "\t\tstk.emplace_back(a, s[a]);",
            "\t\tstk.emplace_back(b, s[b]);",
            "\t\ts[a] += s[b], s[b] = a;",
            "\t\treturn true;",
            "\t}",
            "\tint time() { return stk.size(); }",
            "\tvoid revert(int t) {",
            "\t\twhile (stk.size() > t)",
            "\t\t\ts[stk.back().first] = stk.back().second, stk.pop_back();",
            "\t}",
            "\tint size(int i) { return -s[find(i)]; }",
            "\tbool same(int a, int b) { return find(a) == find(b); }",
            "};"
        ],
        "description": "Maintains union of disjoint sets, and can\nrevert to previous states.",
        "prefix": [
            "hack_DSURestorable"
        ]
    },
    "DelaunayTriangulation.h": {
        "body": [
            "template<class P, class F>",
            "void delaunay(vector<P>& ps, F trifun) {",
            "\tif (sz(ps) == 3) {",
            "\t\tint d = (ps[0].cross(ps[1], ps[2]) < 0);",
            "\t\ttrifun(0, 1 + d, 2 - d);",
            "\t}",
            "\tvector<P3> p3;",
            "\tfor (P p : ps) p3.emplace_back(p.x, p.y, p.dist2());",
            "\tif (sz(ps) > 3)",
            "\t\tfor (auto t : hull3d(p3))",
            "\t\t\tif ((p3[t.b] - p3[t.a])",
            "\t\t\t\t\t\t.cross(p3[t.c] - p3[t.a])",
            "\t\t\t\t\t\t.dot(P3(0, 0, 1)) < 0)",
            "\t\t\t\ttrifun(t.a, t.c, t.b);",
            "}"
        ],
        "description": "Computes the Delaunay triangulation of a set of points.\nEach circumcircle contains none of the input points.\nIf any three points are collinear or any four are on the same circle, behavior is undefined.",
        "prefix": [
            "hack_DelaunayTriangulation"
        ]
    },
    "Determinant.h": {
        "body": [
            "double det(vector<vector<double>>& a) {",
            "\tint n = sz(a);",
            "\tdouble res = 1;",
            "\trep(i, 0, n) {",
            "\t\tint b = i;",
            "\t\trep(j, i + 1, n) if (fabs(a[j][i]) > fabs(a[b][i])) b = j;",
            "\t\tif (i != b) swap(a[i], a[b]), res *= -1;",
            "\t\tres *= a[i][i];",
            "\t\tif (res == 0) return 0;",
            "\t\trep(j, i + 1, n) {",
            "\t\t\tdouble v = a[j][i] / a[i][i];",
            "\t\t\tif (v != 0) rep(k, i + 1, n) a[j][k] -= v * a[i][k];",
            "\t\t}",
            "\t}",
            "\treturn res;",
            "}"
        ],
        "description": "Calculates determinant of a matrix. Destroys the matrix.",
        "prefix": [
            "hack_Determinant"
        ]
    },
    "Dijkstra.h": {
        "body": [
            "template<class T>",
            "pair<vector<bool>, vector<T>> dijkstra(",
            "\tconst vector<vector<pair<int, T>>>& adj, int s) {",
            "\tusing ST = pair<T, int>;",
            "\tpriority_queue<ST, vector<ST>, greater<ST>> q;",
            "\tvector<T> dist(adj.size());",
            "\tvector<bool> seen(adj.size());",
            "\tq.emplace(T{}, s);",
            "\tseen[s] = 1;",
            "\twhile (!q.empty()) {",
            "\t\tauto [d, u] = q.top();",
            "\t\tq.pop();",
            "\t\tif (dist[u] < d) continue;",
            "\t\tfor (auto [v, w] : adj[u])",
            "\t\t\tif (!seen[v] || d + w < dist[v]) {",
            "\t\t\t\tq.emplace(dist[v] = d + w, v);",
            "\t\t\t\tseen[v] = 1;",
            "\t\t\t}",
            "\t}",
            "\treturn {seen, dist};",
            "}"
        ],
        "description": "Computes shortest paths from s\nto any node reachable from s.\nPass in an adjacency list of pairs (node, weight).",
        "prefix": [
            "hack_Dijkstra"
        ]
    },
    "DirectedMST.h": {
        "body": [
            "struct Edge {",
            "\tint a, b;",
            "\tll w;",
            "};",
            "struct Node {",
            "\tEdge key;",
            "\tNode *l, *r;",
            "\tll delta;",
            "\tvoid prop() {",
            "\t\tkey.w += delta;",
            "\t\tif (l) l->delta += delta;",
            "\t\tif (r) r->delta += delta;",
            "\t\tdelta = 0;",
            "\t}",
            "\tEdge top() { return prop(), key; }",
            "};",
            "Node* merge(Node* a, Node* b) {",
            "\tif (!a || !b) return a ?: b;",
            "\ta->prop(), b->prop();",
            "\tif (a->key.w > b->key.w) swap(a, b);",
            "\tswap(a->l, (a->r = merge(b, a->r)));",
            "\treturn a;",
            "}",
            "void pop(Node*& a) { a->prop(), a = merge(a->l, a->r); }",
            "pair<ll, vi> dmst(int n, int r, vector<Edge>& g) {",
            "\tRollbackUF uf(n);",
            "\tvector<Node*> heap(n);",
            "\tfor (Edge e : g) heap[e.b] = merge(heap[e.b], new Node{e});",
            "\tll res = 0;",
            "\tvi seen(n, -1), path(n), par(n);",
            "\tseen[r] = r;",
            "\tvector<Edge> Q(n), in(n, {-1, -1}), comp;",
            "\tdeque<tuple<int, int, vector<Edge>>> cycs;",
            "\trep(s, 0, n) {",
            "\t\tint u = s, qi = 0, w;",
            "\t\twhile (seen[u] < 0) {",
            "\t\t\tif (!heap[u]) return {-1, {}};",
            "\t\t\tEdge e = heap[u]->top();",
            "\t\t\theap[u]->delta -= e.w, pop(heap[u]);",
            "\t\t\tQ[qi] = e, path[qi++] = u, seen[u] = s;",
            "\t\t\tres += e.w, u = uf.find(e.a);",
            "\t\t\tif (seen[u] == s) {",
            "\t\t\t\tNode* cyc = 0;",
            "\t\t\t\tint end = qi, time = uf.time();",
            "\t\t\t\tdo cyc = merge(cyc, heap[w = path[--qi]]);",
            "\t\t\t\twhile (uf.join(u, w));",
            "\t\t\t\tu = uf.find(u), heap[u] = cyc, seen[u] = -1;",
            "\t\t\t\tcycs.push_front({u, time, {&Q[qi], &Q[end]}});",
            "\t\t\t}",
            "\t\t}",
            "\t\trep(i, 0, qi) in[uf.find(Q[i].b)] = Q[i];",
            "\t}",
            "\tfor (auto& [u, t, comp] : cycs) { // restore sol (optional)",
            "\t\tuf.rollback(t);",
            "\t\tEdge inEdge = in[u];",
            "\t\tfor (auto& e : comp) in[uf.find(e.b)] = e;",
            "\t\tin[uf.find(inEdge.b)] = inEdge;",
            "\t}",
            "\trep(i, 0, n) par[i] = in[i].a;",
            "\treturn {res, par};",
            "}"
        ],
        "description": "Finds a minimum spanning\ntree/arborescence of a directed graph, given a root node. If no MST exists, returns -1.",
        "prefix": [
            "hack_DirectedMST"
        ]
    },
    "DynamicDiameter.h": {
        "body": [
            "#define all(x) begin(x), end(x)",
            "#define rep(a, b, c) for (int a = b; a < c; a++)",
            "using namespace std;",
            "using vi = vector<int>;",
            "using ll = long long;",
            "pair<ll, int> operator+(ll x, const pair<ll, int>& o) {",
            "\treturn {x + o.first, o.second};",
            "}",
            "template<class T1, class T2>",
            "ostream& operator<<(ostream& cout, const pair<T1, T2>& o) {",
            "\treturn cout << o.first << \":\" << o.second;",
            "}",
            "struct LinkCut {",
            "\tstruct Node {",
            "\t\tint p = 0, c[2] = {0, 0}, pp = 0;",
            "\t\tpair<ll, int> ppv = {0, 0};",
            "\t\tbool flip = 0;",
            "\t\tll sum = 0, val = 0;",
            "\t\tpair<ll, int> dpL = {0, 0}, dpR = {0, 0};",
            "\t\tmultiset<pair<ll, int>> hanging;",
            "\t};",
            "\tvector<Node> T;",
            "\tLinkCut(int n): T(n + 1) {}",
            "\tint dir(int x, int y) { return T[x].c[1] == y; }",
            "\tvoid set(int x, int d, int y) {",
            "\t\tif (x) T[x].c[d] = y, pull(x);",
            "\t\tif (y) T[y].p = x;",
            "\t}",
            "\tll getSum(int x) { return x ? T[x].sum : 0; }",
            "\tpair<ll, int> getDPL(int x) {",
            "\t\treturn x ? (!T[x].flip ? T[x].dpL : T[x].dpR)",
            "\t\t\t\t\t\t : make_pair(0ll, 0);",
            "\t}",
            "\tpair<ll, int> getDPR(int x) {",
            "\t\treturn x ? (!T[x].flip ? T[x].dpR : T[x].dpL)",
            "\t\t\t\t\t\t : make_pair(0ll, 0);",
            "\t}",
            "\tvoid pull(int x) {",
            "\t\tif (!x) return;",
            "\t\tint &l = T[x].c[0], &r = T[x].c[1];",
            "\t\tT[x].sum = T[x].val + getSum(l) + getSum(r);",
            "\t\tpair<ll, int> hang = {0, 0};",
            "\t\tif (T[x].hanging.size()) hang = *T[x].hanging.rbegin();",
            "\t\tT[x].dpL = max(getDPL(l),",
            "\t\t\tgetSum(l) + T[x].val + max(hang, getDPL(r)));",
            "\t\tif (T[x].dpL.second == 0) T[x].dpL.second = x;",
            "\t\tT[x].dpR = max(getDPR(r),",
            "\t\t\tgetSum(r) + T[x].val + max(hang, getDPR(l)));",
            "\t\tif (T[x].dpR.second == 0) T[x].dpR.second = x;",
            "\t}",
            "\tvoid push(int x) {",
            "\t\tif (!x || !T[x].flip) return;",
            "\t\tint &l = T[x].c[0], &r = T[x].c[1];",
            "\t\tif (l) T[l].flip ^= 1;",
            "\t\tif (r) T[r].flip ^= 1;",
            "\t\tswap(T[x].dpL, T[x].dpR);",
            "\t\tswap(l, r);",
            "\t\tT[x].flip = 0;",
            "\t}",
            "\tvoid rotate(int x, int d) {",
            "\t\tint y = T[x].p, z = T[y].p, w = T[x].c[d];",
            "\t\tswap(T[x].pp, T[y].pp);",
            "\t\tswap(T[x].ppv, T[y].ppv);",
            "\t\tset(y, !d, w);",
            "\t\tset(x, d, y);",
            "\t\tset(z, dir(z, y), x);",
            "\t}",
            "\tvoid splay(int x) {",
            "\t\tfor (push(x); T[x].p;) {",
            "\t\t\tint y = T[x].p, z = T[y].p;",
            "\t\t\tpush(z), push(y), push(x);",
            "\t\t\tint dx = dir(y, x), dy = dir(z, y);",
            "\t\t\tif (!z) rotate(x, !dx);",
            "\t\t\telse if (dx == dy) rotate(y, !dx), rotate(x, !dx);",
            "\t\t\telse rotate(x, dy), rotate(x, dx);",
            "\t\t}",
            "\t}",
            "\tvoid Access(int _u) {",
            "\t\tfor (int v = 0, u = _u; u; u = T[v = u].pp) {",
            "\t\t\tsplay(u), splay(v);",
            "\t\t\tint r = T[u].c[1];",
            "\t\t\tT[v].pp = 0;",
            "\t\t\tif (r) {",
            "\t\t\t\tT[u].hanging.insert(getDPL(r));",
            "\t\t\t\tT[r].ppv = getDPL(r);",
            "\t\t\t}",
            "\t\t\tif (v) {",
            "\t\t\t\tauto it = T[u].hanging.find(T[v].ppv);",
            "\t\t\t\tif (it != T[u].hanging.end()) T[u].hanging.erase(it);",
            "\t\t\t}",
            "\t\t\tswap(T[r].p, T[r].pp);",
            "\t\t\tset(u, 1, v);",
            "\t\t}",
            "\t\tsplay(_u);",
            "\t}",
            "\t// to be able reroot a tree, you must be able to reverse",
            "\t// the inorder trav. of the splay tree",
            "\t// can be skipped if that is not possible",
            "\tvoid MakeRoot(int u) {",
            "\t\tAccess(u);",
            "\t\tif (int l = T[u].c[0]) {",
            "\t\t\tT[l].flip ^= 1;",
            "\t\t\tswap(T[l].p, T[l].pp);",
            "\t\t\tT[l].ppv = getDPL(l);",
            "\t\t\tT[u].hanging.insert(getDPL(l));",
            "\t\t}",
            "\t\tset(u, 0, 0);",
            "\t}",
            "\tvoid Link(int u, int v) { // v is a child of u",
            "\t\tAccess(u), Access(v);",
            "\t\tMakeRoot(v); // not needed if v is always a forest root",
            "\t\tset(u, 0, v);",
            "\t}",
            "\tvoid Cut(int u) { // cut u from its parent",
            "\t\tAccess(u);",
            "\t\tif (int l = T[u].c[0]) T[l].p = 0;",
            "\t\tset(u, 0, 0);",
            "\t}",
            "\tint FindRoot(int u) {",
            "\t\tAccess(u);",
            "\t\twhile (T[u].c[0]) u = T[u].c[0];",
            "\t\tsplay(u);",
            "\t\treturn u;",
            "\t}",
            "\tbool Connected(int u, int v) {",
            "\t\treturn FindRoot(u) == FindRoot(v);",
            "\t}",
            "\t// get a splay tree representing the u -> v path",
            "\tint GetPath(int u, int v) {",
            "\t\treturn MakeRoot(u), Access(v), v;",
            "\t}",
            "};",
            "void build(int u, int p, vector<vi>& adj, LinkCut& lct) {",
            "\tfor (int v : adj[u])",
            "\t\tif (v != p) {",
            "\t\t\tlct.Link(v, u);",
            "\t\t\tbuild(v, u, adj, lct);",
            "\t\t}",
            "}",
            "void solve() {",
            "\tint n, q;",
            "\tll maxW;",
            "\tcin >> n >> q >> maxW;",
            "\tvector<vi> adj(2 * n + 1);",
            "\tvector<ll> w(2 * n + 1);",
            "\tLinkCut lct(2 * n + 1);",
            "\tfor (int i = 0; i < n - 1; i++) {",
            "\t\tint mid = n + 1 + i;",
            "\t\tint u, v;",
            "\t\tcin >> u >> v >> w[mid];",
            "\t\tadj[u].push_back(mid);",
            "\t\tadj[mid].push_back(u);",
            "\t\tadj[v].push_back(mid);",
            "\t\tadj[mid].push_back(v);",
            "\t}",
            "\tfor (int i = 1; i <= 2 * n; i++) lct.T[i].val = w[i];",
            "\tbuild(1, -1, adj, lct);",
            "\tll last = 0;",
            "\tint root = 1;",
            "\tlct.MakeRoot(1);",
            "\tfor (int qq = 0; qq < q; qq++) {",
            "\t\tll d, e;",
            "\t\tcin >> d >> e;",
            "\t\td = (d + last) % (n - 1);",
            "\t\te = (e + last) % maxW;",
            "\t\tint idx = n + 1 + d;",
            "\t\tlct.Access(idx);",
            "\t\tlct.T[idx].val = e;",
            "\t\tlct.push(idx);",
            "\t\tlct.pull(idx);",
            "\t\tlct.Access(root);",
            "\t\tauto [_, diam1] = lct.getDPL(root);",
            "\t\tlct.MakeRoot(root = diam1);",
            "\t\tauto [ans, __] = lct.getDPL(root);",
            "\t\tcout << ans << '\\n';",
            "\t\tlast = ans;",
            "\t}",
            "}",
            "int main() {",
            "\tcin.tie(0)->sync_with_stdio(0);",
            "\tcin.exceptions(cin.failbit);",
            "\tsolve();",
            "\treturn 0;",
            "}"
        ],
        "prefix": [
            "hack_DynamicDiameter"
        ]
    },
    "EdgeColoring.h": {
        "body": [
            "vi edgeColoring(int N, vector<pii> eds) {",
            "\tvi cc(N + 1), ret(sz(eds)), fan(N), free(N), loc;",
            "\tfor (pii e : eds) ++cc[e.first], ++cc[e.second];",
            "\tint u, v, ncols = *max_element(all(cc)) + 1;",
            "\tvector<vi> adj(N, vi(ncols, -1));",
            "\tfor (pii e : eds) {",
            "\t\ttie(u, v) = e;",
            "\t\tfan[0] = v;",
            "\t\tloc.assign(ncols, 0);",
            "\t\tint at = u, end = u, d, c = free[u], ind = 0, i = 0;",
            "\t\twhile (d = free[v], !loc[d] && (v = adj[u][d]) != -1)",
            "\t\t\tloc[d] = ++ind, cc[ind] = d, fan[ind] = v;",
            "\t\tcc[loc[d]] = c;",
            "\t\tfor (int cd = d; at != -1; cd ^= c ^ d, at = adj[at][cd])",
            "\t\t\tswap(adj[at][cd], adj[end = at][cd ^ c ^ d]);",
            "\t\twhile (adj[fan[i]][d] != -1) {",
            "\t\t\tint left = fan[i], right = fan[++i], e = cc[i];",
            "\t\t\tadj[u][e] = left;",
            "\t\t\tadj[left][e] = u;",
            "\t\t\tadj[right][e] = -1;",
            "\t\t\tfree[right] = e;",
            "\t\t}",
            "\t\tadj[u][d] = fan[i];",
            "\t\tadj[fan[i]][d] = u;",
            "\t\tfor (int y : {fan[0], u, end})",
            "\t\t\tfor (int& z = free[y] = 0; adj[y][z] != -1; z++)",
            "\t\t\t\t;",
            "\t}",
            "\trep(i, 0, sz(eds)) for (tie(u, v) = eds[i];",
            "\t\t\t\t\t\t\t\t\t\t\t\t\tadj[u][ret[i]] != v;)++ ret[i];",
            "\treturn ret;",
            "}"
        ],
        "description": "Given a simple, undirected graph with max degree $D$, computes a\n$(D + 1)$-coloring of the edges such that no neighboring edges share a color.\n($D$-coloring is NP-hard, but can be done for bipartite graphs by repeated matchings of\nmax-degree nodes.)",
        "prefix": [
            "hack_EdgeColoring"
        ]
    },
    "EulerWalk.h": {
        "body": [
            "vi eulerWalk(vector<vector<pii>>& gr, int nedges,",
            "\tint src = 0) {",
            "\tint n = sz(gr);",
            "\tvi D(n), its(n), eu(nedges), ret, s = {src};",
            "\tD[src]++; // to allow Euler paths, not just cycles",
            "\twhile (!s.empty()) {",
            "\t\tint x = s.back(), y, e, &it = its[x], end = sz(gr[x]);",
            "\t\tif (it == end) {",
            "\t\t\tret.push_back(x), s.pop_back();",
            "\t\t\tcontinue;",
            "\t\t}",
            "\t\ttie(y, e) = gr[x][it++];",
            "\t\tif (!eu[e]) {",
            "\t\t\tD[x]--, D[y]++;",
            "\t\t\teu[e] = 1, s.push_back(y);",
            "\t\t}",
            "\t}",
            "\tfor (int x : D)",
            "\t\tif (x < 0 || sz(ret) != nedges + 1) return {};",
            "\treturn {ret.rbegin(), ret.rend()};",
            "}"
        ],
        "description": "Eulerian undirected/directed path/cycle algorithm.\nInput should be a vector of (dest, global edge index), where\nfor undirected graphs, forward/backward edges have the same index.\nReturns a list of nodes in the Eulerian path/cycle with src at both start and end, or\nempty list if no cycle/path exists.\nTo get edge indices back, add .second to s and ret.",
        "prefix": [
            "hack_EulerWalk"
        ]
    },
    "ExtendedEuclidean.h": {
        "body": [
            "ll euclid(ll a, ll b, ll &x, ll &y) {",
            "\tif (!b) return x = 1, y = 0, a;",
            "\tll d = euclid(b, a % b, y, x);",
            "\treturn y -= a / b * x, d;",
            "}"
        ],
        "description": "Finds two integers $x$ and $y$, such that $ax+by=\\gcd(a,b)$. If\nyou just need gcd, use the built in \\texttt{\\_\\_gcd} instead.\nIf $a$ and $b$ are coprime, then $x$ is the inverse of $a \\pmod{b}$.",
        "prefix": [
            "hack_ExtendedEuclidean"
        ]
    },
    "FMIndex.h": {
        "body": [
            "const int LIM = 26, A = 'A';",
            "struct FMIndex: SuffixArray {",
            "\tvector<array<int, LIM>> freq;",
            "\tarray<int, LIM + 1> occ = {1};",
            "\tFMIndex(string& s): SuffixArray(s), freq(sz(s) + 2) {",
            "\t\trep(i, 0, sz(sa)) {",
            "\t\t\tfreq[i + 1] = freq[i];",
            "\t\t\tint p = sa[i] - 1;",
            "\t\t\tif (p >= 0) freq[i + 1][s[p] - A]++, occ[s[p] - A + 1]++;",
            "\t\t}",
            "\t\trep(i, 0, LIM) occ[i + 1] += occ[i];",
            "\t} // prepend c at pos i",
            "\tint add(int i, char c) {",
            "\t\treturn occ[c - A] + freq[i][c - A];",
            "\t}",
            "\tvector<pii> query(string& q) { // inclusive-exclusive",
            "\t\tvector<pii> ret(sz(q) + 1);",
            "\t\tauto [L, R] = ret.back() = {0, sz(sa)};",
            "\t\tfor (int i = sz(q) - 1; i >= 0; i--)",
            "\t\t\tret[i] = {L = add(L, q[i]), R = add(R, q[i])};",
            "\t\treturn ret;",
            "\t}",
            "};"
        ],
        "prefix": [
            "hack_FMIndex"
        ]
    },
    "Factor.h": {
        "body": [
            "ull pollard(ull n) {",
            "\tauto f = [n](ull x) { return modmul(x, x, n) + 1; };",
            "\tull x = 0, y = 0, t = 30, prd = 2, i = 1, q;",
            "\twhile (t++ % 40 || __gcd(prd, n) == 1) {",
            "\t\tif (x == y) x = ++i, y = f(x);",
            "\t\tif ((q = modmul(prd, max(x, y) - min(x, y), n))) prd = q;",
            "\t\tx = f(x), y = f(f(y));",
            "\t}",
            "\treturn __gcd(prd, n);",
            "}",
            "vector<ull> factor(ull n) {",
            "\tif (n == 1) return {};",
            "\tif (isPrime(n)) return {n};",
            "\tull x = pollard(n);",
            "\tauto l = factor(x), r = factor(n / x);",
            "\tl.insert(l.end(), all(r));",
            "\treturn l;",
            "}"
        ],
        "description": "Pollard-rho randomized factorization algorithm. Returns prime\nfactors of a number, in arbitrary order (e.g. 2299 -> \\{11, 19, 11\\}).",
        "prefix": [
            "hack_Factor"
        ]
    },
    "FastDelaunay.h": {
        "body": [
            "typedef Point<ll> P;",
            "typedef struct Quad* Q;",
            "typedef __int128_t lll; // (can be ll if coords are < 2e4)",
            "P arb(LLONG_MAX, LLONG_MAX); // not equal to any other point",
            "struct Quad {",
            "\tQ rot, o;",
            "\tP p = arb;",
            "\tbool mark;",
            "\tP& F() { return r()->p; }",
            "\tQ& r() { return rot->rot; }",
            "\tQ prev() { return rot->o->rot; }",
            "\tQ next() { return r()->prev(); }",
            "}* H;",
            "bool circ(P p, P a, P b, P c) { // is p in the circumcircle?",
            "\tlll p2 = p.dist2(), A = a.dist2() - p2, B = b.dist2() - p2,",
            "\t\t\tC = c.dist2() - p2;",
            "\treturn p.cross(a, b) * C + p.cross(b, c) * A +",
            "\t\tp.cross(c, a) * B >",
            "\t\t0;",
            "}",
            "Q makeEdge(P orig, P dest) {",
            "\tQ r = H ? H : new Quad{new Quad{new Quad{new Quad{0}}}};",
            "\tH = r->o;",
            "\tr->r()->r() = r;",
            "\trep(i, 0, 4) r = r->rot, r->p = arb,",
            "\t\t\t\t\t\t\t r->o = i & 1 ? r : r->r();",
            "\tr->p = orig, r->F() = dest;",
            "\treturn r;",
            "}",
            "void splice(Q a, Q b) {",
            "\tswap(a->o->rot->o, b->o->rot->o), swap(a->o, b->o);",
            "}",
            "Q connect(Q a, Q b) {",
            "\tQ q = makeEdge(a->F(), b->p);",
            "\tsplice(q, a->next());",
            "\tsplice(q->r(), b);",
            "\treturn q;",
            "}",
            "pair<Q, Q> rec(const vector<P>& s) {",
            "\tif (sz(s) <= 3) {",
            "\t\tQ a = makeEdge(s[0], s[1]), b = makeEdge(s[1], s.back());",
            "\t\tif (sz(s) == 2) return {a, a->r()};",
            "\t\tsplice(a->r(), b);",
            "\t\tauto side = s[0].cross(s[1], s[2]);",
            "\t\tQ c = side ? connect(b, a) : 0;",
            "\t\treturn {side < 0 ? c->r() : a, side < 0 ? c : b->r()};",
            "\t}",
            "#define H(e) e->F(), e->p",
            "#define valid(e) (e->F().cross(H(base)) > 0)",
            "\tQ A, B, ra, rb;",
            "\tint half = sz(s) / 2;",
            "\ttie(ra, A) = rec({all(s) - half});",
            "\ttie(B, rb) = rec({sz(s) - half + all(s)});",
            "\twhile ((B->p.cross(H(A)) < 0 && (A = A->next())) ||",
            "\t\t(A->p.cross(H(B)) > 0 && (B = B->r()->o)))",
            "\t\t;",
            "\tQ base = connect(B->r(), A);",
            "\tif (A->p == ra->p) ra = base->r();",
            "\tif (B->p == rb->p) rb = base;",
            "#define DEL(e, init, dir)                        \\",
            "\tQ e = init->dir;                               \\",
            "\tif (valid(e))                                  \\",
            "\t\twhile (circ(e->dir->F(), H(base), e->F())) { \\",
            "\t\t\tQ t = e->dir;                              \\",
            "\t\t\tsplice(e, e->prev());                      \\",
            "\t\t\tsplice(e->r(), e->r()->prev());            \\",
            "\t\t\te->o = H, H = e, e = t;                    \\",
            "\t\t}",
            "\tfor (;;) {",
            "\t\tDEL(LC, base->r(), o), DEL(RC, base, prev());",
            "\t\tif (!valid(LC) && !valid(RC)) break;",
            "\t\tif (!valid(LC) || (valid(RC) && circ(H(RC), H(LC))))",
            "\t\t\tbase = connect(RC, base->r());",
            "\t\telse base = connect(base->r(), LC->r());",
            "\t}",
            "\treturn {ra, rb};",
            "}",
            "vector<P> triangulate(vector<P> pts) {",
            "\tsort(all(pts)), assert(unique(all(pts)) == pts.end());",
            "\tif (sz(pts) < 2) return {};",
            "\tQ e = rec(pts).first;",
            "\tvector<Q> q = {e};",
            "\tint qi = 0;",
            "\twhile (e->o->F().cross(e->F(), e->p) < 0) e = e->o;",
            "#define ADD                                                  \\",
            "\t{                                                          \\",
            "\t\tQ c = e;                                                 \\",
            "\t\tdo                                                       \\",
            "\t\t\tc->mark = 1, pts.push_back(c->p), q.push_back(c->r()), \\",
            "\t\t\tc = c->next();                                         \\",
            "\t\twhile (c != e);                                          \\",
            "\t}",
            "\tADD;",
            "\tpts.clear();",
            "\twhile (qi < sz(q))",
            "\t\tif (!(e = q[qi++])->mark) ADD;",
            "\treturn pts;",
            "}"
        ],
        "description": "Fast Delaunay triangulation.\nEach circumcircle contains none of the input points.\nThere must be no duplicate points.\nIf all points are on a line, no triangles will be returned.\nShould work for doubles as well, though there may be precision issues in 'circ'.\nReturns triangles in order \\{t[0][0], t[0][1], t[0][2], t[1][0], \\dots\\}, all counter-clockwise.",
        "prefix": [
            "hack_FastDelaunay"
        ]
    },
    "FastFourierTransform.h": {
        "body": [
            "typedef complex<double> C;",
            "typedef vector<double> vd;",
            "void fft(vector<C>& a) {",
            "\tint n = sz(a), L = 31 - __builtin_clz(n);",
            "\tstatic vector<complex<long double>> R(2, 1);",
            "\tstatic vector<C> rt(2, 1); // (^ 10% faster if double)",
            "\tfor (static int k = 2; k < n; k *= 2) {",
            "\t\tR.resize(n);",
            "\t\trt.resize(n);",
            "\t\tauto x = polar(1.0L, acos(-1.0L) / k);",
            "\t\trep(i, k, 2 * k) rt[i] = R[i] =",
            "\t\t\ti & 1 ? R[i / 2] * x : R[i / 2];",
            "\t}",
            "\tvi rev(n);",
            "\trep(i, 0, n) rev[i] = (rev[i / 2] | (i & 1) << L) / 2;",
            "\trep(i, 0, n) if (i < rev[i]) swap(a[i], a[rev[i]]);",
            "\tfor (int k = 1; k < n; k *= 2)",
            "\t\tfor (int i = 0; i < n; i += 2 * k) rep(j, 0, k) {",
            "\t\t\t\tC z = rt[j+k] * a[i+j+k]; // (25% faster if hand-rolled)",
            "\t\t\t\tauto x = (double*)&rt[j + k],",
            "\t\t\t\tC z(x[0] * y[0] - x[1] * y[1],",
            "\t\t\t\ta[i + j + k] = a[i + j] - z;",
            "\t\t\t\ta[i + j] += z;",
            "\t\t\t}",
            "}",
            "vd conv(const vd& a, const vd& b) {",
            "\tif (a.empty() || b.empty()) return {};",
            "\tvd res(sz(a) + sz(b) - 1);",
            "\tint L = 32 - __builtin_clz(sz(res)), n = 1 << L;",
            "\tvector<C> in(n), out(n);",
            "\tcopy(all(a), begin(in));",
            "\trep(i, 0, sz(b)) in[i].imag(b[i]);",
            "\tfft(in);",
            "\tfor (C& x : in) x *= x;",
            "\trep(i, 0, n) out[i] = in[-i & (n - 1)] - conj(in[i]);",
            "\tfft(out);",
            "\trep(i, 0, sz(res)) res[i] = imag(out[i]) / (4 * n);",
            "\treturn res;",
            "}"
        ],
        "description": "fft(a) computes $\\hat f(k) = \\sum_x a[x] \\exp(2\\pi i \\cdot k x / N)$ for all $k$. N must be a power of 2.\nUseful for convolution:\n\\texttt{conv(a, b) = c}, where $c[x] = \\sum a[i]b[x-i]$.\nFor convolution of complex numbers or more than two vectors: FFT, multiply\npointwise, divide by n, reverse(start+1, end), FFT back.\nRounding is safe if $(\\sum a_i^2 + \\sum b_i^2)\\log_2{N} < 9\\cdot10^{14}$\n(in practice $10^{16}$; higher for random inputs).\nOtherwise, use NTT/FFTMod.",
        "prefix": [
            "hack_FastFourierTransform"
        ]
    },
    "FastFourierTransformMod.h": {
        "body": [
            "typedef vector<ll> vl;",
            "template<int M> vl convMod(const vl &a, const vl &b) {",
            "\tif (a.empty() || b.empty()) return {};",
            "\tvl res(sz(a) + sz(b) - 1);",
            "\tint B = 32 - __builtin_clz(sz(res)), n = 1 << B,",
            "\t\t\tcut = int(sqrt(M));",
            "\tvector<C> L(n), R(n), outs(n), outl(n);",
            "\trep(i, 0, sz(a)) L[i] = C((int)a[i] / cut, (int)a[i] % cut);",
            "\trep(i, 0, sz(b)) R[i] = C((int)b[i] / cut, (int)b[i] % cut);",
            "\tfft(L), fft(R);",
            "\trep(i, 0, n) {",
            "\t\tint j = -i & (n - 1);",
            "\t\toutl[j] = (L[i] + conj(L[j])) * R[i] / (2.0 * n);",
            "\t\touts[j] = (L[i] - conj(L[j])) * R[i] / (2.0 * n) / 1i;",
            "\t}",
            "\tfft(outl), fft(outs);",
            "\trep(i, 0, sz(res)) {",
            "\t\tll av = ll(real(outl[i]) + .5),",
            "\t\t\t cv = ll(imag(outs[i]) + .5);",
            "\t\tll bv = ll(imag(outl[i]) + .5) + ll(real(outs[i]) + .5);",
            "\t\tres[i] = ((av % M * cut + bv) % M * cut + cv) % M;",
            "\t}",
            "\treturn res;",
            "}"
        ],
        "description": "Higher precision FFT, can be used for convolutions modulo arbitrary integers\nas long as $N\\log_2N\\cdot \\text{mod} < 8.6 \\cdot 10^{14}$ (in practice $10^{16}$ or higher).\nInputs must be in $[0, \\text{mod})$.",
        "prefix": [
            "hack_FastFourierTransformMod"
        ]
    },
    "FastMod.h": {
        "body": [
            "typedef unsigned long long ull;",
            "struct FastMod {",
            "\tull b, m;",
            "\tFastMod(ull b): b(b), m(-1ULL / b) {}",
            "\tull reduce(ull a) { // a % b + (0 or b)",
            "\t\treturn a - (ull)((__uint128_t(m) * a) >> 64) * b;",
            "\t}",
            "};"
        ],
        "description": "Compute $a \\% b$ about 5 times faster than usual, where $b$ is constant but not known at compile time.\nReturns a value congruent to $a \\pmod b$ in the range $[0, 2b)$.",
        "prefix": [
            "hack_FastMod"
        ]
    },
    "FastSubsetTransform.h": {
        "body": [
            "void FST(vi& a, bool inv) {",
            "\tfor (int n = sz(a), step = 1; step < n; step *= 2) {",
            "\t\tfor (int i = 0; i < n; i += 2 * step) rep(j, i, i + step) {",
            "\t\t\t\tint &u = a[j], &v = a[j + step];",
            "\t\t\t\ttie(u, v) = inv ? pii(v - u, u) : pii(v, u + v); // AND",
            "\t\t\t\tinv ? pii(v, u - v) : pii(u + v, u); // OR",
            "\t\t\t\tpii(u + v, u - v);                   // XOR",
            "\t\t\t}",
            "\t}",
            "\tif (inv) for (int& x : a) x /= sz(a); // XOR only",
            "}",
            "vi conv(vi a, vi b) {",
            "\tFST(a, 0);",
            "\tFST(b, 0);",
            "\trep(i, 0, sz(a)) a[i] *= b[i];",
            "\tFST(a, 1);",
            "\treturn a;",
            "}"
        ],
        "description": "Transform to a basis with fast convolutions of the form\n$\\displaystyle c[z] = \\sum\\nolimits_{z = x \\oplus y} a[x] \\cdot b[y]$,\nwhere $\\oplus$ is one of AND, OR, XOR. The size of $a$ must be a power of two.",
        "prefix": [
            "hack_FastSubsetTransform"
        ]
    },
    "FloorRange.h": {
        "body": [
            "for (int i = 1, la; i <= n; i = la + 1) {",
            "\tla = n / (n / i);",
            "\t//n / x yields the same value for i <= x <= la.",
            "}"
        ],
        "prefix": [
            "hack_FloorRange"
        ]
    },
    "FracBinarySearch.h": {
        "body": [
            "struct Frac {",
            "\tll p, q;",
            "};",
            "template<class F> Frac fracBS(F f, ll N) {",
            "\tbool dir = 1, A = 1, B = 1;",
            "\tFrac lo{0, 1}, hi{1, 1}; // Set hi to 1/0 to search (0, N]",
            "\tif (f(lo)) return lo;",
            "\tassert(f(hi));",
            "\twhile (A || B) {",
            "\t\tll adv = 0, step = 1; // move hi if dir, else lo",
            "\t\tfor (int si = 0; step; (step *= 2) >>= si) {",
            "\t\t\tadv += step;",
            "\t\t\tFrac mid{lo.p * adv + hi.p, lo.q * adv + hi.q};",
            "\t\t\tif (abs(mid.p) > N || mid.q > N || dir == !f(mid)) {",
            "\t\t\t\tadv -= step;",
            "\t\t\t\tsi = 2;",
            "\t\t\t}",
            "\t\t}",
            "\t\thi.p += lo.p * adv;",
            "\t\thi.q += lo.q * adv;",
            "\t\tdir = !dir;",
            "\t\tswap(lo, hi);",
            "\t\tA = B;",
            "\t\tB = !!adv;",
            "\t}",
            "\treturn dir ? hi : lo;",
            "}"
        ],
        "description": "Given $f$ and $N$, finds the smallest fraction $p/q \\in [0, 1]$\nsuch that $f(p/q)$ is true, and $p, q \\le N$.\nYou may want to throw an exception from $f$ if it finds an exact solution,\nin which case $N$ can be removed.",
        "prefix": [
            "hack_FracBinarySearch"
        ]
    },
    "Fraction.h": {
        "body": [
            "template<class T> struct Q {",
            "\tT a, b;",
            "\tQ(T p, T q = 1) {",
            "\t\tT g = gcd(p, q);",
            "\t\ta = p / g;",
            "\t\tb = q / g;",
            "\t\tif (b < 0) a = -a, b = -b;",
            "\t}",
            "\tT gcd(T x, T y) const { return __gcd(x, y); }",
            "\tQ operator+(const Q& o) const {",
            "\t\treturn {a * o.b + o.a * b, b * o.b};",
            "\t}",
            "\tQ operator-(const Q& o) const {",
            "\t\treturn *this + Q(-o.a, o.b);",
            "\t}",
            "\tQ operator*(const Q& o) const { return {a * o.a, b * o.b}; }",
            "\tQ operator/(const Q& o) const { return *this * Q(o.b, o.a); }",
            "\tQ recip() const { return {b, a}; }",
            "\tint signum() const { return (a > 0) - (a < 0); }",
            "\tbool operator<(const Q& o) const {",
            "\t\treturn a * o.b < o.a * b;",
            "\t}",
            "\tfriend ostream& operator<<(ostream& cout, const Q& o) {",
            "\t\treturn cout << o.a << \"/\" << o.b;",
            "\t}",
            "};"
        ],
        "description": "Struct for representing fractions/rationals.\nAll ops are $O(\\log N)$ due to GCD in constructor.\nUses cross multiplication.",
        "prefix": [
            "hack_Fraction"
        ]
    },
    "FractionOverflow.h": {
        "body": [
            "template<class T> struct QO {",
            "\tT a, b;",
            "\tQO(T p, T q = 1) {",
            "\t\tT g = gcd(p, q);",
            "\t\ta = p / g;",
            "\t\tb = q / g;",
            "\t\tif (b < 0) a = -a, b = -b;",
            "\t}",
            "\tT gcd(T x, T y) const { return __gcd(x, y); }",
            "\tQO operator+(const QO& o) const {",
            "\t\tT g = gcd(b, o.b), bb = b / g, obb = o.b / g;",
            "\t\treturn {a * obb + o.a * bb, b * obb};",
            "\t}",
            "\tQO operator-(const QO& o) const {",
            "\t\treturn *this + QO(-o.a, o.b);",
            "\t}",
            "\tQO operator*(const QO& o) const {",
            "\t\tT g1 = gcd(a, o.b), g2 = gcd(o.a, b);",
            "\t\treturn {(a / g1) * (o.a / g2), (b / g2) * (o.b / g1)};",
            "\t}",
            "\tQO operator/(const QO& o) const {",
            "\t\treturn *this * QO(o.b, o.a);",
            "\t}",
            "\tQO recip() const { return {b, a}; }",
            "\tint signum() const { return (a > 0) - (a < 0); }",
            "\tstatic bool lessThan(T a, T b, T x, T y) {",
            "\t\tif (a / b != x / y) return a / b < x / y;",
            "\t\tif (x % y == 0) return false;",
            "\t\tif (a % b == 0) return true;",
            "\t\treturn lessThan(y, x % y, b, a % b);",
            "\t}",
            "\tbool operator<(const QO& o) const {",
            "\t\tif (this->signum() != o.signum() || a == 0) return a < o.a;",
            "\t\tif (a < 0) return lessThan(abs(o.a), o.b, abs(a), b);",
            "\t\telse return lessThan(a, b, o.a, o.b);",
            "\t}",
            "\tfriend ostream& operator<<(ostream& cout, const QO& o) {",
            "\t\treturn cout << o.a << \"/\" << o.b;",
            "\t}",
            "};"
        ],
        "description": "Safer struct for representing\nfractions/rationals. Comparison is 100\\% overflow safe;\nother ops are safer but can still overflow. All ops are\n$O(\\log N)$.",
        "prefix": [
            "hack_FractionOverflow"
        ]
    },
    "GeneralMatching.h": {
        "body": [
            "vector<pii> generalMatching(int N, vector<pii>& ed) {",
            "\tvector<vector<ll>> mat(N, vector<ll>(N)), A;",
            "\tfor (pii pa : ed) {",
            "\t\tint a = pa.first, b = pa.second, r = rand() % mod;",
            "\t\tmat[a][b] = r, mat[b][a] = (mod - r) % mod;",
            "\t}",
            "\tint r = matInv(A = mat), M = 2 * N - r, fi, fj;",
            "\tassert(r % 2 == 0);",
            "\tif (M != N) do {",
            "\t\t\tmat.resize(M, vector<ll>(M));",
            "\t\t\trep(i, 0, N) {",
            "\t\t\t\tmat[i].resize(M);",
            "\t\t\t\trep(j, N, M) {",
            "\t\t\t\t\tint r = rand() % mod;",
            "\t\t\t\t\tmat[i][j] = r, mat[j][i] = (mod - r) % mod;",
            "\t\t\t\t}",
            "\t\t\t}",
            "\t\t} while (matInv(A = mat) != M);",
            "\tvi has(M, 1);",
            "\tvector<pii> ret;",
            "\trep(it, 0, M / 2) {",
            "\t\trep(i, 0, M) if (has[i])",
            "\t\t\trep(j, i + 1, M) if (A[i][j] && mat[i][j]) {",
            "\t\t\tfi = i;",
            "\t\t\tfj = j;",
            "\t\t\tgoto done;",
            "\t\t}",
            "\t\tassert(0);",
            "done:",
            "\t\tif (fj < N) ret.emplace_back(fi, fj);",
            "\t\thas[fi] = has[fj] = 0;",
            "\t\trep(sw, 0, 2) {",
            "\t\t\tll a = modpow(A[fi][fj], mod - 2);",
            "\t\t\trep(i, 0, M) if (has[i] && A[i][fj]) {",
            "\t\t\t\tll b = A[i][fj] * a % mod;",
            "\t\t\t\trep(j, 0, M) A[i][j] = (A[i][j] - A[fi][j] * b) % mod;",
            "\t\t\t}",
            "\t\t\tswap(fi, fj);",
            "\t\t}",
            "\t}",
            "\treturn ret;",
            "}"
        ],
        "description": "Matching for general graphs.\nFails with probability $N / mod$.",
        "prefix": [
            "hack_GeneralMatching"
        ]
    },
    "GlobalMinCut.h": {
        "body": [
            "pair<int, vi> globalMinCut(vector<vi> mat) {",
            "\tpair<int, vi> best = {INT_MAX, {}};",
            "\tint n = sz(mat);",
            "\tvector<vi> co(n);",
            "\trep(i, 0, n) co[i] = {i};",
            "\trep(ph, 1, n) {",
            "\t\tvi w = mat[0];",
            "\t\tsize_t s = 0, t = 0;",
            "\t\trep(it, 0, n - ph) { // O(V^2)->O(E log V) with prio. queue",
            "\t\t\tw[t] = INT_MIN;",
            "\t\t\ts = t, t = max_element(all(w)) - w.begin();",
            "\t\t\trep(i, 0, n) w[i] += mat[t][i];",
            "\t\t}",
            "\t\tbest = min(best, {w[t] - mat[t][t], co[t]});",
            "\t\tco[s].insert(co[s].end(), all(co[t]));",
            "\t\trep(i, 0, n) mat[s][i] += mat[t][i];",
            "\t\trep(i, 0, n) mat[i][s] = mat[s][i];",
            "\t\tmat[0][t] = INT_MIN;",
            "\t}",
            "\treturn best;",
            "}"
        ],
        "description": "Find a global minimum cut in an undirected graph, as represented by an adjacency matrix.",
        "prefix": [
            "hack_GlobalMinCut"
        ]
    },
    "GoldenSectionSearch.h": {
        "body": [
            "double gss(double a, double b, double (*f)(double)) {",
            "\tdouble r = (sqrt(5) - 1) / 2, eps = 1e-7;",
            "\tdouble x1 = b - r * (b - a), x2 = a + r * (b - a);",
            "\tdouble f1 = f(x1), f2 = f(x2);",
            "\twhile (b - a > eps)",
            "\t\tif (f1 < f2) { //change to > to find maximum",
            "\t\t\tb = x2;",
            "\t\t\tx2 = x1;",
            "\t\t\tf2 = f1;",
            "\t\t\tx1 = b - r * (b - a);",
            "\t\t\tf1 = f(x1);",
            "\t\t} else {",
            "\t\t\ta = x1;",
            "\t\t\tx1 = x2;",
            "\t\t\tf1 = f2;",
            "\t\t\tx2 = a + r * (b - a);",
            "\t\t\tf2 = f(x2);",
            "\t\t}",
            "\treturn a;",
            "}"
        ],
        "description": "Finds the argument minimizing the function $f$ in the interval $[a,b]$ assuming $f$ is unimodal on the interval, i.e. has only one local minimum. The maximum error in the result is $eps$. Works equally well for maximization with a small change in the code. See TernarySearch.h in the Various chapter for a discrete version.",
        "prefix": [
            "hack_GoldenSectionSearch"
        ]
    },
    "GomoryHu.h": {
        "body": [
            "typedef array<ll, 3> Edge;",
            "vector<Edge> gomoryHu(int N, vector<Edge> ed) {",
            "\tvector<Edge> tree;",
            "\tvi par(N);",
            "\trep(i, 1, N) {",
            "\t\tPushRelabel D(N); // Dinic also works",
            "\t\tfor (Edge t : ed) D.addEdge(t[0], t[1], t[2], t[2]);",
            "\t\ttree.push_back({i, par[i], D.calc(i, par[i])});",
            "\t\trep(j, i + 1, N) if (par[j] == par[i] && D.leftOfMinCut(j))",
            "\t\t\tpar[j] = i;",
            "\t}",
            "\treturn tree;",
            "}"
        ],
        "description": "Given a list of edges representing an undirected flow graph,\nreturns edges of the Gomory-Hu tree. The max flow between any pair of\nvertices is given by minimum edge weight along the Gomory-Hu tree path.",
        "prefix": [
            "hack_GomoryHu"
        ]
    },
    "HLD.h": {
        "body": [
            "template<bool VALS_EDGES> struct HLD {",
            "\tint N, tim = 0;",
            "\tvector<vi> adj;",
            "\tvi par, siz, depth, rt, pos;",
            "\tNode* tree;",
            "\tHLD(vector<vi> adj_):",
            "\t\tN(sz(adj_)), adj(adj_), par(N, -1), siz(N, 1), depth(N),",
            "\t\trt(N), pos(N), tree(new Node(0, N)) {",
            "\t\tdfsSz(0), dfsHld(0);",
            "\t}",
            "\tvoid dfsSz(int v) {",
            "\t\tif (par[v] != -1) adj[v].erase(find(all(adj[v]), par[v]));",
            "\t\tfor (int& u : adj[v]) {",
            "\t\t\tpar[u] = v, depth[u] = depth[v] + 1;",
            "\t\t\tdfsSz(u);",
            "\t\t\tsiz[v] += siz[u];",
            "\t\t\tif (siz[u] > siz[adj[v][0]]) swap(u, adj[v][0]);",
            "\t\t}",
            "\t}",
            "\tvoid dfsHld(int v) {",
            "\t\tpos[v] = tim++;",
            "\t\tfor (int u : adj[v]) {",
            "\t\t\trt[u] = (u == adj[v][0] ? rt[v] : u);",
            "\t\t\tdfsHld(u);",
            "\t\t}",
            "\t}",
            "\ttemplate<class B> void process(int u, int v, B op) {",
            "\t\tfor (; rt[u] != rt[v]; v = par[rt[v]]) {",
            "\t\t\tif (depth[rt[u]] > depth[rt[v]]) swap(u, v);",
            "\t\t\top(pos[rt[v]], pos[v] + 1);",
            "\t\t}",
            "\t\tif (depth[u] > depth[v]) swap(u, v);",
            "\t\top(pos[u] + VALS_EDGES, pos[v] + 1);",
            "\t}",
            "\tvoid modifyPath(int u, int v, int val) {",
            "\t\tprocess(u, v, [&](int l, int r) { tree->add(l, r, val); });",
            "\t} // tree->add is [inclusive, exclusive)     ^",
            "\tint queryPath(int u, int v) { // Modify depending on problem",
            "\t\tint res = -1e9;",
            "\t\tprocess(u, v, [&](int l, int r) { // inclusive,exclusive",
            "\t\t\tres = max(res, tree->query(l, r));",
            "\t\t});",
            "\t\treturn res;",
            "\t}",
            "\tint querySubtree(int v) { // modifySubtree is similar",
            "\t\treturn tree->query(pos[v] + VALS_EDGES, pos[v] + siz[v]);",
            "\t}",
            "};"
        ],
        "description": "Decomposes a tree into vertex disjoint heavy paths and light\nedges such that the path from any leaf to the root contains at most log(n)\nlight edges. Code does additive modifications and max queries, but can\nsupport commutative segtree modifications/queries on paths and subtrees.\nTakes as input the full adjacency list. VALS\\_EDGES being true means that\nvalues are stored in the edges, as opposed to the nodes. All values\ninitialized to the segtree default. Root must be 0.",
        "prefix": [
            "hack_HLD"
        ]
    },
    "HashMap.h": {
        "body": [
            "#include <bits/extc++.h>",
            "// To use most bits rather than just the lowest ones:",
            "struct chash { // large odd number for C",
            "\tconst uint64_t C = ll(4e18 * acos(0)) | 71;",
            "\tll operator()(ll x) const {",
            "\t\treturn __builtin_bswap64(x * C);",
            "\t}",
            "};",
            "__gnu_pbds::gp_hash_table<ll, int, chash> h({}, {}, {}, {},",
            "\t{1 << 16});",
            "template<class T> // for auto resize",
            "using hash_map = __gnu_pbds::gp_hash_table<ll, T, chash>;"
        ],
        "description": "Hash map with mostly the same API as unordered\\_map, but \\tilde\n3x faster. Uses 1.5x memory.\nInitial capacity must be a power of 2 (if provided).",
        "prefix": [
            "hack_HashMap"
        ]
    },
    "Hashing.h": {
        "body": [
            "// Arithmetic mod 2^64-1. 2x slower than mod 2^64 and more",
            "// code, but works on evil test data (e.g. Thue-Morse, where",
            "// ABBA... and BAAB... of length 2^10 hash the same mod 2^64).",
            "// \"typedef ull H;\" instead if you think test data is random,",
            "// or work mod 10^9+7 if the Birthday paradox is not a problem.",
            "typedef uint64_t ull;",
            "struct H {",
            "\tull x;",
            "\tH(ull x = 0): x(x) {}",
            "\tH operator+(H o) { return x + o.x + (x + o.x < x); }",
            "\tH operator-(H o) { return *this + ~o.x; }",
            "\tH operator*(H o) {",
            "\t\tauto m = (__uint128_t)x * o.x;",
            "\t\treturn H((ull)m) + (ull)(m >> 64);",
            "\t}",
            "\tull get() const { return x + !~x; }",
            "\tbool operator==(H o) const { return get() == o.get(); }",
            "\tbool operator<(H o) const { return get() < o.get(); }",
            "};",
            "static const H C =",
            "\t(ll)1e11 + 3; // (order ~ 3e9; random also ok)",
            "struct HashInterval {",
            "\tvector<H> ha, pw;",
            "\tHashInterval(string& str): ha(sz(str) + 1), pw(ha) {",
            "\t\tpw[0] = 1;",
            "\t\trep(i, 0, sz(str)) ha[i + 1] = ha[i] * C + str[i],",
            "\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tpw[i + 1] = pw[i] * C;",
            "\t}",
            "\tH hashInterval(int a, int b) { // hash [a, b)",
            "\t\treturn ha[b] - ha[a] * pw[b - a];",
            "\t}",
            "};",
            "vector<H> getHashes(string& str, int length) {",
            "\tif (sz(str) < length) return {};",
            "\tH h = 0, pw = 1;",
            "\trep(i, 0, length) h = h * C + str[i], pw = pw * C;",
            "\tvector<H> ret = {h};",
            "\trep(i, length, sz(str)) {",
            "\t\tret.push_back(h = h * C + str[i] - pw * str[i - length]);",
            "\t}",
            "\treturn ret;",
            "}",
            "H hashString(string& s) {",
            "\tH h{};",
            "\tfor (char c : s) h = h * C + c;",
            "\treturn h;",
            "}"
        ],
        "description": "Self-explanatory methods for string hashing.",
        "prefix": [
            "hack_Hashing"
        ]
    },
    "HilbertMos.h": {
        "body": [
            "const int logn = 21, maxn = 1 << logn;",
            "ll hilbert(int x, int y) {",
            "\tll d = 0;",
            "\tfor (int s = 1 << (logn - 1); s > 0; s >>= 1) {",
            "\t\tint rx = x & s, ry = y & s;",
            "\t\td = d << 2 | rx * 3 ^ ry;",
            "\t\tif (ry == 0) {",
            "\t\t\tif (rx != 0) {",
            "\t\t\t\tx = maxn - x;",
            "\t\t\t\ty = maxn - y;",
            "\t\t\t}",
            "\t\t\tswap(x, y);",
            "\t\t}",
            "\t}",
            "\treturn d;",
            "}"
        ],
        "description": "Maps points on a $2^k \\times 2^k$ matrix\nto their index on the Hilbert curve.",
        "prefix": [
            "hack_HilbertMos"
        ]
    },
    "HillClimbing.h": {
        "body": [
            "typedef array<double, 2> P;",
            "template<class F> pair<double, P> hillClimb(P start, F f) {",
            "\tpair<double, P> cur(f(start), start);",
            "\tfor (double jmp = 1e9; jmp > 1e-20; jmp /= 2) {",
            "\t\trep(j, 0, 100) rep(dx, -1, 2) rep(dy, -1, 2) {",
            "\t\t\tP p = cur.second;",
            "\t\t\tp[0] += dx * jmp;",
            "\t\t\tp[1] += dy * jmp;",
            "\t\t\tcur = min(cur, make_pair(f(p), p));",
            "\t\t}",
            "\t}",
            "\treturn cur;",
            "}"
        ],
        "description": "Poor man's optimization for unimodal functions.",
        "prefix": [
            "hack_HillClimbing"
        ]
    },
    "HullDiameter.h": {
        "body": [
            "typedef Point<ll> P;",
            "array<P, 2> hullDiameter(vector<P> S) {",
            "\tint n = sz(S), j = n < 2 ? 0 : 1;",
            "\tpair<ll, array<P, 2>> res({0, {S[0], S[0]}});",
            "\trep(i, 0, j) for (;; j = (j + 1) % n) {",
            "\t\tres = max(res, {(S[i] - S[j]).dist2(), {S[i], S[j]}});",
            "\t\tif ((S[(j + 1) % n] - S[j]).cross(S[i + 1] - S[i]) >= 0)",
            "\t\t\tbreak;",
            "\t}",
            "\treturn res.second;",
            "}"
        ],
        "description": "Returns the two points with max distance on a convex hull (ccw,\nno duplicate/collinear points).",
        "prefix": [
            "hack_HullDiameter"
        ]
    },
    "InsidePolygon.h": {
        "body": [
            "template<class P>",
            "bool inPolygon(vector<P> &p, P a, bool strict = true) {",
            "\tint cnt = 0, n = sz(p);",
            "\trep(i, 0, n) {",
            "\t\tP q = p[(i + 1) % n];",
            "\t\tif (onSegment(p[i], q, a)) return !strict;",
            "\t\t//or: if (segDist(p[i], q, a) <= eps) return !strict;",
            "\t\tcnt ^=",
            "\t\t\t((a.y < p[i].y) - (a.y < q.y)) * a.cross(p[i], q) > 0;",
            "\t}",
            "\treturn cnt;",
            "}"
        ],
        "description": "Returns true if p lies within the polygon. If strict is true,\nit returns false for points on the boundary. The algorithm uses\nproducts in intermediate steps so watch out for overflow.",
        "prefix": [
            "hack_InsidePolygon"
        ]
    },
    "IntDeterminant.h": {
        "body": [
            "const ll mod = 12345;",
            "ll det(vector<vector<ll>>& a) {",
            "\tint n = sz(a);",
            "\tll ans = 1;",
            "\trep(i, 0, n) {",
            "\t\trep(j, i + 1, n) {",
            "\t\t\twhile (a[j][i] != 0) { // gcd step",
            "\t\t\t\tll t = a[i][i] / a[j][i];",
            "\t\t\t\tif (t)",
            "\t\t\t\t\trep(k, i, n) a[i][k] = (a[i][k] - a[j][k] * t) % mod;",
            "\t\t\t\tswap(a[i], a[j]);",
            "\t\t\t\tans *= -1;",
            "\t\t\t}",
            "\t\t}",
            "\t\tans = ans * a[i][i] % mod;",
            "\t\tif (!ans) return 0;",
            "\t}",
            "\treturn (ans + mod) % mod;",
            "}"
        ],
        "description": "Calculates determinant using modular arithmetics.\nModulos can also be removed to get a pure-integer version.",
        "prefix": [
            "hack_IntDeterminant"
        ]
    },
    "IntPerm.h": {
        "body": [
            "int permToInt(vi& v) {",
            "\tint use = 0, i = 0, r = 0;",
            "\tfor (int x : v)",
            "\t\tr = r * ++i + __builtin_popcount(use & -(1 << x)),",
            "\t\tuse |= 1 << x; // (note: minus, not ~!)",
            "\treturn r;",
            "}"
        ],
        "description": "Permutation -> integer conversion. (Not order preserving.)\nInteger -> permutation can use a lookup table.",
        "prefix": [
            "hack_IntPerm"
        ]
    },
    "Integrate.h": {
        "body": [
            "template<class F>",
            "double quad(double a, double b, F f, const int n = 1000) {",
            "\tdouble h = (b - a) / 2 / n, v = f(a) + f(b);",
            "\trep(i, 1, n * 2) v += f(a + i * h) * (i & 1 ? 4 : 2);",
            "\treturn v * h / 3;",
            "}"
        ],
        "description": "Simple integration of a function over an interval using\nSimpson's rule. The error should be proportional to $h^4$, although in\npractice you will want to verify that the result is stable to desired\nprecision when epsilon changes.",
        "prefix": [
            "hack_Integrate"
        ]
    },
    "IntegrateAdaptive.h": {
        "body": [
            "typedef double d;",
            "#define S(a, b) \\",
            "\t(f(a) + 4 * f((a + b) / 2) + f(b)) * (b - a) / 6",
            "template<class F> d rec(F& f, d a, d b, d eps, d S) {",
            "\td c = (a + b) / 2;",
            "\td S1 = S(a, c), S2 = S(c, b), T = S1 + S2;",
            "\tif (abs(T - S) <= 15 * eps || b - a < 1e-10)",
            "\t\treturn T + (T - S) / 15;",
            "\treturn rec(f, a, c, eps / 2, S1) + rec(f, c, b, eps / 2, S2);",
            "}",
            "template<class F> d quad(d a, d b, F f, d eps = 1e-8) {",
            "\treturn rec(f, a, b, eps, S(a, b));",
            "}"
        ],
        "description": "Fast integration using an adaptive Simpson's rule.",
        "prefix": [
            "hack_IntegrateAdaptive"
        ]
    },
    "IntervalContainer.h": {
        "body": [
            "set<pii>::iterator addInterval(set<pii>& is, int L, int R) {",
            "\tif (L == R) return is.end();",
            "\tauto it = is.lower_bound({L, R}), before = it;",
            "\twhile (it != is.end() && it->first <= R) {",
            "\t\tR = max(R, it->second);",
            "\t\tbefore = it = is.erase(it);",
            "\t}",
            "\tif (it != is.begin() && (--it)->second >= L) {",
            "\t\tL = min(L, it->first);",
            "\t\tR = max(R, it->second);",
            "\t\tis.erase(it);",
            "\t}",
            "\treturn is.insert(before, {L, R});",
            "}",
            "void removeInterval(set<pii>& is, int L, int R) {",
            "\tif (L == R) return;",
            "\tauto it = addInterval(is, L, R);",
            "\tauto r2 = it->second;",
            "\tif (it->first == L) is.erase(it);",
            "\telse (int&)it->second = L;",
            "\tif (R != r2) is.emplace(R, r2);",
            "}"
        ],
        "description": "Add and remove intervals from a set of disjoint intervals.\nWill merge the added interval with any overlapping intervals in the set when adding.\nIntervals are [inclusive, exclusive).",
        "prefix": [
            "hack_IntervalContainer"
        ]
    },
    "IterativeSegmentTree.h": {
        "body": [
            "struct Tree {",
            "\ttypedef int T;",
            "\tstatic constexpr T unit = INT_MIN;",
            "\tT f(T a, T b) { return max(a, b); } // (any associative fn)",
            "\tvector<T> s;",
            "\tint n;",
            "\tTree(int n = 0, T def = unit): s(2 * n, def), n(n) {}",
            "\tvoid update(int pos, T val) {",
            "\t\tfor (s[pos += n] = val; pos /= 2;)",
            "\t\t\ts[pos] = f(s[pos * 2], s[pos * 2 + 1]);",
            "\t}",
            "\tT query(int b, int e) { // query [b, e)",
            "\t\tT ra = unit, rb = unit;",
            "\t\tfor (b += n, e += n; b < e; b /= 2, e /= 2) {",
            "\t\t\tif (b % 2) ra = f(ra, s[b++]);",
            "\t\t\tif (e % 2) rb = f(s[--e], rb);",
            "\t\t}",
            "\t\treturn f(ra, rb);",
            "\t}",
            "};"
        ],
        "description": "Zero-indexed max-tree. Bounds are inclusive to the left and exclusive to the right. Can be changed by modifying T, f and unit.",
        "prefix": [
            "hack_IterativeSegmentTree"
        ]
    },
    "KDBIT.h": {
        "body": [
            "template<class T, int... Ns> struct BIT {",
            "\tT val = 0;",
            "\tvoid update(T v) { val += v; }",
            "\tT query() { return val; }",
            "};",
            "template<class T, int N, int... Ns> struct BIT<T, N, Ns...> {",
            "\tBIT<T, Ns...> bit[N + 1];",
            "\t// map<int, BIT<T, Ns...>> bit; // if the mem use is too high",
            "\ttemplate<class... Args> void update(int i, Args... args) {",
            "\t\tfor (i++; i <= N; i += i & -i) bit[i].update(args...);",
            "\t}",
            "\ttemplate<class... Args> T query(int i, Args... args) {",
            "\t\tT ans = 0;",
            "\t\tfor (i++; i; i -= i & -i) ans += bit[i].query(args...);",
            "\t\treturn ans;",
            "\t}",
            "\ttemplate<class... Args,",
            "\t\tenable_if_t<(sizeof...(Args) == 2 * sizeof...(Ns))>* =",
            "\t\t\tnullptr>",
            "\tT query(int l, int r, Args... args) {",
            "\t\treturn query(r, args...) - query(l - 1, args...);",
            "\t}",
            "};"
        ],
        "description": "$k$-dimensional BIT. \\texttt{BIT<int, N, M>}\ngives an $N \\times M$ BIT. Query \\texttt{bit.query(x1, x2, y1, y2)} Update \\texttt{bit.update(x, y, delta)}",
        "prefix": [
            "hack_KDBIT"
        ]
    },
    "KMP.h": {
        "body": [
            "vi pi(const string& s) {",
            "\tvi p(sz(s));",
            "\trep(i, 1, sz(s)) {",
            "\t\tint g = p[i - 1];",
            "\t\twhile (g && s[i] != s[g]) g = p[g - 1];",
            "\t\tp[i] = g + (s[i] == s[g]);",
            "\t}",
            "\treturn p;",
            "}",
            "vi match(const string& s, const string& pat) {",
            "\tvi p = pi(pat + '\\0' + s), res;",
            "\trep(i, sz(p) - sz(s), sz(p)) if (p[i] == sz(pat))",
            "\t\tres.push_back(i - 2 * sz(pat));",
            "\treturn res;",
            "}"
        ],
        "description": "pi[x] computes the length of the longest prefix of s that ends at x, other than s[0...x] itself (abacaba -> 0010123).\nCan be used to find all occurrences of a string.",
        "prefix": [
            "hack_KMP"
        ]
    },
    "KactlAhoCorasick.h": {
        "body": [
            "struct AhoCorasick {",
            "\tenum { alpha = 26, first = 'A' }; // change this!",
            "\tstruct Node {",
            "\t\t// (nmatches is optional)",
            "\t\tint back, next[alpha], start = -1, end = -1, nmatches = 0;",
            "\t\tNode(int v) { memset(next, v, sizeof(next)); }",
            "\t};",
            "\tvector<Node> N;",
            "\tvi backp;",
            "\tvoid insert(string& s, int j) {",
            "\t\tassert(!s.empty());",
            "\t\tint n = 0;",
            "\t\tfor (char c : s) {",
            "\t\t\tint& m = N[n].next[c - first];",
            "\t\t\tif (m == -1) {",
            "\t\t\t\tn = m = sz(N);",
            "\t\t\t\tN.emplace_back(-1);",
            "\t\t\t} else n = m;",
            "\t\t}",
            "\t\tif (N[n].end == -1) N[n].start = j;",
            "\t\tbackp.push_back(N[n].end);",
            "\t\tN[n].end = j;",
            "\t\tN[n].nmatches++;",
            "\t}",
            "\tAhoCorasick(vector<string>& pat): N(1, -1) {",
            "\t\trep(i, 0, sz(pat)) insert(pat[i], i);",
            "\t\tN[0].back = sz(N);",
            "\t\tN.emplace_back(0);",
            "\t\tqueue<int> q;",
            "\t\tfor (q.push(0); !q.empty(); q.pop()) {",
            "\t\t\tint n = q.front(), prev = N[n].back;",
            "\t\t\trep(i, 0, alpha) {",
            "\t\t\t\tint &ed = N[n].next[i], y = N[prev].next[i];",
            "\t\t\t\tif (ed == -1) ed = y;",
            "\t\t\t\telse {",
            "\t\t\t\t\tN[ed].back = y;",
            "\t\t\t\t\t(N[ed].end == -1 ? N[ed].end : backp[N[ed].start]) =",
            "\t\t\t\t\t\tN[y].end;",
            "\t\t\t\t\tN[ed].nmatches += N[y].nmatches;",
            "\t\t\t\t\tq.push(ed);",
            "\t\t\t\t}",
            "\t\t\t}",
            "\t\t}",
            "\t}",
            "\tvi find(string word) {",
            "\t\tint n = 0;",
            "\t\tvi res; // ll count = 0;",
            "\t\tfor (char c : word) {",
            "\t\t\tn = N[n].next[c - first];",
            "\t\t\tres.push_back(N[n].end);",
            "\t\t\t// count += N[n].nmatches;",
            "\t\t}",
            "\t\treturn res;",
            "\t}",
            "\tvector<vi> findAll(vector<string>& pat, string word) {",
            "\t\tvi r = find(word);",
            "\t\tvector<vi> res(sz(word));",
            "\t\trep(i, 0, sz(word)) {",
            "\t\t\tint ind = r[i];",
            "\t\t\twhile (ind != -1) {",
            "\t\t\t\tres[i - sz(pat[ind]) + 1].push_back(ind);",
            "\t\t\t\tind = backp[ind];",
            "\t\t\t}",
            "\t\t}",
            "\t\treturn res;",
            "\t}",
            "};"
        ],
        "description": "Aho-Corasick automaton, used for multiple pattern matching.\nInitialize with AhoCorasick ac(patterns); the automaton start node will be at index 0.\nfind(word) returns for each position the index of the longest word that ends there, or -1 if none.\nfindAll($-$, word) finds all words (up to $N \\sqrt N$ many if no duplicate patterns)\nthat start at each position (shortest first).\nDuplicate patterns are allowed; empty patterns are not.\nTo find the longest words that start at each position, reverse all input.\nFor large alphabets, split each symbol into chunks, with sentinel bits for symbol boundaries.",
        "prefix": [
            "hack_KactlAhoCorasick"
        ]
    },
    "KactlDinic.h": {
        "body": [
            "struct Dinic {",
            "\tstruct Edge {",
            "\t\tint to, rev;",
            "\t\tll c, oc;",
            "\t\tll flow() { return max(oc - c, 0LL); } // if you need flows",
            "\t};",
            "\tvi lvl, ptr, q;",
            "\tvector<vector<Edge>> adj;",
            "\tDinic(int n): lvl(n), ptr(n), q(n), adj(n) {}",
            "\tvoid addEdge(int a, int b, ll c, ll rcap = 0) {",
            "\t\tadj[a].push_back({b, sz(adj[b]), c, c});",
            "\t\tadj[b].push_back({a, sz(adj[a]) - 1, rcap, rcap});",
            "\t}",
            "\tll dfs(int v, int t, ll f) {",
            "\t\tif (v == t || !f) return f;",
            "\t\tfor (int& i = ptr[v]; i < sz(adj[v]); i++) {",
            "\t\t\tEdge& e = adj[v][i];",
            "\t\t\tif (lvl[e.to] == lvl[v] + 1)",
            "\t\t\t\tif (ll p = dfs(e.to, t, min(f, e.c))) {",
            "\t\t\t\t\te.c -= p, adj[e.to][e.rev].c += p;",
            "\t\t\t\t\treturn p;",
            "\t\t\t\t}",
            "\t\t}",
            "\t\treturn 0;",
            "\t}",
            "\tll calc(int s, int t) {",
            "\t\tll flow = 0;",
            "\t\tq[0] = s;",
            "\t\trep(L, 0,",
            "\t\t\t31) do { // 'int L=30' maybe faster for random data",
            "\t\t\tlvl = ptr = vi(sz(q));",
            "\t\t\tint qi = 0, qe = lvl[s] = 1;",
            "\t\t\twhile (qi < qe && !lvl[t]) {",
            "\t\t\t\tint v = q[qi++];",
            "\t\t\t\tfor (Edge e : adj[v])",
            "\t\t\t\t\tif (!lvl[e.to] && e.c >> (30 - L))",
            "\t\t\t\t\t\tq[qe++] = e.to, lvl[e.to] = lvl[v] + 1;",
            "\t\t\t}",
            "\t\t\twhile (ll p = dfs(s, t, LLONG_MAX)) flow += p;",
            "\t\t}",
            "\t\twhile (lvl[t])",
            "\t\t\t;",
            "\t\treturn flow;",
            "\t}",
            "\tbool leftOfMinCut(int a) { return lvl[a] != 0; }",
            "};"
        ],
        "description": "Flow algorithm with complexity $O(VE\\log U)$ where $U = \\max |\\text{cap}|$.\n$O(\\min(E^{1/2}, V^{2/3})E)$ if $U = 1$; $O(\\sqrt{V}E)$ for bipartite matching.",
        "prefix": [
            "hack_KactlDinic"
        ]
    },
    "KactlSuffixTree.h": {
        "body": [
            "struct SuffixTree {",
            "\tenum { N = 200010, ALPHA = 26 }; // N ~ 2*maxlen+10",
            "\tint toi(char c) { return c - 'a'; }",
            "\tstring a; // v = cur node, q = cur position",
            "\tint t[N][ALPHA], l[N], r[N], p[N], s[N], v = 0, q = 0, m = 2;",
            "\tvoid ukkadd(int i, int c) {",
            "suff:",
            "\t\tif (r[v] <= q) {",
            "\t\t\tif (t[v][c] == -1) {",
            "\t\t\t\tt[v][c] = m;",
            "\t\t\t\tl[m] = i;",
            "\t\t\t\tp[m++] = v;",
            "\t\t\t\tv = s[v];",
            "\t\t\t\tq = r[v];",
            "\t\t\t\tgoto suff;",
            "\t\t\t}",
            "\t\t\tv = t[v][c];",
            "\t\t\tq = l[v];",
            "\t\t}",
            "\t\tif (q == -1 || c == toi(a[q])) q++;",
            "\t\telse {",
            "\t\t\tl[m + 1] = i;",
            "\t\t\tp[m + 1] = m;",
            "\t\t\tl[m] = l[v];",
            "\t\t\tr[m] = q;",
            "\t\t\tp[m] = p[v];",
            "\t\t\tt[m][c] = m + 1;",
            "\t\t\tt[m][toi(a[q])] = v;",
            "\t\t\tl[v] = q;",
            "\t\t\tp[v] = m;",
            "\t\t\tt[p[m]][toi(a[l[m]])] = m;",
            "\t\t\tv = s[p[m]];",
            "\t\t\tq = l[m];",
            "\t\t\twhile (q < r[m]) {",
            "\t\t\t\tv = t[v][toi(a[q])];",
            "\t\t\t\tq += r[v] - l[v];",
            "\t\t\t}",
            "\t\t\tif (q == r[m]) s[m] = v;",
            "\t\t\telse s[m] = m + 2;",
            "\t\t\tq = r[v] - (q - r[m]);",
            "\t\t\tm += 2;",
            "\t\t\tgoto suff;",
            "\t\t}",
            "\t}",
            "\tSuffixTree(string a): a(a) {",
            "\t\tfill(r, r + N, sz(a));",
            "\t\tmemset(s, 0, sizeof s);",
            "\t\tmemset(t, -1, sizeof t);",
            "\t\tfill(t[1], t[1] + ALPHA, 0);",
            "\t\ts[0] = 1;",
            "\t\tl[0] = l[1] = -1;",
            "\t\tr[0] = r[1] = p[0] = p[1] = 0;",
            "\t\trep(i, 0, sz(a)) ukkadd(i, toi(a[i]));",
            "\t}",
            "\t// example: find longest common substring (uses ALPHA = 28)",
            "\tpii best;",
            "\tint lcs(int node, int i1, int i2, int olen) {",
            "\t\tif (l[node] <= i1 && i1 < r[node]) return 1;",
            "\t\tif (l[node] <= i2 && i2 < r[node]) return 2;",
            "\t\tint mask = 0, len = node ? olen + (r[node] - l[node]) : 0;",
            "\t\trep(c, 0, ALPHA) if (t[node][c] != -1) mask |=",
            "\t\t\tlcs(t[node][c], i1, i2, len);",
            "\t\tif (mask == 3) best = max(best, {len, r[node] - len});",
            "\t\treturn mask;",
            "\t}",
            "\tstatic pii LCS(string s, string t) {",
            "\t\tSuffixTree st(s + (char)('z' + 1) + t + (char)('z' + 2));",
            "\t\tst.lcs(0, sz(s), sz(s) + 1 + sz(t), 0);",
            "\t\treturn st.best;",
            "\t}",
            "};"
        ],
        "description": "Ukkonen's algorithm for online suffix tree construction.\nEach node contains indices [l, r) into the string, and a list of child nodes.\nSuffixes are given by traversals of this tree, joining [l, r) substrings.\nThe root is 0 (has l = -1, r = 0), non-existent children are -1.\nTo get a complete tree, append a dummy symbol -- otherwise it may contain\nan incomplete path (still useful for substring matching, though).",
        "prefix": [
            "hack_KactlSuffixTree"
        ]
    },
    "LCA.h": {
        "body": [
            "struct LCA {",
            "\tint T = 0;",
            "\tvector<int> pre, inv, tour;",
            "\tRMQ<int> rmq;",
            "\tLCA(vector<vi>& adj, int root = 0):",
            "\t\tpre(sz(adj)), inv(pre), rmq((dfs(adj, root), tour)) {}",
            "\tvoid dfs(vector<vi>& adj, int u, int p = -1) {",
            "\t\tinv[pre[u] = T++] = u;",
            "\t\tfor (int v : adj[u])",
            "\t\t\tif (v != p) tour.push_back(pre[u]), dfs(adj, v, u);",
            "\t}",
            "\tint lca(int u, int v) {",
            "\t\tif (u == v) return u;",
            "\t\ttie(u, v) = minmax(pre[u], pre[v]);",
            "\t\treturn inv[rmq.query(u, v)];",
            "\t}",
            "};"
        ],
        "description": "Answers lowest common ancestor\nqueries on a rooted tree using RMQ. Works with\nboth directed and undirected adjacency lists.",
        "prefix": [
            "hack_LCA"
        ]
    },
    "LIS.h": {
        "body": [
            "template<class I> vi lis(const vector<I>& S) {",
            "\tif (S.empty()) return {};",
            "\tvi prev(sz(S));",
            "\ttypedef pair<I, int> p;",
            "\tvector<p> res;",
            "\trep(i, 0, sz(S)) {",
            "\t\t// change 0 -> i for longest non-decreasing subsequence",
            "\t\tauto it = lower_bound(all(res), p{S[i], 0});",
            "\t\tif (it == res.end())",
            "\t\t\tres.emplace_back(), it = res.end() - 1;",
            "\t\t*it = {S[i], i};",
            "\t\tprev[i] = it == res.begin() ? 0 : (it - 1)->second;",
            "\t}",
            "\tint L = sz(res), cur = res.back().second;",
            "\tvi ans(L);",
            "\twhile (L--) ans[L] = cur, cur = prev[cur];",
            "\treturn ans;",
            "}"
        ],
        "description": "Compute indices for the longest increasing subsequence.",
        "prefix": [
            "hack_LIS"
        ]
    },
    "LazyIterativeSegTree.h": {
        "body": [
            "template<class T, T (*e)(), T (*op)(T, T), class F, F (*id)(),",
            "\tT (*onto)(F, T), F (*comp)(F, F)>",
            "struct lazy_segtree {",
            "\tint N, log, S;",
            "\tvector<T> d;",
            "\tvector<F> lz;",
            "\tlazy_segtree(const vector<T>& v):",
            "\t\tN(sz(v)), log(__lg(2 * N - 1)), S(1 << log), d(2 * S, e()),",
            "\t\tlz(S, id()) {",
            "\t\tfor (int i = 0; i < N; i++) d[S + i] = v[i];",
            "\t\tfor (int i = S - 1; i >= 1; i--) pull(i);",
            "\t}",
            "\tvoid apply(int k, F f) {",
            "\t\td[k] = onto(f, d[k]);",
            "\t\tif (k < S) lz[k] = comp(f, lz[k]);",
            "\t}",
            "\tvoid push(int k) {",
            "\t\tapply(2 * k, lz[k]), apply(2 * k + 1, lz[k]), lz[k] = id();",
            "\t}",
            "\tvoid push(int l, int r) {",
            "\t\tint zl = __builtin_ctz(l), zr = __builtin_ctz(r);",
            "\t\tfor (int i = log; i > min(zl, zr); i--) {",
            "\t\t\tif (i > zl) push(l >> i);",
            "\t\t\tif (i > zr) push((r - 1) >> i);",
            "\t\t}",
            "\t}",
            "\tvoid pull(int k) { d[k] = op(d[2 * k], d[2 * k + 1]); }",
            "\tvoid set(int p, T x) {",
            "\t\tp += S;",
            "\t\tfor (int i = log; i >= 1; i--) push(p >> i);",
            "\t\tfor (d[p] = x; p /= 2;) pull(p);",
            "\t}",
            "\tT query(int l, int r) {",
            "\t\tif (l == r) return T{};",
            "\t\tpush(l += S, r += S);",
            "\t\tT vl = e(), vr = e();",
            "\t\tfor (; l < r; l /= 2, r /= 2) {",
            "\t\t\tif (l & 1) vl = op(vl, d[l++]);",
            "\t\t\tif (r & 1) vr = op(d[--r], vr);",
            "\t\t}",
            "\t\treturn op(vl, vr);",
            "\t}",
            "\tvoid update(int l, int r, F f) {",
            "\t\tif (l == r) return;",
            "\t\tpush(l += S, r += S);",
            "\t\tfor (int a = l, b = r; a < b; a /= 2, b /= 2) {",
            "\t\t\tif (a & 1) apply(a++, f);",
            "\t\t\tif (b & 1) apply(--b, f);",
            "\t\t}",
            "\t\tint zl = __builtin_ctz(l), zr = __builtin_ctz(r);",
            "\t\tfor (int i = min(zl, zr) + 1; i <= log; i++) {",
            "\t\t\tif (i > zl) pull(l >> i);",
            "\t\t\tif (i > zr) pull((r - 1) >> i);",
            "\t\t}",
            "\t}",
            "};"
        ],
        "prefix": [
            "hack_LazyIterativeSegTree"
        ]
    },
    "LineContainer.h": {
        "body": [
            "struct Line {",
            "\tmutable ll k, m, p;",
            "\tbool operator<(const Line& o) const { return k < o.k; }",
            "\tbool operator<(ll x) const { return p < x; }",
            "};",
            "struct LineContainer: multiset<Line, less<>> {",
            "\t// (for doubles, use inf = 1/.0, div(a,b) = a/b)",
            "\tstatic const ll inf = LLONG_MAX;",
            "\tll div(ll a, ll b) { // floored division",
            "\t\treturn a / b - ((a ^ b) < 0 && a % b);",
            "\t}",
            "\tbool isect(iterator x, iterator y) {",
            "\t\tif (y == end()) return x->p = inf, 0;",
            "\t\tif (x->k == y->k) x->p = x->m > y->m ? inf : -inf;",
            "\t\telse x->p = div(y->m - x->m, x->k - y->k);",
            "\t\treturn x->p >= y->p;",
            "\t}",
            "\tvoid add(ll k, ll m) {",
            "\t\tauto z = insert({k, m, 0}), y = z++, x = y;",
            "\t\twhile (isect(y, z)) z = erase(z);",
            "\t\tif (x != begin() && isect(--x, y)) isect(x, y = erase(y));",
            "\t\twhile ((y = x) != begin() && (--x)->p >= y->p)",
            "\t\t\tisect(x, erase(y));",
            "\t}",
            "\tll query(ll x) {",
            "\t\tassert(!empty());",
            "\t\tauto l = *lower_bound(x);",
            "\t\treturn l.k * x + l.m;",
            "\t}",
            "};"
        ],
        "description": "Container where you can add lines of the form kx+m, and query maximum values at points x.\nUseful for dynamic programming (``convex hull trick'').",
        "prefix": [
            "hack_LineContainer"
        ]
    },
    "LineHullIntersection.h": {
        "body": [
            "#define cmp(i, j) \\",
            "\tsgn(dir.perp().cross(poly[(i) % n] - poly[(j) % n]))",
            "#define extr(i) cmp(i + 1, i) >= 0 && cmp(i, i - 1 + n) < 0",
            "template<class P> int extrVertex(vector<P>& poly, P dir) {",
            "\tint n = sz(poly), lo = 0, hi = n;",
            "\tif (extr(0)) return 0;",
            "\twhile (lo + 1 < hi) {",
            "\t\tint m = (lo + hi) / 2;",
            "\t\tif (extr(m)) return m;",
            "\t\tint ls = cmp(lo + 1, lo), ms = cmp(m + 1, m);",
            "\t\t(ls < ms || (ls == ms && ls == cmp(lo, m)) ? hi : lo) = m;",
            "\t}",
            "\treturn lo;",
            "}",
            "#define cmpL(i) sgn(a.cross(poly[i], b))",
            "template<class P>",
            "array<int, 2> lineHull(P a, P b, vector<P>& poly) {",
            "\tint endA = extrVertex(poly, (a - b).perp());",
            "\tint endB = extrVertex(poly, (b - a).perp());",
            "\tif (cmpL(endA) < 0 || cmpL(endB) > 0) return {-1, -1};",
            "\tarray<int, 2> res;",
            "\trep(i, 0, 2) {",
            "\t\tint lo = endB, hi = endA, n = sz(poly);",
            "\t\twhile ((lo + 1) % n != hi) {",
            "\t\t\tint m = ((lo + hi + (lo < hi ? 0 : n)) / 2) % n;",
            "\t\t\t(cmpL(m) == cmpL(endB) ? lo : hi) = m;",
            "\t\t}",
            "\t\tres[i] = (lo + !cmpL(hi)) % n;",
            "\t\tswap(endA, endB);",
            "\t}",
            "\tif (res[0] == res[1]) return {res[0], -1};",
            "\tif (!cmpL(res[0]) && !cmpL(res[1]))",
            "\t\tswitch ((res[0] - res[1] + sz(poly) + 1) % sz(poly)) {",
            "\t\tcase 0: return {res[0], res[0]};",
            "\t\tcase 2: return {res[1], res[1]};",
            "\t\t}",
            "\treturn res;",
            "}"
        ],
        "description": "Line-convex polygon intersection. The polygon must be ccw and have no collinear points.\nlineHull(line, poly) returns a pair describing the intersection of a line with the polygon:\n\\begin{itemize*}\n\\item $(-1, -1)$ if no collision,\n\\item $(i, -1)$ if touching the corner $i$,\n\\item $(i, i)$ if along side $(i, i+1)$,\n\\item $(i, j)$ if crossing sides $(i, i+1)$ and $(j, j+1)$.\n\\end{itemize*}\nIn the last case, if a corner $i$ is crossed, this is treated as happening on side $(i, i+1)$.\nThe points are returned in the same order as the line hits the polygon.\n\\texttt{extrVertex} returns the point of a hull with the max projection onto a line.",
        "prefix": [
            "hack_LineHullIntersection"
        ]
    },
    "LineProjectionReflection.h": {
        "body": [
            "template<class P>",
            "P lineProj(P a, P b, P p, bool refl = false) {",
            "\tP v = b - a;",
            "\treturn p -",
            "\t\tv.perp() * (1 + refl) * v.cross(p - a) / v.dist2();",
            "}"
        ],
        "description": "Projects point p onto line ab. Set refl=true to get reflection\nof point p across line ab insted. The wrong point will be returned if P is\nan integer point and the desired point doesn't have integer coordinates.\nProducts of three coordinates are used in intermediate steps so watch out\nfor overflow.",
        "prefix": [
            "hack_LineProjectionReflection"
        ]
    },
    "LinearRecurrence.h": {
        "body": [
            "typedef vector<ll> Poly;",
            "ll linearRec(Poly S, Poly tr, ll k) {",
            "\tint n = sz(tr);",
            "\tauto combine = [&](Poly a, Poly b) {",
            "\t\tPoly res(n * 2 + 1);",
            "\t\trep(i, 0, n + 1) rep(j, 0, n + 1) res[i + j] =",
            "\t\t\t(res[i + j] + a[i] * b[j]) % mod;",
            "\t\tfor (int i = 2 * n; i > n; --i)",
            "\t\t\trep(j, 0, n) res[i - 1 - j] =",
            "\t\t\t\t(res[i - 1 - j] + res[i] * tr[j]) % mod;",
            "\t\tres.resize(n + 1);",
            "\t\treturn res;",
            "\t};",
            "\tPoly pol(n + 1), e(pol);",
            "\tpol[0] = e[1] = 1;",
            "\tfor (++k; k; k /= 2) {",
            "\t\tif (k % 2) pol = combine(pol, e);",
            "\t\te = combine(e, e);",
            "\t}",
            "\tll res = 0;",
            "\trep(i, 0, n) res = (res + pol[i + 1] * S[i]) % mod;",
            "\treturn res;",
            "}"
        ],
        "description": "Generates the $k$'th term of an $n$-order\nlinear recurrence $S[i] = \\sum_j S[i-j-1]tr[j]$,\ngiven $S[0 \\ldots \\ge n-1]$ and $tr[0 \\ldots n-1]$.\nFaster than matrix multiplication.\nUseful together with Berlekamp--Massey.",
        "prefix": [
            "hack_LinearRecurrence"
        ]
    },
    "LinkCutTree.h": {
        "body": [
            "// https://codeforces.com/blog/entry/75885",
            "struct LinkCut: SplayTree {",
            "\tLinkCut(int n): SplayTree(n) {}",
            "\tint access(int x) {",
            "\t\tint u = x, v = 0;",
            "\t\tfor (; u; v = u, u = T[u].p) {",
            "\t\t\tsplay(u);",
            "\t\t\tint& ov = T[u].ch[1];",
            "\t\t\tT[u].vir += T[ov].sub;",
            "\t\t\tT[u].vir -= T[v].sub;",
            "\t\t\tov = v;",
            "\t\t\tpull(u);",
            "\t\t}",
            "\t\treturn splay(x), v;",
            "\t}",
            "\tvoid reroot(int x) {",
            "\t\taccess(x);",
            "\t\tT[x].flip ^= 1;",
            "\t\tpush(x);",
            "\t}",
            "\tvoid Link(int u, int v) {",
            "\t\treroot(u), access(v);",
            "\t\tT[v].vir += T[u].sub;",
            "\t\tT[u].p = v;",
            "\t\tpull(v);",
            "\t}",
            "\tvoid Cut(int u, int v) {",
            "\t\treroot(u), access(v);",
            "\t\tT[v].ch[0] = T[u].p = 0;",
            "\t\tpull(v);",
            "\t}",
            "\t// Rooted tree LCA. Returns 0 if u and v arent connected.",
            "\tint LCA(int u, int v) {",
            "\t\tif (u == v) return u;",
            "\t\taccess(u);",
            "\t\tint ret = access(v);",
            "\t\treturn T[u].p ? ret : 0;",
            "\t}",
            "\t// Query subtree of u where v is outside the subtree.",
            "\tll Subtree(int u, int v) {",
            "\t\treroot(v), access(u);",
            "\t\treturn T[u].vir + T[u].self;",
            "\t}",
            "\t// Query path [u..v]",
            "\tll Path(int u, int v) {",
            "\t\treroot(u), access(v);",
            "\t\treturn T[v].path;",
            "\t}",
            "\t// Update vertex u with value v",
            "\tvoid Update(int u, ll v) {",
            "\t\taccess(u);",
            "\t\tT[u].self = v;",
            "\t\tpull(u);",
            "\t}",
            "};"
        ],
        "prefix": [
            "hack_LinkCutTree"
        ]
    },
    "LowerHigher.h": {
        "body": [
            "template<class S, class T>",
            "auto lower(const S& s, const T& x, bool strict = 0) {",
            "\tauto it = strict ? s.lower_bound(x) : s.upper_bound(x);",
            "\treturn it == begin(s) ? end(s) : prev(it);",
            "}",
            "template<class S, class T>",
            "auto higher(const S& s, const T& x, bool strict = 0) {",
            "\treturn strict ? s.upper_bound(x) : s.lower_bound(x);",
            "}"
        ],
        "prefix": [
            "hack_LowerHigher"
        ]
    },
    "Manacher.h": {
        "body": [
            "array<vi, 2> manacher(const string& s) {",
            "\tint n = sz(s);",
            "\tarray<vi, 2> p = {vi(n + 1), vi(n)};",
            "\trep(z, 0, 2) for (int i = 0, l = 0, r = 0; i < n; i++) {",
            "\t\tint t = r - i + !z;",
            "\t\tif (i < r) p[z][i] = min(t, p[z][l + t]);",
            "\t\tint L = i - p[z][i], R = i + p[z][i] - !z;",
            "\t\twhile (L >= 1 && R + 1 < n && s[L - 1] == s[R + 1])",
            "\t\t\tp[z][i]++, L--, R++;",
            "\t\tif (R > r) l = L, r = R;",
            "\t}",
            "\treturn p;",
            "}"
        ],
        "description": "For each position in a string, computes p[0][i] = half length of\nlongest even palindrome around pos i, p[1][i] = longest odd (half rounded down).",
        "prefix": [
            "hack_Manacher"
        ]
    },
    "ManhattanMST.h": {
        "body": [
            "typedef Point<int> P;",
            "vector<array<int, 3>> manhattanMST(vector<P> ps) {",
            "\tvi id(sz(ps));",
            "\tiota(all(id), 0);",
            "\tvector<array<int, 3>> edges;",
            "\trep(k, 0, 4) {",
            "\t\tsort(all(id), [&](int i, int j) {",
            "\t\t\treturn (ps[i] - ps[j]).x < (ps[j] - ps[i]).y;",
            "\t\t});",
            "\t\tmap<int, int> sweep;",
            "\t\tfor (int i : id) {",
            "\t\t\tfor (auto it = sweep.lower_bound(-ps[i].y);",
            "\t\t\t\t\t it != sweep.end(); sweep.erase(it++)) {",
            "\t\t\t\tint j = it->second;",
            "\t\t\t\tP d = ps[i] - ps[j];",
            "\t\t\t\tif (d.y > d.x) break;",
            "\t\t\t\tedges.push_back({d.y + d.x, i, j});",
            "\t\t\t}",
            "\t\t\tsweep[-ps[i].y] = i;",
            "\t\t}",
            "\t\tfor (P& p : ps)",
            "\t\t\tif (k & 1) p.x = -p.x;",
            "\t\t\telse swap(p.x, p.y);",
            "\t}",
            "\treturn edges;",
            "}"
        ],
        "description": "Given N points, returns up to 4*N edges, which are guaranteed\nto contain a minimum spanning tree for the graph with edge weights w(p, q) =\n|p.x - q.x| + |p.y - q.y|. Edges are in the form (distance, src, dst). Use a\nstandard MST algorithm on the result to find the final MST.",
        "prefix": [
            "hack_ManhattanMST"
        ]
    },
    "Matrix.h": {
        "body": [
            "template<class T, int N> struct Matrix {",
            "\ttypedef Matrix M;",
            "\tarray<array<T, N>, N> d{};",
            "\tM operator*(const M& m) const {",
            "\t\tM a;",
            "\t\trep(i, 0, N) rep(j, 0, N) rep(k, 0, N) a.d[i][j] +=",
            "\t\t\td[i][k] * m.d[k][j];",
            "\t\treturn a;",
            "\t}",
            "\tvector<T> operator*(const vector<T>& vec) const {",
            "\t\tvector<T> ret(N);",
            "\t\trep(i, 0, N) rep(j, 0, N) ret[i] += d[i][j] * vec[j];",
            "\t\treturn ret;",
            "\t}",
            "\tM operator^(ll p) const {",
            "\t\tassert(p >= 0);",
            "\t\tM a, b(*this);",
            "\t\trep(i, 0, N) a.d[i][i] = 1;",
            "\t\twhile (p) {",
            "\t\t\tif (p & 1) a = a * b;",
            "\t\t\tb = b * b;",
            "\t\t\tp >>= 1;",
            "\t\t}",
            "\t\treturn a;",
            "\t}",
            "};"
        ],
        "description": "Basic operations on square matrices.",
        "prefix": [
            "hack_Matrix"
        ]
    },
    "MatrixInverse-mod.h": {
        "body": [
            "int matInv(vector<vector<ll>>& A) {",
            "\tint n = sz(A);",
            "\tvi col(n);",
            "\tvector<vector<ll>> tmp(n, vector<ll>(n));",
            "\trep(i, 0, n) tmp[i][i] = 1, col[i] = i;",
            "\trep(i, 0, n) {",
            "\t\tint r = i, c = i;",
            "\t\trep(j, i, n) rep(k, i, n) if (A[j][k]) {",
            "\t\t\tr = j;",
            "\t\t\tc = k;",
            "\t\t\tgoto found;",
            "\t\t}",
            "\t\treturn i;",
            "found:",
            "\t\tA[i].swap(A[r]);",
            "\t\ttmp[i].swap(tmp[r]);",
            "\t\trep(j, 0, n) swap(A[j][i], A[j][c]),",
            "\t\t\tswap(tmp[j][i], tmp[j][c]);",
            "\t\tswap(col[i], col[c]);",
            "\t\tll v = modpow(A[i][i], mod - 2);",
            "\t\trep(j, i + 1, n) {",
            "\t\t\tll f = A[j][i] * v % mod;",
            "\t\t\tA[j][i] = 0;",
            "\t\t\trep(k, i + 1, n) A[j][k] = (A[j][k] - f * A[i][k]) % mod;",
            "\t\t\trep(k, 0, n) tmp[j][k] =",
            "\t\t\t\t(tmp[j][k] - f * tmp[i][k]) % mod;",
            "\t\t}",
            "\t\trep(j, i + 1, n) A[i][j] = A[i][j] * v % mod;",
            "\t\trep(j, 0, n) tmp[i][j] = tmp[i][j] * v % mod;",
            "\t\tA[i][i] = 1;",
            "\t}",
            "\tfor (int i = n - 1; i > 0; --i) rep(j, 0, i) {",
            "\t\t\tll v = A[j][i];",
            "\t\t\trep(k, 0, n) tmp[j][k] =",
            "\t\t\t\t(tmp[j][k] - v * tmp[i][k]) % mod;",
            "\t\t}",
            "\trep(i, 0, n) rep(j, 0, n) A[col[i]][col[j]] =",
            "\t\ttmp[i][j] % mod + (tmp[i][j] < 0 ? mod : 0);",
            "\treturn n;",
            "}"
        ],
        "description": "Invert matrix $A$ modulo a prime.\nReturns rank; result is stored in $A$ unless singular (rank < n).\nFor prime powers, repeatedly set $A^{-1} = A^{-1} (2I - AA^{-1})\\  (\\text{mod }p^k)$ where $A^{-1}$ starts as\nthe inverse of A mod p, and k is doubled in each step.",
        "prefix": [
            "hack_MatrixInverse-mod"
        ]
    },
    "MatrixInverse.h": {
        "body": [
            "int matInv(vector<vector<double>>& A) {",
            "\tint n = sz(A);",
            "\tvi col(n);",
            "\tvector<vector<double>> tmp(n, vector<double>(n));",
            "\trep(i, 0, n) tmp[i][i] = 1, col[i] = i;",
            "\trep(i, 0, n) {",
            "\t\tint r = i, c = i;",
            "\t\trep(j, i, n)",
            "\t\t\trep(k, i, n) if (fabs(A[j][k]) > fabs(A[r][c])) r = j,",
            "\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tc = k;",
            "\t\tif (fabs(A[r][c]) < 1e-12) return i;",
            "\t\tA[i].swap(A[r]);",
            "\t\ttmp[i].swap(tmp[r]);",
            "\t\trep(j, 0, n) swap(A[j][i], A[j][c]),",
            "\t\t\tswap(tmp[j][i], tmp[j][c]);",
            "\t\tswap(col[i], col[c]);",
            "\t\tdouble v = A[i][i];",
            "\t\trep(j, i + 1, n) {",
            "\t\t\tdouble f = A[j][i] / v;",
            "\t\t\tA[j][i] = 0;",
            "\t\t\trep(k, i + 1, n) A[j][k] -= f * A[i][k];",
            "\t\t\trep(k, 0, n) tmp[j][k] -= f * tmp[i][k];",
            "\t\t}",
            "\t\trep(j, i + 1, n) A[i][j] /= v;",
            "\t\trep(j, 0, n) tmp[i][j] /= v;",
            "\t\tA[i][i] = 1;",
            "\t}",
            "\tfor (int i = n - 1; i > 0; --i) rep(j, 0, i) {",
            "\t\t\tdouble v = A[j][i];",
            "\t\t\trep(k, 0, n) tmp[j][k] -= v * tmp[i][k];",
            "\t\t}",
            "\trep(i, 0, n) rep(j, 0, n) A[col[i]][col[j]] = tmp[i][j];",
            "\treturn n;",
            "}"
        ],
        "description": "Invert matrix $A$. Returns rank; result is stored in $A$ unless singular (rank < n).\nCan easily be extended to prime moduli; for prime powers, repeatedly\nset $A^{-1} = A^{-1} (2I - AA^{-1})\\  (\\text{mod }p^k)$ where $A^{-1}$ starts as\nthe inverse of A mod p, and k is doubled in each step.",
        "prefix": [
            "hack_MatrixInverse"
        ]
    },
    "MaximalCliques.h": {
        "body": [
            "typedef bitset<128> B;",
            "template<class F>",
            "void cliques(vector<B>& eds, F f, B P = ~B(), B X = {},",
            "\tB R = {}) {",
            "\tif (!P.any()) {",
            "\t\tif (!X.any()) f(R);",
            "\t\treturn;",
            "\t}",
            "\tauto q = (P | X)._Find_first();",
            "\tauto cands = P & ~eds[q];",
            "\trep(i, 0, sz(eds)) if (cands[i]) {",
            "\t\tR[i] = 1;",
            "\t\tcliques(eds, f, P & eds[i], X & eds[i], R);",
            "\t\tR[i] = P[i] = 0;",
            "\t\tX[i] = 1;",
            "\t}",
            "}"
        ],
        "description": "Runs a callback for all maximal cliques in a graph (given as a\nsymmetric bitset matrix; self-edges not allowed). Callback is given a bitset\nrepresenting the maximal clique.",
        "prefix": [
            "hack_MaximalCliques"
        ]
    },
    "MaximumClique.h": {
        "body": [
            "typedef vector<bitset<200>> vb;",
            "struct Maxclique {",
            "\tdouble limit = 0.025, pk = 0;",
            "\tstruct Vertex {",
            "\t\tint i, d = 0;",
            "\t};",
            "\ttypedef vector<Vertex> vv;",
            "\tvb e;",
            "\tvv V;",
            "\tvector<vi> C;",
            "\tvi qmax, q, S, old;",
            "\tvoid init(vv& r) {",
            "\t\tfor (auto& v : r) v.d = 0;",
            "\t\tfor (auto& v : r)",
            "\t\t\tfor (auto j : r) v.d += e[v.i][j.i];",
            "\t\tsort(all(r), [](auto a, auto b) { return a.d > b.d; });",
            "\t\tint mxD = r[0].d;",
            "\t\trep(i, 0, sz(r)) r[i].d = min(i, mxD) + 1;",
            "\t}",
            "\tvoid expand(vv& R, int lev = 1) {",
            "\t\tS[lev] += S[lev - 1] - old[lev];",
            "\t\told[lev] = S[lev - 1];",
            "\t\twhile (sz(R)) {",
            "\t\t\tif (sz(q) + R.back().d <= sz(qmax)) return;",
            "\t\t\tq.push_back(R.back().i);",
            "\t\t\tvv T;",
            "\t\t\tfor (auto v : R)",
            "\t\t\t\tif (e[R.back().i][v.i]) T.push_back({v.i});",
            "\t\t\tif (sz(T)) {",
            "\t\t\t\tif (S[lev]++ / ++pk < limit) init(T);",
            "\t\t\t\tint j = 0, mxk = 1, mnk = max(sz(qmax) - sz(q) + 1, 1);",
            "\t\t\t\tC[1].clear(), C[2].clear();",
            "\t\t\t\tfor (auto v : T) {",
            "\t\t\t\t\tint k = 1;",
            "\t\t\t\t\tauto f = [&](int i) { return e[v.i][i]; };",
            "\t\t\t\t\twhile (any_of(all(C[k]), f)) k++;",
            "\t\t\t\t\tif (k > mxk) mxk = k, C[mxk + 1].clear();",
            "\t\t\t\t\tif (k < mnk) T[j++].i = v.i;",
            "\t\t\t\t\tC[k].push_back(v.i);",
            "\t\t\t\t}",
            "\t\t\t\tif (j > 0) T[j - 1].d = 0;",
            "\t\t\t\trep(k, mnk, mxk + 1) for (int i : C[k]) T[j].i = i,",
            "\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tT[j++].d = k;",
            "\t\t\t\texpand(T, lev + 1);",
            "\t\t\t} else if (sz(q) > sz(qmax)) qmax = q;",
            "\t\t\tq.pop_back(), R.pop_back();",
            "\t\t}",
            "\t}",
            "\tvi maxClique() {",
            "\t\tinit(V), expand(V);",
            "\t\treturn qmax;",
            "\t}",
            "\tMaxclique(vb conn): e(conn), C(sz(e) + 1), S(sz(C)), old(S) {",
            "\t\trep(i, 0, sz(e)) V.push_back({i});",
            "\t}",
            "};"
        ],
        "description": "Quickly finds a maximum clique of a graph (given as symmetric bitset\nmatrix; self-edges not allowed). Can be used to find a maximum independent\nset by finding a clique of the complement graph.",
        "prefix": [
            "hack_MaximumClique"
        ]
    },
    "MillerRabin.h": {
        "body": [
            "bool isPrime(ull n) {",
            "\tif (n < 2 || n % 6 % 4 != 1) return (n | 1) == 3;",
            "\tull A[] = {2, 325, 9375, 28178, 450775, 9780504, 1795265022},",
            "\t\t\ts = __builtin_ctzll(n - 1), d = n >> s;",
            "\tfor (ull a : A) { // ^ count trailing zeroes",
            "\t\tull p = modpow(a % n, d, n), i = s;",
            "\t\twhile (p != 1 && p != n - 1 && a % n && i--)",
            "\t\t\tp = modmul(p, p, n);",
            "\t\tif (p != n - 1 && i != s) return 0;",
            "\t}",
            "\treturn 1;",
            "}"
        ],
        "description": "Deterministic Miller-Rabin primality test.\nGuaranteed to work for numbers up to $7 \\cdot 10^{18}$; for larger numbers, use Python and extend A randomly.",
        "prefix": [
            "hack_MillerRabin"
        ]
    },
    "MinCostMaxFlow.h": {
        "body": [
            "#include <bits/extc++.h>",
            "const ll INF = numeric_limits<ll>::max() / 4;",
            "typedef vector<ll> VL;",
            "struct MCMF {",
            "\tint N;",
            "\tvector<vi> ed, red;",
            "\tvector<VL> cap, flow, cost;",
            "\tvi seen;",
            "\tVL dist, pi;",
            "\tvector<pii> par;",
            "\tMCMF(int N):",
            "\t\tN(N), ed(N), red(N), cap(N, VL(N)), flow(cap), cost(cap),",
            "\t\tseen(N), dist(N), pi(N), par(N) {}",
            "\tvoid addEdge(int from, int to, ll cap, ll cost) {",
            "\t\tthis->cap[from][to] = cap;",
            "\t\tthis->cost[from][to] = cost;",
            "\t\ted[from].push_back(to);",
            "\t\tred[to].push_back(from);",
            "\t}",
            "\tvoid path(int s) {",
            "\t\tfill(all(seen), 0);",
            "\t\tfill(all(dist), INF);",
            "\t\tdist[s] = 0;",
            "\t\tll di;",
            "\t\t__gnu_pbds::priority_queue<pair<ll, int>> q;",
            "\t\tvector<decltype(q)::point_iterator> its(N);",
            "\t\tq.push({0, s});",
            "\t\tauto relax = [&](int i, ll cap, ll cost, int dir) {",
            "\t\t\tll val = di - pi[i] + cost;",
            "\t\t\tif (cap && val < dist[i]) {",
            "\t\t\t\tdist[i] = val;",
            "\t\t\t\tpar[i] = {s, dir};",
            "\t\t\t\tif (its[i] == q.end()) its[i] = q.push({-dist[i], i});",
            "\t\t\t\telse q.modify(its[i], {-dist[i], i});",
            "\t\t\t}",
            "\t\t};",
            "\t\twhile (!q.empty()) {",
            "\t\t\ts = q.top().second;",
            "\t\t\tq.pop();",
            "\t\t\tseen[s] = 1;",
            "\t\t\tdi = dist[s] + pi[s];",
            "\t\t\tfor (int i : ed[s])",
            "\t\t\t\tif (!seen[i])",
            "\t\t\t\t\trelax(i, cap[s][i] - flow[s][i], cost[s][i], 1);",
            "\t\t\tfor (int i : red[s])",
            "\t\t\t\tif (!seen[i]) relax(i, flow[i][s], -cost[i][s], 0);",
            "\t\t}",
            "\t\trep(i, 0, N) pi[i] = min(pi[i] + dist[i], INF);",
            "\t}",
            "\tpair<ll, ll> maxflow(int s, int t) {",
            "\t\tll totflow = 0, totcost = 0;",
            "\t\twhile (path(s), seen[t]) {",
            "\t\t\tll fl = INF;",
            "\t\t\tfor (int p, r, x = t; tie(p, r) = par[x], x != s; x = p)",
            "\t\t\t\tfl = min(fl, r ? cap[p][x] - flow[p][x] : flow[x][p]);",
            "\t\t\ttotflow += fl;",
            "\t\t\tfor (int p, r, x = t; tie(p, r) = par[x], x != s; x = p)",
            "\t\t\t\tif (r) flow[p][x] += fl;",
            "\t\t\t\telse flow[x][p] -= fl;",
            "\t\t}",
            "\t\trep(i, 0, N) rep(j, 0, N) totcost +=",
            "\t\t\tcost[i][j] * flow[i][j];",
            "\t\treturn {totflow, totcost};",
            "\t}",
            "\t// If some costs can be negative, call this before maxflow:",
            "\tvoid setpi(int s) { // (otherwise, leave this out)",
            "\t\tfill(all(pi), INF);",
            "\t\tpi[s] = 0;",
            "\t\tint it = N, ch = 1;",
            "\t\tll v;",
            "\t\twhile (ch-- && it--)",
            "\t\t\trep(i, 0, N) if (pi[i] != INF) for (int to : ed[i]) if (",
            "\t\t\t\tcap[i][to]) if ((v = pi[i] + cost[i][to]) < pi[to])",
            "\t\t\t\tpi[to] = v,",
            "\t\t\t\tch = 1;",
            "\t\tassert(it >= 0); // negative cost cycle",
            "\t}",
            "};"
        ],
        "description": "Min-cost max-flow. cap[i][j] != cap[j][i] is allowed; double edges are not.\nIf costs can be negative, call setpi before maxflow, but note that negative cost cycles are not supported.\nTo obtain the actual flow, look at positive values only.",
        "prefix": [
            "hack_MinCostMaxFlow"
        ]
    },
    "MinRotation.h": {
        "body": [
            "int minRotation(string s) {",
            "\tint a = 0, N = sz(s);",
            "\ts += s;",
            "\trep(b, 0, N) rep(k, 0, N) {",
            "\t\tif (a + k == b || s[a + k] < s[b + k]) {",
            "\t\t\tb += max(0, k - 1);",
            "\t\t\tbreak;",
            "\t\t}",
            "\t\tif (s[a + k] > s[b + k]) {",
            "\t\t\ta = b;",
            "\t\t\tbreak;",
            "\t\t}",
            "\t}",
            "\treturn a;",
            "}"
        ],
        "description": "Finds the lexicographically smallest rotation of a string.",
        "prefix": [
            "hack_MinRotation"
        ]
    },
    "MinimumEnclosingCircle.h": {
        "body": [
            "pair<P, double> mec(vector<P> ps) {",
            "\tshuffle(all(ps), mt19937(time(0)));",
            "\tP o = ps[0];",
            "\tdouble r = 0, EPS = 1 + 1e-8;",
            "\trep(i, 0, sz(ps)) if ((o - ps[i]).dist() > r * EPS) {",
            "\t\to = ps[i], r = 0;",
            "\t\trep(j, 0, i) if ((o - ps[j]).dist() > r * EPS) {",
            "\t\t\to = (ps[i] + ps[j]) / 2;",
            "\t\t\tr = (o - ps[i]).dist();",
            "\t\t\trep(k, 0, j) if ((o - ps[k]).dist() > r * EPS) {",
            "\t\t\t\to = ccCenter(ps[i], ps[j], ps[k]);",
            "\t\t\t\tr = (o - ps[i]).dist();",
            "\t\t\t}",
            "\t\t}",
            "\t}",
            "\treturn {o, r};",
            "}"
        ],
        "description": "Computes the minimum circle that encloses a set of points.",
        "prefix": [
            "hack_MinimumEnclosingCircle"
        ]
    },
    "MoQueries.h": {
        "body": [
            "void add(int ind, int end) { ... } // add a[ind] (end = 0 or 1)",
            "void del(int ind, int end) { ... } // remove a[ind]",
            "int calc(){...} // compute current answer",
            "vi mo(vector<pii> Q) {",
            "\tint L = 0, R = 0, blk = 350; // ~N/sqrt(Q)",
            "\tvi s(sz(Q)), res = s;",
            "#define K(x) \\",
            "\tpii(x.first / blk, x.second ^ -(x.first / blk & 1))",
            "\tiota(all(s), 0);",
            "\tsort(all(s),",
            "\t\t[&](int s, int t) { return K(Q[s]) < K(Q[t]); });",
            "\tfor (int qi : s) {",
            "\t\tpii q = Q[qi];",
            "\t\twhile (L > q.first) add(--L, 0);",
            "\t\twhile (R < q.second) add(R++, 1);",
            "\t\twhile (L < q.first) del(L++, 0);",
            "\t\twhile (R > q.second) del(--R, 1);",
            "\t\tres[qi] = calc();",
            "\t}",
            "\treturn res;",
            "}",
            "vi moTree(vector<array<int, 2>> Q, vector<vi>& ed,",
            "\tint root = 0) {",
            "\tint N = sz(ed), pos[2] = {}, blk = 350; // ~N/sqrt(Q)",
            "\tvi s(sz(Q)), res = s, I(N), L(N), R(N), in(N), par(N);",
            "\tadd(0, 0), in[0] = 1;",
            "\tauto dfs = [&](int x, int p, int dep, auto& f) -> void {",
            "\t\tpar[x] = p;",
            "\t\tL[x] = N;",
            "\t\tif (dep) I[x] = N++;",
            "\t\tfor (int y : ed[x])",
            "\t\t\tif (y != p) f(y, x, !dep, f);",
            "\t\tif (!dep) I[x] = N++;",
            "\t\tR[x] = N;",
            "\t};",
            "\tdfs(root, -1, 0, dfs);",
            "#define K(x) pii(I[x[0]] / blk, I[x[1]] ^ -(I[x[0]] / blk & 1))",
            "\tiota(all(s), 0);",
            "\tsort(all(s),",
            "\t\t[&](int s, int t) { return K(Q[s]) < K(Q[t]); });",
            "\tfor (int qi : s) rep(end, 0, 2) {",
            "\t\t\tint &a = pos[end], b = Q[qi][end], i = 0;",
            "#define step(c)    \\",
            "\t{                \\",
            "\t\tif (in[c]) {   \\",
            "\t\t\tdel(a, end); \\",
            "\t\t\tin[a] = 0;   \\",
            "\t\t} else {       \\",
            "\t\t\tadd(c, end); \\",
            "\t\t\tin[c] = 1;   \\",
            "\t\t}              \\",
            "\t\ta = c;         \\",
            "\t}",
            "\t\t\twhile (!(L[b] <= L[a] && R[a] <= R[b]))",
            "\t\t\t\tI[i++] = b, b = par[b];",
            "\t\t\twhile (a != b) step(par[a]);",
            "\t\t\twhile (i--) step(I[i]);",
            "\t\t\tif (end) res[qi] = calc();",
            "\t\t}",
            "\treturn res;",
            "}"
        ],
        "description": "Answer interval or tree path queries by finding an approximate TSP through the queries,\nand moving from one query to the next by adding/removing points at the ends.\nIf values are on tree edges, change \\texttt{step} to add/remove the edge $(a, c)$ and remove the initial \\texttt{add} call (but keep \\texttt{in}).",
        "prefix": [
            "hack_MoQueries"
        ]
    },
    "ModInt.h": {
        "body": [
            "template<int MOD, int RT> struct mint {",
            "\tusing mr = const mint&;",
            "\tint v;",
            "\texplicit operator int() const {",
            "\t\treturn v;",
            "\t} // explicit -> don't silently convert to int",
            "\tmint(ll _v = 0) {",
            "\t\tv = int((-MOD < _v && _v < MOD) ? _v : _v % MOD);",
            "\t\tif (v < 0) v += MOD;",
            "\t}",
            "\tmint& operator+=(mr o) {",
            "\t\tif ((v += o.v) >= MOD) v -= MOD;",
            "\t\treturn *this;",
            "\t}",
            "\tmint& operator-=(mr o) {",
            "\t\tif ((v -= o.v) < 0) v += MOD;",
            "\t\treturn *this;",
            "\t}",
            "\tmint& operator*=(mr o) {",
            "\t\tv = int(ll(v) * o.v % MOD);",
            "\t\treturn *this;",
            "\t}",
            "\tmint& operator/=(mr o) { return (*this) *= inv(o); }",
            "\tfriend mint pow(mint a, ll p) {",
            "\t\tmint ans = 1;",
            "\t\tassert(p >= 0);",
            "\t\tfor (; p; p /= 2, a *= a)",
            "\t\t\tif (p & 1) ans *= a;",
            "\t\treturn ans;",
            "\t}",
            "\tfriend mint inv(mr a) {",
            "\t\tassert(a.v != 0);",
            "\t\treturn pow(a, MOD - 2);",
            "\t}",
            "\tfriend mint operator+(mint a, mr b) { return a += b; }",
            "\tfriend mint operator-(mint a, mr b) { return a -= b; }",
            "\tfriend mint operator*(mint a, mr b) { return a *= b; }",
            "\tfriend mint operator/(mint a, mr b) { return a /= b; }",
            "\tbool operator==(mr o) const { return v == o.v; }",
            "\tfriend bool operator!=(mr a, mr b) { return !(a == b); }",
            "\tfriend bool operator<(mr a, mr b) { return a.v < b.v; }",
            "\tmint operator-() const { return mint(-v); }",
            "\tmint& operator++() { return *this += 1; }",
            "\tmint& operator--() { return *this -= 1; }",
            "\tfriend istream& operator>>(istream& is, mint& a) {",
            "\t\treturn is >> a.v;",
            "\t}",
            "\tfriend ostream& operator<<(ostream& os, const mint& a) {",
            "\t\treturn os << a.v;",
            "\t}",
            "\tstatic constexpr mint rt() {",
            "\t\treturn RT;",
            "\t} // primitive root for FFT",
            "};",
            "using mi =",
            "\tmint<MOD, 5>; // 5 is primitive root for both common mods"
        ],
        "prefix": [
            "hack_ModInt"
        ]
    },
    "ModInverse.h": {
        "body": [
            "const ll mod = 1000000007, LIM = 200000;",
            "ll* inv = new ll[LIM] - 1;",
            "inv[1] = 1;",
            "rep(i, 2, LIM) inv[i] = mod - (mod / i) * inv[mod % i] % mod;"
        ],
        "description": "Pre-computation of modular inverses. Assumes LIM $\\le$ mod and that mod is a prime.",
        "prefix": [
            "hack_ModInverse"
        ]
    },
    "ModLog.h": {
        "body": [
            "ll modLog(ll a, ll b, ll m) {",
            "\tll n = (ll)sqrt(m) + 1, e = 1, f = 1, j = 1;",
            "\tunordered_map<ll, ll> A;",
            "\twhile (j <= n && (e = f = e * a % m) != b % m)",
            "\t\tA[e * b % m] = j++;",
            "\tif (e == b % m) return j;",
            "\tif (__gcd(m, e) == __gcd(m, b))",
            "\t\trep(i, 2, n + 2) if (A.count(e = e * f % m)) return n * i -",
            "\t\t\tA[e];",
            "\treturn -1;",
            "}"
        ],
        "description": "Returns the smallest $x > 0$ s.t. $a^x = b \\pmod m$, or\n$-1$ if no such $x$ exists. modLog(a,1,m) can be used to\ncalculate the order of $a$.",
        "prefix": [
            "hack_ModLog"
        ]
    },
    "ModMulLL.h": {
        "body": [
            "typedef unsigned long long ull;",
            "ull modmul(ull a, ull b, ull M) {",
            "\tll ret = a * b - M * ull(1.L / M * a * b);",
            "\treturn ret + M * (ret < 0) - M * (ret >= (ll)M);",
            "}",
            "ull modpow(ull b, ull e, ull mod) {",
            "\tull ans = 1;",
            "\tfor (; e; b = modmul(b, b, mod), e /= 2)",
            "\t\tif (e & 1) ans = modmul(ans, b, mod);",
            "\treturn ans;",
            "}"
        ],
        "description": "Calculate $a\\cdot b\\bmod c$ (or $a^b \\bmod c$) for $0 \\le a, b \\le c \\le 7.2\\cdot 10^{18}$.",
        "prefix": [
            "hack_ModMulLL"
        ]
    },
    "ModPow.h": {
        "body": [
            "const ll mod = 1000000007; // faster if const",
            "ll modpow(ll b, ll e) {",
            "\tll ans = 1;",
            "\tfor (; e; b = b * b % mod, e /= 2)",
            "\t\tif (e & 1) ans = ans * b % mod;",
            "\treturn ans;",
            "}"
        ],
        "description": "",
        "prefix": [
            "hack_ModPow"
        ]
    },
    "ModSqrt.h": {
        "body": [
            "ll sqrt(ll a, ll p) {",
            "\ta %= p;",
            "\tif (a < 0) a += p;",
            "\tif (a == 0) return 0;",
            "\tassert(modpow(a, (p - 1) / 2, p) == 1); // else no solution",
            "\tif (p % 4 == 3) return modpow(a, (p + 1) / 4, p);",
            "\t// a^(n+3)/8 or 2^(n+3)/8 * 2^(n-1)/4 works if p % 8 == 5",
            "\tll s = p - 1, n = 2;",
            "\tint r = 0, m;",
            "\twhile (s % 2 == 0) ++r, s /= 2;",
            "\twhile (modpow(n, (p - 1) / 2, p) != p - 1) ++n;",
            "\tll x = modpow(a, (s + 1) / 2, p);",
            "\tll b = modpow(a, s, p), g = modpow(n, s, p);",
            "\tfor (;; r = m) {",
            "\t\tll t = b;",
            "\t\tfor (m = 0; m < r && t != 1; ++m) t = t * t % p;",
            "\t\tif (m == 0) return x;",
            "\t\tll gs = modpow(g, 1LL << (r - m - 1), p);",
            "\t\tg = gs * gs % p;",
            "\t\tx = x * gs % p;",
            "\t\tb = b * g % p;",
            "\t}",
            "}"
        ],
        "description": "Tonelli-Shanks algorithm for modular square roots. Finds $x$ s.t. $x^2 = a \\pmod p$ ($-x$ gives the other solution).",
        "prefix": [
            "hack_ModSqrt"
        ]
    },
    "MonotonicQueue.h": {
        "body": [
            "template<class T, class Compare = less<T>>",
            "struct monotonic_queue: queue<T> {",
            "\tusing q = queue<T>;",
            "\tdeque<T> mq;",
            "\tCompare cmp;",
            "\tconst T& min() { return assert(!q::empty()), mq.front(); }",
            "\tvoid update() {",
            "\t\twhile (!mq.empty() && cmp(q::back(), mq.back()))",
            "\t\t\tmq.pop_back();",
            "\t\tmq.push_back(q::back());",
            "\t}",
            "\tvoid pop() {",
            "\t\tassert(!q::empty());",
            "\t\tif (!mq.empty() && !cmp(mq.front(), q::front()))",
            "\t\t\tmq.pop_front();",
            "\t\tq::pop();",
            "\t}",
            "\tvoid push(const T& val) { queue<T>::push(val), update(); }",
            "\tvoid push(T&& val) { queue<T>::push(val), update(); }",
            "\ttemplate<class... Args> void emplace(Args&&... args) {",
            "\t\tq::emplace(args...), update();",
            "\t}",
            "};"
        ],
        "description": "Queue that maintains its minimum/maximum element.",
        "prefix": [
            "hack_MonotonicQueue"
        ]
    },
    "MultiplicativePrefixSum.h": {
        "body": [
            "/*\tPrefix sum of multiplicative functions :",
            "\t\tp_f : the prefix sum of f (x) (1 <= x <= th).",
            "\t\tp_g : the prefix sum of g (x) (0 <= x <= N).",
            "\t\tp_c : the prefix sum of f * g (x) (0 <= x <= N).",
            "\t\tth : the thereshold, generally should be n ^ (2 / 3).",
            "*/",
            "typedef ll (*func)(ll);",
            "template<func p_f, func p_g, func p_c, ll TH>",
            "struct prefix_mul {",
            "\tll n, inv;",
            "\tunordered_map<ll, ll> mem;",
            "\tll calc(ll x) {",
            "\t\tif (x < TH) return p_f(x);",
            "\t\tauto it = mem.find(x);",
            "\t\tif (it != mem.end()) return it->second;",
            "\t\tll ans = 0;",
            "\t\tfor (ll i = 2, la; i <= x; i = la + 1) {",
            "\t\t\tla = x / (x / i);",
            "\t\t\tans =",
            "\t\t\t\t(ans + (p_g(la) - p_g(i - 1) + mod) * calc(x / i)) %",
            "\t\t\t\tmod;",
            "\t\t}",
            "\t\tans = (p_c(x) - ans + mod) * inv % mod;",
            "\t\treturn mem[x] = ans;",
            "\t}",
            "\tll solve(ll n) {",
            "\t\tif (n <= 0) return 0;",
            "\t\tthis->n = n;",
            "\t\tinv = binpow(p_g(1), mod - 2);",
            "\t\treturn calc(n);",
            "\t}",
            "};"
        ],
        "prefix": [
            "hack_MultiplicativePrefixSum"
        ]
    },
    "MultiplicativeSieve.h": {
        "body": [
            "const int LIM = 1e6 + 10;",
            "vi primes;",
            "bitset<LIM> notPrime;",
            "int ps[LIM], ks[LIM];",
            "ll f[LIM];",
            "template<ll (*g)(int, int, int)> void sieve(int n = LIM) {",
            "\tf[1] = 1;",
            "\tfor (int i = 2; i < n; i++) {",
            "\t\tif (!notPrime[i]) {",
            "\t\t\tprimes.push_back(i);",
            "\t\t\tps[i] = i, ks[i] = 1;",
            "\t\t\tf[i] = g(i, i, 1);",
            "\t\t\tfor (ll pk = i, x = 1ll * i * i; x < n;",
            "\t\t\t\t\t pk *= i, x *= i) {",
            "\t\t\t\tps[x] = x, ks[x] = ks[pk] + 1;",
            "\t\t\t\tf[x] = g(x, i, ks[x]);",
            "\t\t\t}",
            "\t\t}",
            "\t\tfor (ll j = 0, p;",
            "\t\t\t\t j < sz(primes) && (p = primes[j]) * i < n; j++) {",
            "\t\t\tll x = i * p;",
            "\t\t\tif (x >= n) break;",
            "\t\t\tnotPrime[x] = 1;",
            "\t\t\tif (i % p == 0) {",
            "\t\t\t\tif (i != ps[i]) {",
            "\t\t\t\t\tps[x] = ps[i] * p, ks[x] = ks[i] + 1;",
            "\t\t\t\t\tf[x] = f[i / ps[i]] * f[ps[x]];",
            "\t\t\t\t}",
            "\t\t\t\tbreak;",
            "\t\t\t} else {",
            "\t\t\t\tf[x] = f[i] * f[p];",
            "\t\t\t\tps[x] = p, ks[x] = 1;",
            "\t\t\t}",
            "\t\t}",
            "\t}",
            "}"
        ],
        "prefix": [
            "hack_MultiplicativeSieve"
        ]
    },
    "Multipoint.h": {
        "body": [
            "vl inv(const vl& a, int N) {",
            "\tvl b = {modpow(a[0], mod - 2)};",
            "\tint k = 1;",
            "\tfor (int k = 2; k / 2 < N; k *= 2) {",
            "\t\tvl temp = {begin(a), sz(a) > k ? begin(a) + k : end(a)};",
            "\t\ttemp = conv(temp, b);",
            "\t\tfor (int i = 0; i < sz(temp); i++)",
            "\t\t\tif (temp[i]) temp[i] = mod - temp[i];",
            "\t\ttemp[0] += 2;",
            "\t\tif (temp[0] >= mod) temp[0] -= mod;",
            "\t\tb = conv(temp, b);",
            "\t\tb.resize(min(k, N));",
            "\t}",
            "\treturn b;",
            "}",
            "pair<vl, vl> div(vl& a, vl& b) {",
            "\tif (sz(a) < sz(b)) return {{}, a};",
            "\treverse(all(a)), reverse(all(b));",
            "\tvl q = conv(a, inv(b, sz(a) - sz(b) + 1));",
            "\tq.resize(sz(a) - sz(b) + 1);",
            "\treverse(all(a)), reverse(all(b)), reverse(all(q));",
            "\tint cap = 0;",
            "\tvl r = conv(b, q);",
            "\trep(i, 0, sz(a)) {",
            "\t\tr[i] = a[i] + mod - r[i];",
            "\t\tif (r[i] >= mod) r[i] -= mod;",
            "\t\tif (r[i]) cap = i + 1;",
            "\t}",
            "\tr.resize(cap);",
            "\treturn {q, r};",
            "}",
            "const int M = 1 << 17;",
            "vl t[4 * M]; // about 2 sec",
            "void build(int v, int lo, int hi, vl& x) {",
            "\tif (hi - lo == 1) // handle if negative or w/e",
            "\t\tt[v] = {x[lo] ? mod - x[lo] : 0, 1};",
            "\telse {",
            "\t\tint mid = (lo + hi) / 2;",
            "\t\tbuild(2 * v, lo, mid, x), build(2 * v + 1, mid, hi, x);",
            "\t\tt[v] = conv(t[2 * v], t[2 * v + 1]);",
            "\t}",
            "}",
            "void calc(int v, int lo, int hi, vl a, vl& ans) {",
            "\ta = div(a, t[v]).second;",
            "\tif (hi - lo == 1) {",
            "\t\tans[lo] = sz(a) ? a[0] : 0;",
            "\t\treturn;",
            "\t}",
            "\tint mid = (lo + hi) / 2;",
            "\tcalc(2 * v, lo, mid, a, ans);",
            "\tcalc(2 * v + 1, mid, hi, a, ans);",
            "}"
        ],
        "prefix": [
            "hack_Multipoint"
        ]
    },
    "NDimensionalVector.h": {
        "body": [
            "template<int D, class T> struct Vec: vector<Vec<D - 1, T>> {",
            "\ttemplate<class... Args>",
            "\tVec(int n = 0, Args... args):",
            "\t\tvector<Vec<D - 1, T>>(n, Vec<D - 1, T>(args...)) {}",
            "};",
            "template<class T> struct Vec<1, T>: vector<T> {",
            "\tVec(int n = 0, const T& val = T()): vector<T>(n, val) {}",
            "};"
        ],
        "prefix": [
            "hack_NDimensionalVector"
        ]
    },
    "NumberTheoreticTransform.h": {
        "body": [
            "const ll mod = (119 << 23) + 1, root = 62; // = 998244353",
            "// For p < 2^30 there is also e.g. 5 << 25, 7 << 26, 479 << 21",
            "// and 483 << 21 (same root). The last two are > 10^9.",
            "typedef vector<ll> vl;",
            "void ntt(vl &a) {",
            "\tint n = sz(a), L = 31 - __builtin_clz(n);",
            "\tstatic vl rt(2, 1);",
            "\tfor (static int k = 2, s = 2; k < n; k *= 2, s++) {",
            "\t\trt.resize(n);",
            "\t\tll z[] = {1, modpow(root, mod >> s)};",
            "\t\trep(i, k, 2 * k) rt[i] = rt[i / 2] * z[i & 1] % mod;",
            "\t}",
            "\tvi rev(n);",
            "\trep(i, 0, n) rev[i] = (rev[i / 2] | (i & 1) << L) / 2;",
            "\trep(i, 0, n) if (i < rev[i]) swap(a[i], a[rev[i]]);",
            "\tfor (int k = 1; k < n; k *= 2)",
            "\t\tfor (int i = 0; i < n; i += 2 * k) rep(j, 0, k) {",
            "\t\t\t\tll z = rt[j + k] * a[i + j + k] % mod, &ai = a[i + j];",
            "\t\t\t\ta[i + j + k] = ai - z + (z > ai ? mod : 0);",
            "\t\t\t\tai += (ai + z >= mod ? z - mod : z);",
            "\t\t\t}",
            "}",
            "vl conv(const vl &a, const vl &b) {",
            "\tif (a.empty() || b.empty()) return {};",
            "\tint s = sz(a) + sz(b) - 1, B = 32 - __builtin_clz(s),",
            "\t\t\tn = 1 << B;",
            "\tint inv = modpow(n, mod - 2);",
            "\tvl L(a), R(b), out(n);",
            "\tL.resize(n), R.resize(n);",
            "\tntt(L), ntt(R);",
            "\trep(i, 0, n) out[-i & (n - 1)] =",
            "\t\t(ll)L[i] * R[i] % mod * inv % mod;",
            "\tntt(out);",
            "\treturn {out.begin(), out.begin() + s};",
            "}"
        ],
        "description": "ntt(a) computes $\\hat f(k) = \\sum_x a[x] g^{xk}$ for all $k$, where $g=\\text{root}^{(mod-1)/N}$.\nN must be a power of 2.\nUseful for convolution modulo specific nice primes of the form $2^a b+1$,\nwhere the convolution result has size at most $2^a$. For arbitrary modulo, see FFTMod.\n\\texttt{conv(a, b) = c}, where $c[x] = \\sum a[i]b[x-i]$.\nFor manual convolution: NTT the inputs, multiply\npointwise, divide by n, reverse(start+1, end), NTT back.\nInputs must be in [0, mod).",
        "prefix": [
            "hack_NumberTheoreticTransform"
        ]
    },
    "OnSegment.h": {
        "body": [
            "template<class P> bool onSegment(P s, P e, P p) {",
            "\treturn p.cross(s, e) == 0 && (s - p).dot(e - p) <= 0;",
            "}"
        ],
        "description": "Returns true iff p lies on the line segment from s to e.\nUse \\texttt{(segDist(s,e,p)<=epsilon)} instead when using Point<double>.",
        "prefix": [
            "hack_OnSegment"
        ]
    },
    "OrderStatisticTree.h": {
        "body": [
            "#include <ext/pb_ds/assoc_container.hpp>",
            "#include <ext/pb_ds/tree_policy.hpp>",
            "using namespace __gnu_pbds;",
            "template<class T>",
            "using Tree = tree<T, null_type, less<T>, rb_tree_tag,",
            "\ttree_order_statistics_node_update>;",
            "void example() {",
            "\tTree<int> t, t2;",
            "\tt.insert(8);",
            "\tauto it = t.insert(10).first;",
            "\tassert(it == t.lower_bound(9));",
            "\tassert(t.order_of_key(10) == 1);",
            "\tassert(t.order_of_key(11) == 2);",
            "\tassert(*t.find_by_order(0) == 8);",
            "\tt.join(t2); // assuming T < T2 or T > T2, merge t2 into t",
            "}"
        ],
        "description": "A set (not multiset!) with support for finding the n'th\nelement, and finding the index of an element.\nTo get a map, change \\texttt{null\\_type}.",
        "prefix": [
            "hack_OrderStatisticTree"
        ]
    },
    "PlanarFaceExtraction.h": {
        "body": [
            "template<class P> struct Edge {",
            "\tint id;",
            "\tP a, b, ab;",
            "\tEdge *rev, *prev;",
            "\tbool used, isBorder;",
            "\tEdge(P a, P b):",
            "\t\tid(0), a(a), b(b), ab(b - a), rev(NULL), prev(NULL),",
            "\t\tused(0), isBorder(0) {}",
            "\tfriend ostream &operator<<(ostream &os, Edge e) {",
            "\t\treturn os << e.id;",
            "\t}",
            "};",
            "// Takes a bunch of points and adjacency array. No lines formed by adjacent points can cross!",
            "// Returns an array list of polygons formed by these points and adjs",
            "// No two points can be the same. Points will be assigned IDs in order given.",
            "// Will not form polygons with holes (there may be nested polygons you need to check for)",
            "// O(v + m log m)",
            "template<class P>",
            "vector<vector<Edge<P> *>> extractPolygons(vector<P> &points,",
            "\tvector<vi> &adjs) {",
            "\tusing Edge = Edge<P>;",
            "\tint n = sz(points),",
            "\t\t\tcurEId = 0; // # of poly-poly edges; can keep global",
            "\tvector<vector<Edge *>> edges(n);",
            "\tvi idxs(n);",
            "\trep(i, 0, n) edges[i].resize(sz(adjs[i]));",
            "\tfor (int i = 0; i < n; i++) {",
            "\t\tP p = points[i];",
            "\t\tfor (int next : adjs[i]) {",
            "\t\t\tif (next < i) continue;",
            "\t\t\tP q = points[next];",
            "\t\t\tEdge *a = new Edge(p, q), *b = new Edge(q, p);",
            "\t\t\ta->id = b->id = curEId++;",
            "\t\t\tedges[i][idxs[i]++] = b->rev = a;",
            "\t\t\tedges[next][idxs[next]++] = a->rev = b;",
            "\t\t}",
            "\t}",
            "\trep(i, 0, n) {",
            "\t\tint len = sz(edges[i]);",
            "\t\tsort(all(edges[i]), [&](auto ea, auto eb) {",
            "\t\t\t// or another more stable radial sort of your choosing",
            "\t\t\treturn atan2l(ea->ab.y, ea->ab.x) <",
            "\t\t\t\tatan2l(eb->ab.y, eb->ab.x);",
            "\t\t});",
            "\t\trep(j, 0, len) edges[i][(j + 1) % len]->prev = edges[i][j];",
            "\t}",
            "\tvector<vector<Edge *>> polys;",
            "\tfor (int i = 0; i < n; i++) {",
            "\t\tP cur = points[i];",
            "\t\tfor (Edge *e : edges[i]) {",
            "\t\t\tif (e->used) continue;",
            "\t\t\te->used = true;",
            "\t\t\tvector<Edge *> edgeList{e};",
            "\t\t\tcur = e->b;",
            "\t\t\twhile (true) {",
            "\t\t\t\te = e->rev->prev;",
            "\t\t\t\tif (e->used) break;",
            "\t\t\t\te->used = true;",
            "\t\t\t\tedgeList.pb(e);",
            "\t\t\t\tcur = e->b;",
            "\t\t\t}",
            "\t\t\tpolys.pb({edgeList});",
            "\t\t}",
            "\t}",
            "\tvector<vector<Edge *>> res;",
            "\tfor (vector<Edge *> &p : polys) {",
            "\t\tld a = 0;",
            "\t\tfor (Edge *e : p) a = a + e->a.cross(e->b);",
            "\t\tif (a >= 0) res.pb(p); // Normal polygon (maybe 0 area)",
            "\t\telse // Else, this the border polygon (vs in reverse order)",
            "\t\t\tfor (Edge *e : p) e->isBorder = true;",
            "\t}",
            "\treturn res;",
            "}"
        ],
        "description": "Takes a bunch of points and adjacency array. No lines formed by adjacent points can cross!\nReturns an array list of polygons formed by these points and adjs\nNo two points can be the same. Points will be assigned IDs in order given.\nWill not form polygons with holes (there may be nested polygons you need to check for)",
        "prefix": [
            "hack_PlanarFaceExtraction"
        ]
    },
    "Point.h": {
        "body": [
            "template<class T> int sgn(T x) { return (x > 0) - (x < 0); }",
            "template<class T> struct Point {",
            "\ttypedef Point P;",
            "\tT x, y;",
            "\texplicit Point(T x = 0, T y = 0): x(x), y(y) {}",
            "\tbool operator<(P p) const {",
            "\t\treturn tie(x, y) < tie(p.x, p.y);",
            "\t}",
            "\tbool operator==(P p) const {",
            "\t\treturn tie(x, y) == tie(p.x, p.y);",
            "\t}",
            "\tP operator+(P p) const { return P(x + p.x, y + p.y); }",
            "\tP operator-(P p) const { return P(x - p.x, y - p.y); }",
            "\tP operator*(T d) const { return P(x * d, y * d); }",
            "\tP operator/(T d) const { return P(x / d, y / d); }",
            "\tT dot(P p) const { return x * p.x + y * p.y; }",
            "\tT cross(P p) const { return x * p.y - y * p.x; }",
            "\tT cross(P a, P b) const {",
            "\t\treturn (a - *this).cross(b - *this);",
            "\t}",
            "\tT dist2() const { return x * x + y * y; }",
            "\tdouble dist() const { return sqrt((double)dist2()); }",
            "\t// angle to x-axis in interval [-pi, pi]",
            "\tdouble angle() const { return atan2(y, x); }",
            "\tP unit() const { return *this / dist(); } // makes dist()=1",
            "\tP perp() const { return P(-y, x); } // rotates +90 degrees",
            "\tP normal() const { return perp().unit(); }",
            "\t// returns point rotated 'a' radians ccw around the origin",
            "\tP rotate(double a) const {",
            "\t\treturn P(x * cos(a) - y * sin(a), x * sin(a) + y * cos(a));",
            "\t}",
            "\tfriend ostream& operator<<(ostream& os, P p) {",
            "\t\treturn os << \"(\" << p.x << \",\" << p.y << \")\";",
            "\t}",
            "};"
        ],
        "description": "Class to handle points in the plane.\nT can be e.g. double or long long. (Avoid int.)",
        "prefix": [
            "hack_Point"
        ]
    },
    "Point3D.h": {
        "body": [
            "template<class T> struct Point3D {",
            "\ttypedef Point3D P;",
            "\ttypedef const P& R;",
            "\tT x, y, z;",
            "\texplicit Point3D(T x = 0, T y = 0, T z = 0):",
            "\t\tx(x), y(y), z(z) {}",
            "\tbool operator<(R p) const {",
            "\t\treturn tie(x, y, z) < tie(p.x, p.y, p.z);",
            "\t}",
            "\tbool operator==(R p) const {",
            "\t\treturn tie(x, y, z) == tie(p.x, p.y, p.z);",
            "\t}",
            "\tP operator+(R p) const {",
            "\t\treturn P(x + p.x, y + p.y, z + p.z);",
            "\t}",
            "\tP operator-(R p) const {",
            "\t\treturn P(x - p.x, y - p.y, z - p.z);",
            "\t}",
            "\tP operator*(T d) const { return P(x * d, y * d, z * d); }",
            "\tP operator/(T d) const { return P(x / d, y / d, z / d); }",
            "\tT dot(R p) const { return x * p.x + y * p.y + z * p.z; }",
            "\tP cross(R p) const {",
            "\t\treturn P(y * p.z - z * p.y, z * p.x - x * p.z,",
            "\t\t\tx * p.y - y * p.x);",
            "\t}",
            "\tT dist2() const { return x * x + y * y + z * z; }",
            "\tdouble dist() const { return sqrt((double)dist2()); }",
            "\t//Azimuthal angle (longitude) to x-axis in interval [-pi, pi]",
            "\tdouble phi() const { return atan2(y, x); }",
            "\t//Zenith angle (latitude) to the z-axis in interval [0, pi]",
            "\tdouble theta() const {",
            "\t\treturn atan2(sqrt(x * x + y * y), z);",
            "\t}",
            "\tP unit() const { return *this / (T)dist(); } //makes dist()=1",
            "\t//returns unit vector normal to *this and p",
            "\tP normal(P p) const { return cross(p).unit(); }",
            "\t//returns point rotated 'angle' radians ccw around axis",
            "\tP rotate(double angle, P axis) const {",
            "\t\tdouble s = sin(angle), c = cos(angle);",
            "\t\tP u = axis.unit();",
            "\t\treturn u * dot(u) * (1 - c) + (*this) * c - cross(u) * s;",
            "\t}",
            "};"
        ],
        "description": "Class to handle points in 3D space.\nT can be e.g. double or long long.",
        "prefix": [
            "hack_Point3D"
        ]
    },
    "PointInsideHull.h": {
        "body": [
            "typedef Point<ll> P;",
            "bool inHull(const vector<P>& l, P p, bool strict = true) {",
            "\tint a = 1, b = sz(l) - 1, r = !strict;",
            "\tif (sz(l) < 3) return r && onSegment(l[0], l.back(), p);",
            "\tif (sideOf(l[0], l[a], l[b]) > 0) swap(a, b);",
            "\tif (",
            "\t\tsideOf(l[0], l[a], p) >= r || sideOf(l[0], l[b], p) <= -r)",
            "\t\treturn false;",
            "\twhile (abs(a - b) > 1) {",
            "\t\tint c = (a + b) / 2;",
            "\t\t(sideOf(l[0], l[c], p) > 0 ? b : a) = c;",
            "\t}",
            "\treturn sgn(l[a].cross(l[b], p)) < r;",
            "}"
        ],
        "description": "Determine whether a point t lies inside a convex hull (CCW\norder, with no collinear points). Returns true if point lies within\nthe hull. If strict is true, points on the boundary aren't included.",
        "prefix": [
            "hack_PointInsideHull"
        ]
    },
    "PointRotator.h": {
        "body": [
            "using namespace std;",
            "#define sz(x) int(size(x))",
            "#define all(x) begin(x), end(x)",
            "using ll = long long;",
            "using vi = vector<int>;",
            "template<class T> int sgn(T x) { return (x > 0) - (x < 0); }",
            "template<class T> struct Point {",
            "\ttypedef Point P;",
            "\tT x, y;",
            "\texplicit Point(T x = 0, T y = 0): x(x), y(y) {}",
            "\tbool operator<(P p) const {",
            "\t\treturn tie(y, x) < tie(p.y, p.x);",
            "\t}",
            "\tbool operator==(P p) const {",
            "\t\treturn tie(x, y) == tie(p.x, p.y);",
            "\t}",
            "\tP operator+(P p) const { return P(x + p.x, y + p.y); }",
            "\tP operator-(P p) const { return P(x - p.x, y - p.y); }",
            "\tP operator*(T d) const { return P(x * d, y * d); }",
            "\tP operator/(T d) const { return P(x / d, y / d); }",
            "\tT dot(P p) const { return x * p.x + y * p.y; }",
            "\tT cross(P p) const { return x * p.y - y * p.x; }",
            "\tT cross(P a, P b) const {",
            "\t\treturn (a - *this).cross(b - *this);",
            "\t}",
            "\tT dist2() const { return x * x + y * y; }",
            "\tdouble dist() const { return sqrt((double)dist2()); }",
            "\t// angle to x-axis in interval [-pi, pi]",
            "\tdouble angle() const { return atan2(y, x); }",
            "\tP unit() const { return *this / dist(); } // makes dist()=1",
            "\tP perp() const { return P(-y, x); } // rotates +90 degrees",
            "\tP normal() const { return perp().unit(); }",
            "\t// returns point rotated 'a' radians ccw around the origin",
            "\tP rotate(double a) const {",
            "\t\treturn P(x * cos(a) - y * sin(a), x * sin(a) + y * cos(a));",
            "\t}",
            "\tfriend ostream& operator<<(ostream& os, P p) {",
            "\t\treturn os << \"(\" << p.x << \",\" << p.y << \")\";",
            "\t}",
            "};",
            "using P = Point<ll>;",
            "struct Angle {",
            "\tint x, y;",
            "\tint t;",
            "\tAngle(int x, int y, int t = 0): x(x), y(y), t(t) {}",
            "\tAngle operator-(Angle b) const {",
            "\t\treturn {x - b.x, y - b.y, t};",
            "\t}",
            "\tint half() const {",
            "\t\tassert(x || y);",
            "\t\treturn y < 0 || (y == 0 && x < 0);",
            "\t}",
            "\tAngle t90() const { return {-y, x, t + (half() && x >= 0)}; }",
            "\tAngle t180() const { return {-x, -y, t + half()}; }",
            "\tAngle t360() const { return {x, y, t + 1}; }",
            "};",
            "bool operator<(Angle a, Angle b) {",
            "\t// add a.dist2() and b.dist2() to also compare distances",
            "\treturn make_tuple(a.t, a.half(), a.y * (ll)b.x) <",
            "\t\tmake_tuple(b.t, b.half(), a.x * (ll)b.y);",
            "}",
            "using bs = bitset<2000 + 5>;",
            "void solve() {",
            "\tint n;",
            "\tcin >> n;",
            "\tvector<P> pts(n);",
            "\tfor (int i = 0; i < n; i++) cin >> pts[i].x >> pts[i].y;",
            "\tassert(n % 2 == 0);",
            "\tvi order(n), inv(n);",
            "\tiota(all(order), 0);",
            "\tsort(all(order),",
            "\t\t[&](int i, int j) { return pts[i] < pts[j]; });",
            "\tbs curr;",
            "\tbs curr2;",
            "\tfor (int i = 0; i < n; i++) {",
            "\t\tinv[order[i]] = i;",
            "\t\tif (i < n / 2) curr[order[i]] = 1;",
            "\t\telse curr2[order[i]] = 1;",
            "\t}",
            "\tauto doSwap = [&](int i, int j) {",
            "\t\tif (i == j) return;",
            "\t\tint pi = inv[i], pj = inv[j];",
            "\t\tbool temp = curr[i];",
            "\t\tcurr[i] = curr[j];",
            "\t\tcurr[j] = temp;",
            "\t\ttemp = curr2[i];",
            "\t\tcurr2[i] = curr2[j];",
            "\t\tcurr2[j] = temp;",
            "\t\tswap(order[pi], order[pj]);",
            "\t\tswap(inv[i], inv[j]);",
            "\t};",
            "\t// vector<tuple<Angle, int, int>> swaps;",
            "\tmap<Angle, map<ll, vi>> swaps;",
            "\tfor (int i = 0; i < n; i++)",
            "\t\tfor (int j = i + 1; j < n; j++) {",
            "\t\t\tP v = pts[j] - pts[i];",
            "\t\t\tif (v.y < 0 || (v.y == 0 && v.x < 0)) v = v * -1;",
            "\t\t\tll g = __gcd(abs(v.x), abs(v.y));",
            "\t\t\tassert(g != 0);",
            "\t\t\tv = v / g;",
            "\t\t\tAngle a(v.x, v.y);",
            "\t\t\tswaps[a][v.cross(pts[j])].push_back(i);",
            "\t\t\tswaps[a][v.cross(pts[j])].push_back(j);",
            "\t\t}",
            "\tauto orig = order;",
            "\tunordered_set<bs> grps;",
            "\tgrps.insert(curr);",
            "\tgrps.insert(curr2);",
            "\t// cout << \"base:\\n\" << curr << \"\\n\" << curr2 << \"\\n\";",
            "\tfor (auto& [_, under] : swaps) {",
            "\t\tfor (auto& [val, idxs] : under) {",
            "\t\t\tsort(all(idxs));",
            "\t\t\tidxs.erase(unique(all(idxs)), end(idxs));",
            "\t\t\tsort(all(idxs),",
            "\t\t\t\t[&](int i, int j) { return inv[i] < inv[j]; });",
            "\t\t\t// cout << \"rev: \";",
            "\t\t\t// for (int i : idxs) cout << pts[i] << \" \";",
            "\t\t\t// cout << \"\\n\";",
            "\t\t\tint i = 0, j = sz(idxs) - 1;",
            "\t\t\twhile (i < j) doSwap(idxs[i++], idxs[j--]);",
            "\t\t}",
            "\t\tgrps.insert(curr);",
            "\t\tgrps.insert(curr2);",
            "\t\t// cout << \"have!: \";",
            "\t\t// for (int i : order) cout << pts[i] << \" \";",
            "\t\t// cout << \"\\n\";",
            "\t\t// cout << \"then:\\n\" << curr << \"\\n\" << curr2 << \"\\n\";",
            "\t}",
            "\tgrps.insert(curr);",
            "\t// cout << \"last:\\n\" << curr << \"\\n\" << curr2 << \"\\n\";",
            "\tcout << sz(grps) << \"\\n\";",
            "}",
            "int main() {",
            "\tcin.tie(0)->sync_with_stdio(0);",
            "\tcin.exceptions(cin.failbit);",
            "\tsolve();",
            "\treturn 0;",
            "}"
        ],
        "prefix": [
            "hack_PointRotator"
        ]
    },
    "PolygonArea.h": {
        "body": [
            "template<class T> T polygonArea2(vector<Point<T>>& v) {",
            "\tT a = v.back().cross(v[0]);",
            "\trep(i, 0, sz(v) - 1) a += v[i].cross(v[i + 1]);",
            "\treturn a;",
            "}"
        ],
        "description": "Returns twice the signed area of a polygon.\nClockwise enumeration gives negative area. Watch out for overflow if using int as T!",
        "prefix": [
            "hack_PolygonArea"
        ]
    },
    "PolygonCenter.h": {
        "body": [
            "typedef Point<double> P;",
            "P polygonCenter(const vector<P>& v) {",
            "\tP res(0, 0);",
            "\tdouble A = 0;",
            "\tfor (int i = 0, j = sz(v) - 1; i < sz(v); j = i++) {",
            "\t\tres = res + (v[i] + v[j]) * v[j].cross(v[i]);",
            "\t\tA += v[j].cross(v[i]);",
            "\t}",
            "\treturn res / A / 3;",
            "}"
        ],
        "description": "Returns the center of mass for a polygon.",
        "prefix": [
            "hack_PolygonCenter"
        ]
    },
    "PolygonCut.h": {
        "body": [
            "typedef Point<double> P;",
            "vector<P> polygonCut(const vector<P>& poly, P s, P e) {",
            "\tvector<P> res;",
            "\trep(i, 0, sz(poly)) {",
            "\t\tP cur = poly[i], prev = i ? poly[i - 1] : poly.back();",
            "\t\tbool side = s.cross(e, cur) < 0;",
            "\t\tif (side != (s.cross(e, prev) < 0))",
            "\t\t\tres.push_back(lineInter(s, e, cur, prev).second);",
            "\t\tif (side) res.push_back(cur);",
            "\t}",
            "\treturn res;",
            "}"
        ],
        "description": "\\\\\n\\begin{minipage}{75mm}\nReturns a vector with the vertices of a polygon with everything to the left of the line going from s to e cut away.\n\\end{minipage}\n\\begin{minipage}{15mm}\n\\vspace{-6mm}\n\\includegraphics[width=\\textwidth]{content/geometry/PolygonCut}\n\\vspace{-6mm}\n\\end{minipage}",
        "prefix": [
            "hack_PolygonCut"
        ]
    },
    "PolygonUnion.h": {
        "body": [
            "typedef Point<double> P;",
            "double rat(P a, P b) {",
            "\treturn sgn(b.x) ? a.x / b.x : a.y / b.y;",
            "}",
            "double polyUnion(vector<vector<P>>& poly) {",
            "\tdouble ret = 0;",
            "\trep(i, 0, sz(poly)) rep(v, 0, sz(poly[i])) {",
            "\t\tP A = poly[i][v], B = poly[i][(v + 1) % sz(poly[i])];",
            "\t\tvector<pair<double, int>> segs = {{0, 0}, {1, 0}};",
            "\t\trep(j, 0, sz(poly)) if (i != j) {",
            "\t\t\trep(u, 0, sz(poly[j])) {",
            "\t\t\t\tP C = poly[j][u], D = poly[j][(u + 1) % sz(poly[j])];",
            "\t\t\t\tint sc = sideOf(A, B, C), sd = sideOf(A, B, D);",
            "\t\t\t\tif (sc != sd) {",
            "\t\t\t\t\tdouble sa = C.cross(D, A), sb = C.cross(D, B);",
            "\t\t\t\t\tif (min(sc, sd) < 0)",
            "\t\t\t\t\t\tsegs.emplace_back(sa / (sa - sb), sgn(sc - sd));",
            "\t\t\t\t} else if (",
            "\t\t\t\t\t!sc && !sd && j < i && sgn((B - A).dot(D - C)) > 0) {",
            "\t\t\t\t\tsegs.emplace_back(rat(C - A, B - A), 1);",
            "\t\t\t\t\tsegs.emplace_back(rat(D - A, B - A), -1);",
            "\t\t\t\t}",
            "\t\t\t}",
            "\t\t}",
            "\t\tsort(all(segs));",
            "\t\tfor (auto& s : segs) s.first = min(max(s.first, 0.0), 1.0);",
            "\t\tdouble sum = 0;",
            "\t\tint cnt = segs[0].second;",
            "\t\trep(j, 1, sz(segs)) {",
            "\t\t\tif (!cnt) sum += segs[j].first - segs[j - 1].first;",
            "\t\t\tcnt += segs[j].second;",
            "\t\t}",
            "\t\tret += A.cross(B) * sum;",
            "\t}",
            "\treturn ret / 2;",
            "}"
        ],
        "description": "Calculates the area of the union of $n$ polygons (not necessarily\nconvex). The points within each polygon must be given in CCW order.\n(Epsilon checks may optionally be added to sideOf/sgn, but shouldn't be needed.)",
        "prefix": [
            "hack_PolygonUnion"
        ]
    },
    "PolyhedronVolume.h": {
        "body": [
            "template<class V, class L>",
            "double signedPolyVolume(const V& p, const L& trilist) {",
            "\tdouble v = 0;",
            "\tfor (auto i : trilist) v += p[i.a].cross(p[i.b]).dot(p[i.c]);",
            "\treturn v / 6;",
            "}"
        ],
        "description": "Magic formula for the volume of a polyhedron. Faces should point outwards.",
        "prefix": [
            "hack_PolyhedronVolume"
        ]
    },
    "PrimeSieve.h": {
        "body": [
            "const int MAX_PR = 5'000'000;",
            "bitset<MAX_PR> isprime;",
            "vector<int> primeSieve(int lim) {",
            "\tisprime.set();",
            "\tisprime[0] = isprime[1] = 0;",
            "\tfor (int i = 4; i < lim; i += 2) isprime[i] = 0;",
            "\tfor (int i = 3; i * i < lim; i += 2)",
            "\t\tif (isprime[i])",
            "\t\t\tfor (int j = i * i; j < lim; j += i * 2) isprime[j] = 0;",
            "\tvector<int> pr;",
            "\tfor (int i = 2; i < lim; i++)",
            "\t\tif (isprime[i]) pr.push_back(i);",
            "\treturn pr;",
            "}"
        ],
        "description": "Prime sieve for generating all primes up\nto a certain limit. isprime$[i]$ is true iff $i$ is a prime.",
        "prefix": [
            "hack_PrimeSieve"
        ]
    },
    "PrimeSieveFast.h": {
        "body": [
            "const int LIM = 1e8;",
            "bitset<LIM> isPrime;",
            "vector<int> primeSieve() {",
            "\tconst int S = round(sqrt(LIM)), R = LIM / 2;",
            "\tvector<int> pr = {2}, sieve(S + 1);",
            "\tpr.reserve(int(LIM / log(LIM) * 1.1));",
            "\tvector<pair<int, int>> cp;",
            "\tfor (int i = 3; i <= S; i += 2)",
            "\t\tif (!sieve[i]) {",
            "\t\t\tcp.push_back({i, i * i / 2});",
            "\t\t\tfor (int j = i * i; j <= S; j += 2 * i) sieve[j] = 1;",
            "\t\t}",
            "\tfor (int L = 1; L <= R; L += S) {",
            "\t\tarray<bool, S> block{};",
            "\t\tfor (auto& [p, idx] : cp)",
            "\t\t\tfor (int i = idx; i < S + L; idx = (i += p))",
            "\t\t\t\tblock[i - L] = 1;",
            "\t\tfor (int i = 0; i < min(S, R - L); i++)",
            "\t\t\tif (!block[i]) pr.push_back((L + i) * 2 + 1);",
            "\t}",
            "\tfor (int i : pr) isPrime[i] = 1;",
            "\treturn pr;",
            "}"
        ],
        "description": "Prime sieve for generating all primes smaller\nthan LIM.\n",
        "prefix": [
            "hack_PrimeSieveFast"
        ]
    },
    "PushRelabel.h": {
        "body": [
            "struct PushRelabel {",
            "\tstruct Edge {",
            "\t\tint dest, back;",
            "\t\tll f, c;",
            "\t};",
            "\tvector<vector<Edge>> g;",
            "\tvector<ll> ec;",
            "\tvector<Edge*> cur;",
            "\tvector<vi> hs;",
            "\tvi H;",
            "\tPushRelabel(int n): g(n), ec(n), cur(n), hs(2 * n), H(n) {}",
            "\tvoid addEdge(int s, int t, ll cap, ll rcap = 0) {",
            "\t\tif (s == t) return;",
            "\t\tg[s].push_back({t, sz(g[t]), 0, cap});",
            "\t\tg[t].push_back({s, sz(g[s]) - 1, 0, rcap});",
            "\t}",
            "\tvoid addFlow(Edge& e, ll f) {",
            "\t\tEdge& back = g[e.dest][e.back];",
            "\t\tif (!ec[e.dest] && f) hs[H[e.dest]].push_back(e.dest);",
            "\t\te.f += f;",
            "\t\te.c -= f;",
            "\t\tec[e.dest] += f;",
            "\t\tback.f -= f;",
            "\t\tback.c += f;",
            "\t\tec[back.dest] -= f;",
            "\t}",
            "\tll calc(int s, int t) {",
            "\t\tint v = sz(g);",
            "\t\tH[s] = v;",
            "\t\tec[t] = 1;",
            "\t\tvi co(2 * v);",
            "\t\tco[0] = v - 1;",
            "\t\trep(i, 0, v) cur[i] = g[i].data();",
            "\t\tfor (Edge& e : g[s]) addFlow(e, e.c);",
            "\t\tfor (int hi = 0;;) {",
            "\t\t\twhile (hs[hi].empty())",
            "\t\t\t\tif (!hi--) return -ec[s];",
            "\t\t\tint u = hs[hi].back();",
            "\t\t\ths[hi].pop_back();",
            "\t\t\twhile (ec[u] > 0) // discharge u",
            "\t\t\t\tif (cur[u] == g[u].data() + sz(g[u])) {",
            "\t\t\t\t\tH[u] = 1e9;",
            "\t\t\t\t\tfor (Edge& e : g[u])",
            "\t\t\t\t\t\tif (e.c && H[u] > H[e.dest] + 1)",
            "\t\t\t\t\t\t\tH[u] = H[e.dest] + 1, cur[u] = &e;",
            "\t\t\t\t\tif (++co[H[u]], !--co[hi] && hi < v)",
            "\t\t\t\t\t\trep(i, 0, v) if (hi < H[i] && H[i] < v)-- co[H[i]],",
            "\t\t\t\t\t\t\tH[i] = v + 1;",
            "\t\t\t\t\thi = H[u];",
            "\t\t\t\t} else if (cur[u]->c && H[u] == H[cur[u]->dest] + 1)",
            "\t\t\t\t\taddFlow(*cur[u], min(ec[u], cur[u]->c));",
            "\t\t\t\telse ++cur[u];",
            "\t\t}",
            "\t}",
            "\tbool leftOfMinCut(int a) { return H[a] >= sz(g); }",
            "};"
        ],
        "description": "Push-relabel using the highest label selection rule and the gap heuristic. Quite fast in practice.\nTo obtain the actual flow, look at positive values only.",
        "prefix": [
            "hack_PushRelabel"
        ]
    },
    "RMQ.h": {
        "body": [
            "template<class T, class C = less<T>> struct RMQ {",
            "\tvector<vector<T>> t;",
            "\tC cmp;",
            "\tRMQ(vector<T>& a, C cmp = C{}):",
            "\t\tt(__lg(sz(a)) + 1, a), cmp(cmp) {",
            "\t\tfor (int k = 1, len = 1; k < sz(t); k++, len <<= 1)",
            "\t\t\tfor (int i = 0; i + 2 * len - 1 < sz(a); i++)",
            "\t\t\t\tt[k][i] = min(t[k - 1][i], t[k - 1][i + len], cmp);",
            "\t}",
            "\tT query(int a, int b) { // inclusive-exclusive [a, b)",
            "\t\tint k = __lg(b - a), len = 1 << k;",
            "\t\treturn min(t[k][a], t[k][b - len], cmp);",
            "\t}",
            "};"
        ],
        "description": "Constant time subarray min/max queries for a\nfixed array. Queries are inclusive-exclusive.",
        "prefix": [
            "hack_RMQ"
        ]
    },
    "RadixSum.h": {
        "body": [
            "#define all(x) x.begin(), x.end()",
            "#define rep(a, b, c) for (int a = b; a < c; a++)",
            "#define sz(x) (int)x.size()",
            "using namespace std;",
            "using ll = long long int;",
            "using vi = vector<int>;",
            "using pii = pair<int, int>;",
            "using ull = unsigned long long;",
            "const int N = ll(1e5);",
            "const int L = 5;",
            "const ull INV =",
            "\t6723469279985657373ULL; // inverse of 5^5 mod 2^64",
            "const ull MOD = 1LL << 58;",
            "// if a is a root of p(x) = x^4 - x^3 + x^2 - x + 1,",
            "// then a is a primitive 10th root of unity (a^10 = 1, and no smaller power works)",
            "struct Poly {",
            "\tarray<ull, L> a = {};",
            "\tPoly() {}",
            "\tPoly(int i, ull v = 1) { a[i] = v; }",
            "\tPoly operator+(const Poly& o) const {",
            "\t\tPoly ret;",
            "\t\tfor (int i = 0; i < L; i++) ret.a[i] = a[i] + o.a[i];",
            "\t\treturn ret;",
            "\t}",
            "\tPoly operator*(const Poly& o) const {",
            "\t\tarray<ull, 2 * L> temp = {};",
            "\t\tfor (int i = 0; i < L; i++)",
            "\t\t\tfor (int j = 0; j < L; j++) temp[i + j] += a[i] * o.a[j];",
            "\t\t// mod by x^4 - x^3 + x^2 - x + 1",
            "\t\tfor (int i = 2 * L - 1; i >= 4; i--) {",
            "\t\t\tll v = temp[i];",
            "\t\t\ttemp[i - 0] -= v;",
            "\t\t\ttemp[i - 1] += v;",
            "\t\t\ttemp[i - 2] -= v;",
            "\t\t\ttemp[i - 3] += v;",
            "\t\t\ttemp[i - 4] -= v;",
            "\t\t}",
            "\t\tPoly ret;",
            "\t\tfor (int i = 0; i < L; i++) ret.a[i] = temp[i];",
            "\t\treturn ret;",
            "\t}",
            "\tfriend ostream& operator<<(ostream& os, const Poly& p) {",
            "\t\tfor (int i = L - 1; i >= 0; i--)",
            "\t\t\tif (p.a[i]) os << p.a[i] << \" \";",
            "\t\treturn os;",
            "\t}",
            "};",
            "vector<Poly> pws;",
            "vector<Poly> transform(const vector<Poly>& a, bool inv) {",
            "\tint n = a.size();",
            "\tint nb = n / 10;",
            "\tif (n == 1) return a;",
            "\tvector<Poly> c(n);",
            "\tvector<vector<Poly>> b(10, vector<Poly>(nb));",
            "\tfor (int i = 0; i < n; i++) b[i / nb][i % nb] = a[i];",
            "\tfor (int i = 0; i < 10; i++) b[i] = transform(b[i], inv);",
            "\tint shift = 0;",
            "\tfor (int i = 0; i < 10; i++) {",
            "\t\tfor (int j = 0; j < 10; j++) {",
            "\t\t\tint pw = (i * j) % 10;",
            "\t\t\tif (inv) pw = (10 - pw) % 10;",
            "\t\t\tPoly root = Poly(pw % 5, pw / 5 ? -1 : 1);",
            "\t\t\tfor (int k = 0; k < nb; k++)",
            "\t\t\t\tc[shift + k] = c[shift + k] + b[j][k] * root;",
            "\t\t}",
            "\t\tshift += nb;",
            "\t}",
            "\treturn c;",
            "}",
            "Poly binpow(Poly a, int n) {",
            "\tPoly ret(0, 1);",
            "\tfor (; n; n /= 2, a = a * a)",
            "\t\tif (n & 1) ret = a * ret;",
            "\treturn ret;",
            "}",
            "void solve() {",
            "\tvector<Poly> f(N);",
            "\tint n;",
            "\tcin >> n;",
            "\tfor (int i = 0; i < n; i++) {",
            "\t\tint x;",
            "\t\tcin >> x;",
            "\t\tf[x] = f[x] + Poly(0, 1);",
            "\t}",
            "\tf = transform(f, false);",
            "\tfor (int i = 0; i < N; i++) f[i] = binpow(f[i], n);",
            "\tf = transform(f, true);",
            "\tfor (int i = 0; i < n; i++) {",
            "\t\tull ans = f[i].a[0];",
            "\t\t// \"divide\" by n",
            "\t\tans *= INV;",
            "\t\tans >>= 5;",
            "\t\tans %= 1ULL << 58;",
            "\t\tcout << ans << '\\n';",
            "\t}",
            "}",
            "int main() {",
            "\tcin.tie(0)->sync_with_stdio(0);",
            "\tcin.exceptions(cin.failbit);",
            "\t// int t; cin >> t; while (t--)",
            "\tsolve();",
            "\treturn 0;",
            "}"
        ],
        "prefix": [
            "hack_RadixSum"
        ]
    },
    "SCCKosaraju.h": {
        "body": [
            "namespace SCCKosaraju {",
            "vector<vector<int>> adj, radj;",
            "vector<int> todo, comp;",
            "vector<bool> vis;",
            "void dfs1(int x) {",
            "\tvis[x] = 1;",
            "\tfor (int y : adj[x])",
            "\t\tif (!vis[y]) dfs1(y);",
            "\ttodo.push_back(x);",
            "}",
            "void dfs2(int x, int i) {",
            "\tcomp[x] = i;",
            "\tfor (int y : radj[x])",
            "\t\tif (comp[y] == -1) dfs2(y, i);",
            "}",
            "vector<int> scc(vector<vector<int>>& _adj) {",
            "\tadj = _adj;",
            "\tint time = 0, n = adj.size();",
            "\tcomp.resize(n, -1), radj.resize(n), vis.resize(n);",
            "\tfor (int x = 0; x < n; x++)",
            "\t\tfor (int y : adj[x]) radj[y].push_back(x);",
            "\tfor (int x = 0; x < n; x++)",
            "\t\tif (!vis[x]) dfs1(x);",
            "\treverse(todo.begin(), todo.end());",
            "\tfor (int x : todo)",
            "\t\tif (comp[x] == -1) dfs2(x, time++);",
            "\treturn comp;",
            "}",
            "}; // namespace SCCKosaraju"
        ],
        "description": "Finds strongly connected components of a\ndirected graph. Visits/indexes SCCs in\ntopological order.",
        "prefix": [
            "hack_SCCKosaraju"
        ]
    },
    "SCCTarjan.h": {
        "body": [
            "namespace SCCTarjan {",
            "vector<int> val, comp, z, cont;",
            "int Time, ncomps;",
            "template<class G, class F> int dfs(int j, G& g, F& f) {",
            "\tint low = val[j] = ++Time, x;",
            "\tz.push_back(j);",
            "\tfor (auto e : g[j])",
            "\t\tif (comp[e] < 0) low = min(low, val[e] ?: dfs(e, g, f));",
            "\tif (low == val[j]) {",
            "\t\tdo {",
            "\t\t\tx = z.back();",
            "\t\t\tz.pop_back();",
            "\t\t\tcomp[x] = ncomps;",
            "\t\t\tcont.push_back(x);",
            "\t\t} while (x != j);",
            "\t\tf(cont);",
            "\t\tcont.clear();",
            "\t\tncomps++;",
            "\t}",
            "\treturn val[j] = low;",
            "}",
            "template<class G, class F> vector<int> scc(G& g, F f) {",
            "\tint n = g.size();",
            "\tval.assign(n, 0);",
            "\tcomp.assign(n, -1);",
            "\tTime = ncomps = 0;",
            "\tfor (int i = 0; i < n; i++)",
            "\t\tif (comp[i] < 0) dfs(i, g, f);",
            "\treturn comp;",
            "}",
            "template<class G> // convenience function w/o lambda",
            "vector<int> scc(G& g) {",
            "\treturn scc(g, [](auto& v) {});",
            "}",
            "} // namespace SCCTarjan"
        ],
        "description": "Finds strongly connected components of a\ndirected graph. Visits/indexes SCCs in reverse topological\norder.",
        "prefix": [
            "hack_SCCTarjan"
        ]
    },
    "SIMD.h": {
        "body": [
            "#pragma GCC target(\"avx2\") // or sse4.1",
            "#include \"immintrin.h\"",
            "typedef __m256i mi;",
            "#define L(x) _mm256_loadu_si256((mi*)&(x))",
            "// High-level/specific methods:",
            "// load(u)?_si256, store(u)?_si256, setzero_si256, _mm_malloc",
            "// blendv_(epi8|ps|pd) (z?y:x), movemask_epi8 (hibits of bytes)",
            "// i32gather_epi32(addr, x, 4): map addr[] over 32-b parts of x",
            "// sad_epu8: sum of absolute differences of u8, outputs 4xi64",
            "// maddubs_epi16: dot product of unsigned i7's, outputs 16xi15",
            "// madd_epi16: dot product of signed i16's, outputs 8xi32",
            "// extractf128_si256(, i) (256->128), cvtsi128_si32 (128->lo32)",
            "// permute2f128_si256(x,x,1) swaps 128-bit lanes",
            "// shuffle_epi32(x, 3*64+2*16+1*4+0) == x for each lane",
            "// shuffle_epi8(x, y) takes a vector instead of an imm",
            "// Methods that work with most data types (append e.g. _epi32):",
            "// set1, blend (i8?x:y), add, adds (sat.), mullo, sub, and/or,",
            "// andnot, abs, min, max, sign(1,x), cmp(gt|eq), unpack(lo|hi)",
            "int sumi32(mi m) {",
            "\tunion {",
            "\t\tint v[8];",
            "\t\tmi m;",
            "\t} u;",
            "\tu.m = m;",
            "\tint ret = 0;",
            "\trep(i, 0, 8) ret += u.v[i];",
            "\treturn ret;",
            "}",
            "mi zero() { return _mm256_setzero_si256(); }",
            "mi one() { return _mm256_set1_epi32(-1); }",
            "bool all_zero(mi m) { return _mm256_testz_si256(m, m); }",
            "bool all_one(mi m) { return _mm256_testc_si256(m, one()); }",
            "ll example_filteredDotProduct(int n, short* a, short* b) {",
            "\tint i = 0;",
            "\tll r = 0;",
            "\tmi zero = _mm256_setzero_si256(), acc = zero;",
            "\twhile (i + 16 <= n) {",
            "\t\tmi va = L(a[i]), vb = L(b[i]);",
            "\t\ti += 16;",
            "\t\tva = _mm256_and_si256(_mm256_cmpgt_epi16(vb, va), va);",
            "\t\tmi vp = _mm256_madd_epi16(va, vb);",
            "\t\tacc = _mm256_add_epi64(_mm256_unpacklo_epi32(vp, zero),",
            "\t\t\t_mm256_add_epi64(acc, _mm256_unpackhi_epi32(vp, zero)));",
            "\t}",
            "\tunion {",
            "\t\tll v[4];",
            "\t\tmi m;",
            "\t} u;",
            "\tu.m = acc;",
            "\trep(i, 0, 4) r += u.v[i];",
            "\tfor (; i < n; ++i)",
            "\t\tif (a[i] < b[i]) r += a[i] * b[i]; // <- equiv",
            "\treturn r;",
            "}"
        ],
        "description": "Cheat sheet of SSE/AVX intrinsics, for doing arithmetic on several numbers at once.\nCan provide a constant factor improvement of about 4, orthogonal to loop unrolling.\nOperations follow the pattern \\texttt{\"\\_mm(256)?\\_name\\_(si(128|256)|epi(8|16|32|64)|pd|ps)\"}. Not all are described here;\ngrep for \\texttt{\\_mm\\_} in \\texttt{/usr/lib/gcc/{*}/4.9/include/} for more.\nIf AVX is unsupported, try 128-bit operations, \"emmintrin.h\" and \\#define \\texttt{\\_\\_SSE\\_\\_} and \\texttt{\\_\\_MMX\\_\\_} before including it.\nFor aligned memory use \\texttt{\\_mm\\_malloc(size, 32)} or \\texttt{int buf[N] alignas(32)}, but prefer loadu/storeu.",
        "prefix": [
            "hack_SIMD"
        ]
    },
    "SebaDinic.h": {
        "body": [
            "// disable scaling when max flow/capacity is small, or",
            "// sometimes on random data",
            "template<bool SCALING = true> struct Dinic {",
            "\tstruct Edge {",
            "\t\tint v, dual;",
            "\t\tll cap, res;",
            "\t\tconstexpr ll flow() { return max(cap - res, 0LL); }",
            "\t};",
            "\tint n, s, t;",
            "\tvi lvl, q, ptr;",
            "\tvector<vector<Edge>> adj;",
            "\tvector<pii> edges;",
            "\tDinic(int n): n(n + 2), s(n++), t(n++), q(n), adj(n) {}",
            "\tint add(int u, int v, ll cap, ll flow = 0) {",
            "\t\tadj[u].push_back({v, sz(adj[v]), cap, cap - flow});",
            "\t\tadj[v].push_back({u, sz(adj[u]) - 1, 0, 0});",
            "\t\tedges.emplace_back(u, adj[u].size() - 1);",
            "\t\treturn edges.size() - 1; // this Edge's ID",
            "\t}",
            "\tll dfs(int u, ll in) {",
            "\t\tif (u == t || !in) return in;",
            "\t\tll flow = 0;",
            "\t\tfor (int& i = ptr[u]; i < sz(adj[u]); i++) {",
            "\t\t\tauto& e = adj[u][i];",
            "\t\t\tif (e.res && lvl[e.v] == lvl[u] - 1)",
            "\t\t\t\tif (ll out = dfs(e.v, min(in, e.res))) {",
            "\t\t\t\t\tflow += out, in -= out, e.res -= out;",
            "\t\t\t\t\tadj[e.v][e.dual].res += out;",
            "\t\t\t\t\tif (!in) return flow;",
            "\t\t\t\t}",
            "\t\t}",
            "\t\treturn flow;",
            "\t}",
            "\tll flow() {",
            "\t\tll flow = 0;",
            "\t\tq[0] = t;",
            "\t\tfor (int B = SCALING * 30; B >= 0; B--) do {",
            "\t\t\t\tlvl = ptr = vi(n);",
            "\t\t\t\tint qi = 0, qe = lvl[t] = 1;",
            "\t\t\t\twhile (qi < qe && !lvl[s]) {",
            "\t\t\t\t\tint u = q[qi++];",
            "\t\t\t\t\tfor (auto& e : adj[u])",
            "\t\t\t\t\t\tif (!lvl[e.v] && adj[e.v][e.dual].res >> B)",
            "\t\t\t\t\t\t\tq[qe++] = e.v, lvl[e.v] = lvl[u] + 1;",
            "\t\t\t\t}",
            "\t\t\t\tif (lvl[s]) flow += dfs(s, LLONG_MAX);",
            "\t\t\t} while (lvl[s]);",
            "\t\treturn flow;",
            "\t}",
            "\tEdge& get(int id) { // get Edge object from its ID",
            "\t\treturn adj[edges[id].first][edges[id].second];",
            "\t}",
            "\tvoid clear() {",
            "\t\tfor (auto& it : adj)",
            "\t\t\tfor (auto& e : it) e.res = e.cap;",
            "\t}",
            "\tbool leftOfMinCut(int u) { return lvl[u] == 0; }",
            "\t// d is a list of vertex demands, d[u] = flow in - flow out",
            "\t// negative if u is a source, positive if u is a sink",
            "\tbool circulation(vector<ll> d = {}) {",
            "\t\td.resize(n);",
            "\t\tvector<int> circEdges;",
            "\t\tDinic g(n);",
            "\t\tfor (int u = 0; u < n; u++)",
            "\t\t\tfor (auto& e : adj[u]) {",
            "\t\t\t\td[u] += e.flow(), d[e.v] -= e.flow();",
            "\t\t\t\tif (e.res) circEdges.push_back(g.add(u, e.v, e.res));",
            "\t\t\t}",
            "\t\tint tylerEdge = g.add(t, s, LLONG_MAX, 0);",
            "\t\tll flow = 0;",
            "\t\tfor (int u = 0; u < n; u++)",
            "\t\t\tif (d[u] < 0) g.add(g.s, u, -d[u]);",
            "\t\t\telse if (d[u] > 0) g.add(u, g.t, d[u]), flow += d[u];",
            "\t\tif (flow != g.flow()) return false;",
            "\t\tint i = 0; // reconstruct the flow into this graph",
            "\t\tfor (int u = 0; u < n; u++)",
            "\t\t\tfor (auto& e : adj[u])",
            "\t\t\t\tif (e.res) e.res -= g.get(circEdges[i++]).flow();",
            "\t\treturn true;",
            "\t}",
            "};"
        ],
        "description": "Max flow algorithm. Can find a valid\ncirculation given vertex and/or edge demands. Time:\n$O(VE\\log{U})$",
        "prefix": [
            "hack_SebaDinic"
        ]
    },
    "SegTreeWalk.h": {
        "body": [
            "// hash = 8f9536",
            "template<class G> int max_right(int l, G g) { // bool g(T);",
            "\tassert(g(e()));",
            "\tif (l == N) return N;",
            "\tl += S;",
            "\tfor (int i = log; i >= 1; i--) push(l >> i);",
            "\tT sm = e();",
            "\tdo {",
            "\t\twhile (l % 2 == 0) l >>= 1;",
            "\t\tif (!g(op(sm, d[l]))) {",
            "\t\t\twhile (l < S) {",
            "\t\t\t\tpush(l), l *= 2;",
            "\t\t\t\tif (g(op(sm, d[l]))) sm = op(sm, d[l++]);",
            "\t\t\t}",
            "\t\t\treturn l - S;",
            "\t\t}",
            "\t\tsm = op(sm, d[l++]);",
            "\t} while ((l & -l) != l);",
            "\treturn N;",
            "}",
            "template<class G> int min_left(int r, G g) {",
            "\tassert(g(e()));",
            "\tif (r == 0) return 0;",
            "\tr += S;",
            "\tfor (int i = log; i >= 1; i--) push((r - 1) >> i);",
            "\tT sm = e();",
            "\tdo {",
            "\t\tr--;",
            "\t\twhile (r > 1 && (r % 2)) r >>= 1;",
            "\t\tif (!g(op(d[r], sm))) {",
            "\t\t\twhile (r < S) {",
            "\t\t\t\tpush(r), r *= 2;",
            "\t\t\t\tif (g(op(d[++r], sm))) sm = op(d[r--], sm);",
            "\t\t\t}",
            "\t\t\treturn r + 1 - S;",
            "\t\t}",
            "\t\tsm = op(d[r], sm);",
            "\t} while ((r & -r) != r);",
            "\treturn 0;",
            "}"
        ],
        "prefix": [
            "hack_SegTreeWalk"
        ]
    },
    "SegmentDistance.h": {
        "body": [
            "typedef Point<double> P;",
            "double segDist(P& s, P& e, P& p) {",
            "\tif (s == e) return (p - s).dist();",
            "\tauto d = (e - s).dist2(),",
            "\t\t\t t = min(d, max(.0, (p - s).dot(e - s)));",
            "\treturn ((p - s) * d - (e - s) * t).dist() / d;",
            "}"
        ],
        "description": "\\\\\n\\begin{minipage}{75mm}\nReturns the shortest distance between point p and the line segment from point s to e.\n\\end{minipage}\n\\begin{minipage}{15mm}\n\\vspace{-10mm}\n\\includegraphics[width=\\textwidth]{content/geometry/SegmentDistance}\n\\end{minipage}",
        "prefix": [
            "hack_SegmentDistance"
        ]
    },
    "SegmentIntersection.h": {
        "body": [
            "template<class P> vector<P> segInter(P a, P b, P c, P d) {",
            "\tauto oa = c.cross(d, a), ob = c.cross(d, b),",
            "\t\t\t oc = a.cross(b, c), od = a.cross(b, d);",
            "\t// Checks if intersection is single non-endpoint point.",
            "\tif (sgn(oa) * sgn(ob) < 0 && sgn(oc) * sgn(od) < 0)",
            "\t\treturn {(a * ob - b * oa) / (ob - oa)};",
            "\tset<P> s;",
            "\tif (onSegment(c, d, a)) s.insert(a);",
            "\tif (onSegment(c, d, b)) s.insert(b);",
            "\tif (onSegment(a, b, c)) s.insert(c);",
            "\tif (onSegment(a, b, d)) s.insert(d);",
            "\treturn {all(s)};",
            "}"
        ],
        "description": "\\\\\n\\begin{minipage}{75mm}\nIf a unique intersection point between the line segments going from s1 to e1 and from s2 to e2 exists then it is returned.\nIf no intersection point exists an empty vector is returned. If infinitely many exist a vector with 2 elements is returned, containing the endpoints of the common line segment.\nThe wrong position will be returned if P is Point<ll> and the intersection point does not have integer coordinates.\nProducts of three coordinates are used in intermediate steps so watch out for overflow if using int or long long.\n\\end{minipage}\n\\begin{minipage}{15mm}\n\\includegraphics[width=\\textwidth]{content/geometry/SegmentIntersection}\n\\end{minipage}",
        "prefix": [
            "hack_SegmentIntersection"
        ]
    },
    "Simplex.h": {
        "body": [
            "typedef double T; // long double, Rational, double + mod<P>...",
            "typedef vector<T> vd;",
            "typedef vector<vd> vvd;",
            "const T eps = 1e-8, inf = 1 / .0;",
            "#define MP make_pair",
            "#define ltj(X) \\",
            "\tif (s == -1 || MP(X[j], N[j]) < MP(X[s], N[s])) s = j",
            "struct LPSolver {",
            "\tint m, n;",
            "\tvi N, B;",
            "\tvvd D;",
            "\tLPSolver(const vvd& A, const vd& b, const vd& c):",
            "\t\tm(sz(b)), n(sz(c)), N(n + 1), B(m), D(m + 2, vd(n + 2)) {",
            "\t\trep(i, 0, m) rep(j, 0, n) D[i][j] = A[i][j];",
            "\t\trep(i, 0, m) {",
            "\t\t\tB[i] = n + i;",
            "\t\t\tD[i][n] = -1;",
            "\t\t\tD[i][n + 1] = b[i];",
            "\t\t}",
            "\t\trep(j, 0, n) {",
            "\t\t\tN[j] = j;",
            "\t\t\tD[m][j] = -c[j];",
            "\t\t}",
            "\t\tN[n] = -1;",
            "\t\tD[m + 1][n] = 1;",
            "\t}",
            "\tvoid pivot(int r, int s) {",
            "\t\tT *a = D[r].data(), inv = 1 / a[s];",
            "\t\trep(i, 0, m + 2) if (i != r && abs(D[i][s]) > eps) {",
            "\t\t\tT *b = D[i].data(), inv2 = b[s] * inv;",
            "\t\t\trep(j, 0, n + 2) b[j] -= a[j] * inv2;",
            "\t\t\tb[s] = a[s] * inv2;",
            "\t\t}",
            "\t\trep(j, 0, n + 2) if (j != s) D[r][j] *= inv;",
            "\t\trep(i, 0, m + 2) if (i != r) D[i][s] *= -inv;",
            "\t\tD[r][s] = inv;",
            "\t\tswap(B[r], N[s]);",
            "\t}",
            "\tbool simplex(int phase) {",
            "\t\tint x = m + phase - 1;",
            "\t\tfor (;;) {",
            "\t\t\tint s = -1;",
            "\t\t\trep(j, 0, n + 1) if (N[j] != -phase) ltj(D[x]);",
            "\t\t\tif (D[x][s] >= -eps) return true;",
            "\t\t\tint r = -1;",
            "\t\t\trep(i, 0, m) {",
            "\t\t\t\tif (D[i][s] <= eps) continue;",
            "\t\t\t\tif (r == -1 ||",
            "\t\t\t\t\tMP(D[i][n + 1] / D[i][s], B[i]) <",
            "\t\t\t\t\t\tMP(D[r][n + 1] / D[r][s], B[r]))",
            "\t\t\t\t\tr = i;",
            "\t\t\t}",
            "\t\t\tif (r == -1) return false;",
            "\t\t\tpivot(r, s);",
            "\t\t}",
            "\t}",
            "\tT solve(vd& x) {",
            "\t\tint r = 0;",
            "\t\trep(i, 1, m) if (D[i][n + 1] < D[r][n + 1]) r = i;",
            "\t\tif (D[r][n + 1] < -eps) {",
            "\t\t\tpivot(r, n);",
            "\t\t\tif (!simplex(2) || D[m + 1][n + 1] < -eps) return -inf;",
            "\t\t\trep(i, 0, m) if (B[i] == -1) {",
            "\t\t\t\tint s = 0;",
            "\t\t\t\trep(j, 1, n + 1) ltj(D[i]);",
            "\t\t\t\tpivot(i, s);",
            "\t\t\t}",
            "\t\t}",
            "\t\tbool ok = simplex(1);",
            "\t\tx = vd(n);",
            "\t\trep(i, 0, m) if (B[i] < n) x[B[i]] = D[i][n + 1];",
            "\t\treturn ok ? D[m][n + 1] : inf;",
            "\t}",
            "};"
        ],
        "description": "Solves a general linear maximization problem: maximize $c^T x$ subject to $Ax \\le b$, $x \\ge 0$.\nReturns -inf if there is no solution, inf if there are arbitrarily good solutions, or the maximum value of $c^T x$ otherwise.\nThe input vector is set to an optimal $x$ (or in the unbounded case, an arbitrary solution fulfilling the constraints).\nNumerical stability is not guaranteed. For better performance, define variables such that $x = 0$ is viable.",
        "prefix": [
            "hack_Simplex"
        ]
    },
    "SolveLinear.h": {
        "body": [
            "typedef vector<double> vd;",
            "const double eps = 1e-12;",
            "int solveLinear(vector<vd>& A, vd& b, vd& x) {",
            "\tint n = sz(A), m = sz(x), rank = 0, br, bc;",
            "\tif (n) assert(sz(A[0]) == m);",
            "\tvi col(m);",
            "\tiota(all(col), 0);",
            "\trep(i, 0, n) {",
            "\t\tdouble v, bv = 0;",
            "\t\trep(r, i, n) rep(c, i, m) if ((v = fabs(A[r][c])) > bv)",
            "\t\t\tbr = r,",
            "\t\t\tbc = c, bv = v;",
            "\t\tif (bv <= eps) {",
            "\t\t\trep(j, i, n) if (fabs(b[j]) > eps) return -1;",
            "\t\t\tbreak;",
            "\t\t}",
            "\t\tswap(A[i], A[br]);",
            "\t\tswap(b[i], b[br]);",
            "\t\tswap(col[i], col[bc]);",
            "\t\trep(j, 0, n) swap(A[j][i], A[j][bc]);",
            "\t\tbv = 1 / A[i][i];",
            "\t\trep(j, i + 1, n) {",
            "\t\t\tdouble fac = A[j][i] * bv;",
            "\t\t\tb[j] -= fac * b[i];",
            "\t\t\trep(k, i + 1, m) A[j][k] -= fac * A[i][k];",
            "\t\t}",
            "\t\trank++;",
            "\t}",
            "\tx.assign(m, 0);",
            "\tfor (int i = rank; i--;) {",
            "\t\tb[i] /= A[i][i];",
            "\t\tx[col[i]] = b[i];",
            "\t\trep(j, 0, i) b[j] -= A[j][i] * b[i];",
            "\t}",
            "\treturn rank; // (multiple solutions if rank < m)",
            "}"
        ],
        "description": "Solves $A * x = b$. If there are multiple solutions, an arbitrary one is returned.\nReturns rank, or -1 if no solutions. Data in $A$ and $b$ is lost.",
        "prefix": [
            "hack_SolveLinear"
        ]
    },
    "SolveLinear2.h": {
        "body": [
            "rep(j, 0, n) if (j != i) // instead of rep(j,i+1,n)",
            "\t// ... then at the end:",
            "\tx.assign(m, undefined);",
            "rep(i, 0, rank) {",
            "\trep(j, rank, m) if (fabs(A[i][j]) > eps) goto fail;",
            "\tx[col[i]] = b[i] / A[i][i];",
            "fail:;",
            "}"
        ],
        "description": "To get all uniquely determined values of $x$ back from SolveLinear, make the following changes:",
        "prefix": [
            "hack_SolveLinear2"
        ]
    },
    "Splay.h": {
        "body": [
            "struct node {",
            "\tnode *ch[2] = {0}, *p = 0;",
            "\tint cnt = 1, val;",
            "\tnode(int val, node* l = 0, node* r = 0):",
            "\t\tch{l, r}, val(val) {}",
            "};",
            "int cnt(node* x) { return x ? x->cnt : 0; }",
            "int dir(node* p, node* x) { return p && p->ch[0] != x; }",
            "void setLink(node* p, node* x, int d) {",
            "\tif (p) p->ch[d] = x;",
            "\tif (x) x->p = p;",
            "}",
            "node* update(node* x) {",
            "\tif (!x) return 0;",
            "\tx->cnt = 1 + cnt(x->ch[0]) + cnt(x->ch[1]);",
            "\tsetLink(x, x->ch[0], 0);",
            "\tsetLink(x, x->ch[1], 1);",
            "\treturn x;",
            "}",
            "void prop(node* x) {",
            "\tif (!x) return;",
            "\t// update(x); // needed if prop() can change subtree sizes",
            "}",
            "void rotate(node* x, int d) {",
            "\tif (!x || !x->ch[d]) return;",
            "\tnode *y = x->ch[d], *z = x->p;",
            "\tsetLink(x, y->ch[d ^ 1], d);",
            "\tsetLink(y, x, d ^ 1);",
            "\tsetLink(z, y, dir(z, x));",
            "\tupdate(x);",
            "\tupdate(y);",
            "}",
            "node* splay(node* x) {",
            "\twhile (x && x->p) {",
            "\t\tnode *y = x->p, *z = y->p;",
            "\t\t// prop(z), prop(y), prop(x); // needed for LCT",
            "\t\tint dy = dir(y, x), dz = dir(z, y);",
            "\t\tif (!z) rotate(y, dy);",
            "\t\telse if (dy == dz) rotate(z, dz), rotate(y, dy);",
            "\t\telse rotate(y, dy), rotate(z, dz);",
            "\t}",
            "\treturn x;",
            "}",
            "// the returned node becomes the new root, update the root",
            "// pointer!",
            "node* nodeAt(node* x, int pos) {",
            "\tif (!x) return 0;",
            "\twhile (prop(x), cnt(x->ch[0]) != pos)",
            "\t\tif (pos < cnt(x->ch[0])) x = x->ch[0];",
            "\t\telse pos -= cnt(x->ch[0]) + 1, x = x->ch[1];",
            "\treturn splay(x);",
            "}",
            "node* merge(node* l, node* r) {",
            "\tif (!l || !r) return l ?: r;",
            "\tl = nodeAt(l, cnt(l) - 1);",
            "\tsetLink(l, r, 1);",
            "\treturn update(l);",
            "}",
            "// first is everything < pos, second is >= pos",
            "pair<node*, node*> split(node* t, int pos) {",
            "\tif (pos <= 0 || !t) return {0, t};",
            "\tif (pos > cnt(t)) return {t, 0};",
            "\tnode *l = nodeAt(t, pos - 1), *r = l->ch[1];",
            "\tif (r) l->ch[1] = r->p = 0;",
            "\treturn {update(l), update(r)};",
            "}",
            "// insert a new node between pos-1 and pos",
            "node* insert(node* t, int pos, int val) {",
            "\tauto [l, r] = split(t, pos);",
            "\treturn update(new node(val, l, r));",
            "}",
            "// apply lambda to all nodes in an inorder traversal",
            "template<class F> void each(node* x, F f) {",
            "\tif (x) prop(x), each(x->ch[0], f), f(x), each(x->ch[1], f);",
            "}"
        ],
        "description": "An implicit balanced BST. You only need to\nchange \\texttt{update()} and \\texttt{prop()}. \\\\\nIf used for link-cut tree, code everything up to\n\\texttt{splay()}. Time: amortized $O(\\log n)$ for all\noperations",
        "prefix": [
            "hack_Splay"
        ]
    },
    "SplayTree.h": {
        "body": [
            "// https://codeforces.com/blog/entry/75885",
            "struct SplayTree {",
            "\tstruct Node {",
            "\t\tint ch[2] = {0, 0}, p = 0, cnt = 1;",
            "\t\tll self = 0, path = 0; // Path aggregates",
            "\t\tll sub = 0, vir = 0; // Subtree aggregates",
            "\t\tbool flip = 0; // Lazy tags",
            "\t};",
            "\tvector<Node> T;",
            "\tSplayTree(int n): T(n + 1) { T[0].cnt = 0; }",
            "\tvoid push(int x) {",
            "\t\tif (!x || !T[x].flip) return;",
            "\t\tint l = T[x].ch[0], r = T[x].ch[1];",
            "\t\tT[l].flip ^= 1, T[r].flip ^= 1;",
            "\t\tswap(T[x].ch[0], T[x].ch[1]);",
            "\t\tT[x].flip = 0;",
            "\t}",
            "\tvoid pull(int x) {",
            "\t\tint l = T[x].ch[0], r = T[x].ch[1];",
            "\t\tpush(l);",
            "\t\tpush(r);",
            "\t\tT[x].path = T[l].path + T[x].self + T[r].path;",
            "\t\tT[x].sub = T[x].vir + T[l].sub + T[r].sub + T[x].self;",
            "\t\tT[x].cnt = T[l].cnt + 1 + T[r].cnt;",
            "\t}",
            "\tvoid set(int x, int d, int y) {",
            "\t\tT[x].ch[d] = y;",
            "\t\tT[y].p = x;",
            "\t\tpull(x);",
            "\t}",
            "\tvoid splay(int x) {",
            "\t\tauto dir = [&](int x) {",
            "\t\t\tint p = T[x].p;",
            "\t\t\tif (!p) return -1;",
            "\t\t\treturn T[p].ch[0] == x ? 0 : T[p].ch[1] == x ? 1 : -1;",
            "\t\t};",
            "\t\tauto rotate = [&](int x) {",
            "\t\t\tint y = T[x].p, z = T[y].p, dx = dir(x), dy = dir(y);",
            "\t\t\tset(y, dx, T[x].ch[!dx]);",
            "\t\t\tset(x, !dx, y);",
            "\t\t\tif (~dy) set(z, dy, x);",
            "\t\t\tT[x].p = z;",
            "\t\t};",
            "\t\tfor (push(x); ~dir(x);) {",
            "\t\t\tint y = T[x].p, z = T[y].p;",
            "\t\t\tpush(z);",
            "\t\t\tpush(y);",
            "\t\t\tpush(x);",
            "\t\t\tint dx = dir(x), dy = dir(y);",
            "\t\t\tif (~dy) rotate(dx != dy ? x : y);",
            "\t\t\trotate(x);",
            "\t\t}",
            "\t}",
            "\t// TEST THIS STUFF",
            "\tint kth(int x, int k) {",
            "\t\tif (!x) return 0;",
            "\t\tk = min(max(k, 0), T[x].cnt - 1);",
            "\t\tfor (int l = T[x].ch[0]; T[l].cnt != k; l = T[x].cnt[0])",
            "\t\t\tif (T[l].cnt < k) x = l;",
            "\t\t\telse k -= T[l].cnt + 1, x = T[x].ch[1];",
            "\t\treturn splay(x), x;",
            "\t}",
            "\t// k = size of left subtree",
            "\tpair<int, int> split(int x, int k) {",
            "\t\tif (!x || k <= 0) return {0, x};",
            "\t\tif (k >= T[x].cnt) return {x, 0};",
            "\t\tint r = kth(x, k), l = T[r].ch[0];",
            "\t\tT[r].ch[0] = 0, T[l].p = 0;",
            "\t\treturn {l, r};",
            "\t}",
            "\tint merge(int l, int r) {",
            "\t\tif (!l || !r) return !l ? r : l;",
            "\t\tr = kth(r, 0), set(r, 0, l);",
            "\t\treturn r;",
            "\t}",
            "};"
        ],
        "prefix": [
            "hack_SplayTree"
        ]
    },
    "SubMatrix.h": {
        "body": [
            "template<class T> struct SubMatrix {",
            "\tvector<vector<T>> p;",
            "\tSubMatrix(vector<vector<T>>& v) {",
            "\t\tint R = sz(v), C = sz(v[0]);",
            "\t\tp.assign(R + 1, vector<T>(C + 1));",
            "\t\trep(r, 0, R) rep(c, 0, C) p[r + 1][c + 1] =",
            "\t\t\tv[r][c] + p[r][c + 1] + p[r + 1][c] - p[r][c];",
            "\t}",
            "\tT sum(int u, int l, int d, int r) {",
            "\t\treturn p[d][r] - p[d][l] - p[u][r] + p[u][l];",
            "\t}",
            "};"
        ],
        "description": "Calculate submatrix sums quickly, given upper-left and lower-right corners (half-open).",
        "prefix": [
            "hack_SubMatrix"
        ]
    },
    "SubmasksSupermasks.h": {
        "body": [
            "void submasks(int n) {",
            "\tfor (int mask = 0; mask < (1 << n); mask++)",
            "\t\tfor (int sub = mask; sub; sub = (sub - 1) & mask) {",
            "\t\t\t// do thing",
            "\t\t}",
            "}",
            "void supermasks(int n) {",
            "\tfor (int mask = 0; mask < (1 << n); mask++)",
            "\t\tfor (int sup = mask; sup < (1 << n);",
            "\t\t\t\t sup = (sup + 1) | mask) {",
            "\t\t\t// do thing",
            "\t\t}",
            "}"
        ],
        "prefix": [
            "hack_SubmasksSupermasks"
        ]
    },
    "SuffixArray.h": {
        "body": [
            "struct SuffixArray {",
            "\tvi sa, lcp, rank;",
            "\tSuffixArray(string& s, int lim = 256) { // basic_string<int>",
            "\t\tint n = sz(s) + 1, k = 0, a, b;",
            "\t\tvi x(all(s) + 1), y(n), ws(max(n, lim));",
            "\t\tsa = lcp = rank = y, iota(all(sa), 0);",
            "\t\tfor (int j = 0, p = 0; p < n; j = max(1, j * 2), lim = p) {",
            "\t\t\tp = j, iota(all(y), n - j);",
            "\t\t\trep(i, 0, n) if (sa[i] >= j) y[p++] = sa[i] - j;",
            "\t\t\tfill(all(ws), 0);",
            "\t\t\trep(i, 0, n) ws[x[i]]++;",
            "\t\t\trep(i, 1, lim) ws[i] += ws[i - 1];",
            "\t\t\tfor (int i = n; i--;) sa[--ws[x[y[i]]]] = y[i];",
            "\t\t\tswap(x, y), p = 1, x[sa[0]] = 0;",
            "\t\t\trep(i, 1, n)",
            "\t\t\t\ta = sa[i - 1],",
            "\t\t\t\tb = sa[i],",
            "\t\t\t\tx[b] =",
            "\t\t\t\t\t(y[a] == y[b] && y[a + j] == y[b + j]) ? p - 1 : p++;",
            "\t\t}",
            "\t\trep(i, 0, n) rank[sa[i]] = i;",
            "\t\tfor (int i = 0, j; i < n - 1; lcp[rank[i++]] = k)",
            "\t\t\tfor (k &&k--, j = sa[rank[i] - 1]; s[i + k] == s[j + k];",
            "\t\t\t\t\t k++)",
            "\t\t\t\t;",
            "\t}",
            "};"
        ],
        "description": "Builds suffix array for a string.\n\\texttt{sa[i]} is the starting index of the suffix which\nis $i$'th in the sorted suffix array.\nThe returned vector is of size $n+1$, and \\texttt{sa[0] = n}.\nThe \\texttt{lcp} array contains longest common prefixes for\nneighbouring strings in the suffix array:\n\\texttt{lcp[i] = lcp(sa[i], sa[i-1])}, \\texttt{lcp[0] = 0}.\nThe input string must not contain any zero bytes.",
        "prefix": [
            "hack_SuffixArray"
        ]
    },
    "SuffixTree.h": {
        "body": [
            "const int oo = 1e9;",
            "// Use to traverse tree",
            "struct State {",
            "\tint id, l, r;",
            "\tint getLen() { return r - l + 1; }",
            "};",
            "struct Node {",
            "\tint id;",
            "\tint suffLink;",
            "\tint l, r;",
            "\tint depth;",
            "\tmap<char, int> child;",
            "\tNode(int id, int l, int r): id(id), l(l), r(r) {}",
            "\tbool hasEdge(char c) { return child.find(c) != child.end(); }",
            "\tint getLen() { return r - l + 1; }",
            "};",
            "struct SuffixTree {",
            "\tState active;",
            "\tint root;",
            "\tvector<Node> nodes;",
            "\tstring st;",
            "\tSuffixTree(string inp): st(inp) {",
            "\t\t// append $ if need to know which nodes are suffixes",
            "\t\tnodes.emplace_back(0, -1, -1);",
            "\t\tnodes.emplace_back(1, 0, 0);",
            "\t\tnodes[1].suffLink = 0;",
            "\t\troot = 1;",
            "\t\tactive = State{root, 0, 0};",
            "\t\tfor (int i = 0; i < st.size(); i++) {",
            "\t\t\tnodes[0].child[st[i]] = 1;",
            "\t\t\tactive.r = i;",
            "\t\t\tactive = update(active);",
            "\t\t\tactive = canonize(active);",
            "\t\t}",
            "\t\tfor (int i = 0; i < nodes.size(); i++)",
            "\t\t\tnodes[i].r = min(nodes[i].r, (int)st.size() - 1);",
            "\t}",
            "\t// call canonize when following suffix links",
            "\tState canonize(State s) {",
            "\t\tif (s.r < s.l) return s;",
            "\t\tint curr = nodes[s.id].child[st[s.l]];",
            "\t\twhile (nodes[curr].getLen() <= s.getLen()) {",
            "\t\t\ts.l += nodes[curr].getLen();",
            "\t\t\ts.id = curr;",
            "\t\t\tif (s.l <= s.r) curr = nodes[s.id].child[st[s.l]];",
            "\t\t}",
            "\t\treturn s;",
            "\t}",
            "\tint newNode(int l, int r) {",
            "\t\tnodes.emplace_back(nodes.size(), l, r);",
            "\t\treturn nodes.size() - 1;",
            "\t}",
            "\tpair<bool, int> split(State s, char t) {",
            "\t\tif (s.l <= s.r) {",
            "\t\t\tint curr = nodes[s.id].child[st[s.l]];",
            "\t\t\tif (t == st[nodes[curr].l + s.getLen()])",
            "\t\t\t\treturn {true, s.id};",
            "\t\t\tnewNode(nodes[curr].l, nodes[curr].l + s.r - s.l);",
            "\t\t\tnodes[s.id].child[st[s.l]] = nodes.back().id;",
            "\t\t\tnodes.back().child[st[nodes[curr].l + s.getLen()]] =",
            "\t\t\t\tcurr;",
            "\t\t\tnodes[curr].l = nodes[curr].l + s.getLen();",
            "\t\t\treturn {false, nodes.back().id};",
            "\t\t} else {",
            "\t\t\tif (!nodes[s.id].child.count(t)) return {false, s.id};",
            "\t\t\telse return {true, s.id};",
            "\t\t}",
            "\t}",
            "\tState update(State s) {",
            "\t\tint oldr = root;",
            "\t\tauto [endPoint, r] =",
            "\t\t\tsplit(State{s.id, s.l, s.r - 1}, st[s.r]);",
            "\t\twhile (!endPoint) {",
            "\t\t\tnewNode(s.r, oo);",
            "\t\t\tnodes[r].child[st[s.r]] = nodes.back().id;",
            "\t\t\tif (oldr != root) nodes[oldr].suffLink = r;",
            "\t\t\toldr = r;",
            "\t\t\tState canon =",
            "\t\t\t\tcanonize(State{nodes[s.id].suffLink, s.l, s.r - 1});",
            "\t\t\ttie(s.id, s.l) = {canon.id, canon.l};",
            "\t\t\ttie(endPoint, r) =",
            "\t\t\t\tsplit(State{s.id, s.l, s.r - 1}, st[s.r]);",
            "\t\t}",
            "\t\tif (oldr != root) nodes[oldr].suffLink = s.id;",
            "\t\treturn s;",
            "\t}",
            "};"
        ],
        "prefix": [
            "hack_SuffixTree"
        ]
    },
    "SumOverSubsets.h": {
        "body": [
            "// in place sum over subsets (give desc.)",
            "// works with vector, array, and std::array",
            "template<class Arr> void sos(Arr& f, int n, bool inv = 0) {",
            "\tfor (int i = 0, b = 1; i < n; i++, b *= 2)",
            "\t\trep(mask, 0, 1 << n) if (mask & b) f[mask] +=",
            "\t\t\tinv ? -f[mask ^ b] : f[mask ^ b];",
            "}",
            "template<class T>",
            "vector<T> conv(const vector<T>& a, const vector<T>& b) {",
            "\tint n = __lg(sz(a)), len = 1 << n;",
            "\tvector<vector<T>> f(n + 1, vector<T>(len)), g = f, h = f;",
            "\trep(mask, 0, len) {",
            "\t\tint pc = __builtin_popcount(mask);",
            "\t\tf[pc][mask] = a[mask], g[pc][mask] = b[mask];",
            "\t}",
            "\trep(i, 0, n + 1) sos(f[i], n), sos(g[i], n);",
            "\trep(mask, 0, len) rep(i, 0, n + 1) rep(j, 0, i + 1)",
            "\t\th[i][mask] += f[j][mask] * g[i - j][mask];",
            "\trep(i, 0, n + 1) sos(h[i], n, 1);",
            "\tvector<T> c(len);",
            "\trep(mask, 0, len) c[mask] =",
            "\t\th[__builtin_popcount(mask)][mask];",
            "\treturn c;",
            "}"
        ],
        "prefix": [
            "hack_SumOverSubsets"
        ]
    },
    "TotientSum.h": {
        "body": [
            "using namespace std;",
            "#define all(x) begin(x), end(x)",
            "#define sz(x) int(x.size())",
            "#define rep(a, b, c) for (int a = (b); a < (c); a++)",
            "typedef long long ll;",
            "typedef vector<int> vi;",
            "const ll mod = 998244353;",
            "template<int MOD, int RT> struct mint {",
            "\tusing mr = const mint&;",
            "\tint v;",
            "\texplicit operator int() const {",
            "\t\treturn v;",
            "\t} // explicit -> don't silently convert to int",
            "\tmint(ll _v = 0) {",
            "\t\tv = int((-MOD < _v && _v < MOD) ? _v : _v % MOD);",
            "\t\tif (v < 0) v += MOD;",
            "\t}",
            "\tmint& operator+=(mr o) {",
            "\t\tif ((v += o.v) >= MOD) v -= MOD;",
            "\t\treturn *this;",
            "\t}",
            "\tmint& operator-=(mr o) {",
            "\t\tif ((v -= o.v) < 0) v += MOD;",
            "\t\treturn *this;",
            "\t}",
            "\tmint& operator*=(mr o) {",
            "\t\tv = int(ll(v) * o.v % MOD);",
            "\t\treturn *this;",
            "\t}",
            "\tmint& operator/=(mr o) { return (*this) *= inv(o); }",
            "\tfriend mint pow(mint a, ll p) {",
            "\t\tmint ans = 1;",
            "\t\tassert(p >= 0);",
            "\t\tfor (; p; p /= 2, a *= a)",
            "\t\t\tif (p & 1) ans *= a;",
            "\t\treturn ans;",
            "\t}",
            "\tfriend mint inv(mr a) {",
            "\t\tassert(a.v != 0);",
            "\t\treturn pow(a, MOD - 2);",
            "\t}",
            "\tfriend mint operator+(mint a, mr b) { return a += b; }",
            "\tfriend mint operator-(mint a, mr b) { return a -= b; }",
            "\tfriend mint operator*(mint a, mr b) { return a *= b; }",
            "\tfriend mint operator/(mint a, mr b) { return a /= b; }",
            "\tbool operator==(mr o) const { return v == o.v; }",
            "\tfriend bool operator!=(mr a, mr b) { return !(a == b); }",
            "\tfriend bool operator<(mr a, mr b) { return a.v < b.v; }",
            "\tmint operator-() const { return mint(-v); }",
            "\tmint& operator++() { return *this += 1; }",
            "\tmint& operator--() { return *this -= 1; }",
            "\tfriend istream& operator>>(istream& is, mint& a) {",
            "\t\treturn is >> a.v;",
            "\t}",
            "\tfriend ostream& operator<<(ostream& os, const mint& a) {",
            "\t\treturn os << a.v;",
            "\t}",
            "\tstatic constexpr mint rt() {",
            "\t\treturn RT;",
            "\t} // primitive root for FFT",
            "};",
            "using mi =",
            "\tmint<mod, 5>; // 5 is primitive root for both common mods",
            "const int LIM = 4641588;",
            "int primes[LIM], np = 0;",
            "bitset<LIM> notPrime;",
            "int ps[LIM], ks[LIM];",
            "mi phi[LIM];",
            "void sieve(int n) {",
            "\tphi[0] = 0, phi[1] = 1;",
            "\tfor (int i = 2; i < n; i++) {",
            "\t\tif (!notPrime[i]) { // Define f(p^k)",
            "\t\t\tprimes[np++] = i;",
            "\t\t\tps[i] = i, ks[i] = 1;",
            "\t\t\tphi[i] = i - 1; // EDIT HERE: f(p)",
            "\t\t\tfor (ll pk = i, x = 1ll * i * i; x < n;",
            "\t\t\t\t\t pk *= i, x *= i) {",
            "\t\t\t\tps[x] = x, ks[x] = ks[pk] + 1;",
            "\t\t\t\tphi[x] = phi[pk] * i; // EDIT HERE: f(p^k), k > 1",
            "\t\t\t}",
            "\t\t}",
            "\t\tfor (ll j = 0, p; j < np && (p = primes[j]) * i < n; j++) {",
            "\t\t\tll x = i * p;",
            "\t\t\tif (x >= n) break;",
            "\t\t\tnotPrime[x] = 1;",
            "\t\t\tif (i % p == 0) {",
            "\t\t\t\tif (i != ps[i]) {",
            "\t\t\t\t\tps[x] = ps[i] * p, ks[x] = ks[i] + 1;",
            "\t\t\t\t\tphi[x] = phi[i / ps[i]] * phi[ps[x]];",
            "\t\t\t\t}",
            "\t\t\t\tbreak;",
            "\t\t\t} else {",
            "\t\t\t\tphi[x] = phi[i] * phi[p];",
            "\t\t\t\tps[x] = p, ks[x] = 1;",
            "\t\t\t}",
            "\t\t}",
            "\t}",
            "}",
            "const int KEEP = 2500;",
            "mi dp[KEEP];",
            "bool saved[KEEP];",
            "/*    Prefix sum of multiplicative functions :",
            "\t\tp_f : the prefix sum of f (x) (1 <= x <= th).",
            "\t\tp_g : the prefix sum of g (x) (0 <= x <= N).",
            "\t\tp_c : the prefix sum of f * g (x) (0 <= x <= N).",
            "\t\tth : the thereshold, generally should be n ^ (2 / 3).",
            "*/",
            "struct prefix_mul {",
            "\ttypedef mi (*func)(mi);",
            "\tfunc p_f, p_g, p_c;",
            "\tll n, th;",
            "\tmi inv;",
            "\tunordered_map<ll, mi> mem;",
            "\tprefix_mul(func p_f, func p_g, func p_c):",
            "\t\tp_f(p_f), p_g(p_g), p_c(p_c) {}",
            "\tmi calc(ll x, ll io) {",
            "\t\tif (x <= th) return p_f(x);",
            "\t\tif (saved[io]) return dp[io];",
            "\t\tmi ans = 0;",
            "\t\tfor (ll i = 2, la; i <= x; i = la + 1) {",
            "\t\t\tla = x / (x / i);",
            "\t\t\tans += (p_g(la) - p_g(i - 1)) * calc(x / i, i * io);",
            "\t\t}",
            "\t\tans = (p_c(x) - ans) * inv;",
            "\t\tsaved[io] = 1;",
            "\t\treturn dp[io] = ans;",
            "\t}",
            "\tmi solve(ll n, ll th) {",
            "\t\tif (n <= 0) return 0;",
            "\t\tprefix_mul::n = n;",
            "\t\tprefix_mul::th = th;",
            "\t\tfill(all(saved), 0);",
            "\t\tinv = 1 / p_g(1);",
            "\t\treturn calc(n, 1);",
            "\t}",
            "};",
            "const mi INV2 = 499122177;",
            "mi phi_f(mi n) { return phi[n.v]; }",
            "mi ONE(mi n) { return n; }",
            "mi Id(mi n) { return n * (n + 1) * INV2; }",
            "int main() {",
            "\tcin.tie(0)->sync_with_stdio(0);",
            "\tcin.exceptions(cin.failbit);",
            "\tsieve(LIM);",
            "\trep(i, 2, LIM) phi[i] += phi[i - 1];",
            "\tprefix_mul lmao(phi_f, ONE, Id);",
            "\tll n;",
            "\tcin >> n;",
            "\tcout << lmao.solve(n, LIM - 1) << \"\\n\";",
            "\treturn 0;",
            "}"
        ],
        "prefix": [
            "hack_TotientSum"
        ]
    },
    "Treaps.h": {
        "body": [
            "struct node {",
            "\tint pri, sz = 1;",
            "\tll val, sum, min, lazy = 0;",
            "\tnode *l = NULL, *r = NULL;",
            "\tnode(ll v): val(v), sum(v), min(v) { pri = rand(); }",
            "};",
            "int getSz(node *in) { return in ? in->sz : 0; }",
            "ll getSum(node *in) { return in ? in->sum : 0; }",
            "ll getMin(node *in) { return in ? in->min : 4e18; }",
            "void pushNode(node *in, ll val) {",
            "\tin->sum += val;",
            "\tin->min += val;",
            "\tin->lazy += val;",
            "}",
            "void push(node *in) {",
            "\tif (in->l) pushNode(in->l, in->lazy);",
            "\tif (in->r) pushNode(in->r, in->lazy);",
            "\tin->lazy = 0;",
            "}",
            "void pull(node *in) {",
            "\tin->sz = getSz(in->l) + 1 + getSz(in->r);",
            "\tin->sum = getSum(in->l) + in->val + getSum(in->r);",
            "\tin->min = min(getMin(in->l), min(in->val, getMin(in->r)));",
            "}",
            "pair<node *, node *> split(node *in, int leftIdx) {",
            "\tif (!in) return {NULL, NULL};",
            "\tpush(in);",
            "\tif (leftIdx < getSz(in->l)) {",
            "\t\tauto [lLeft, lRight] = split(in->l, leftIdx);",
            "\t\tin->l = lRight;",
            "\t\tpull(in);",
            "\t\treturn {lLeft, in};",
            "\t}",
            "\tauto [rLeft, rRight] =",
            "\t\tsplit(in->r, leftIdx - (getSz(in->l) + 1));",
            "\tin->r = rLeft;",
            "\tpull(in);",
            "\treturn {in, rRight};",
            "}",
            "node *merge(node *a, node *b) {",
            "\tif (!a) return b;",
            "\tif (!b) return a;",
            "\tpush(a), push(b);",
            "\tif (a->pri < b->pri) {",
            "\t\ta->r = merge(a->r, b);",
            "\t\tpull(a);",
            "\t\treturn a;",
            "\t}",
            "\tb->l = merge(a, b->l);",
            "\tpull(b);",
            "\treturn b;",
            "}",
            "ll getSum(node *in, int l, int r) {",
            "\tauto [rest, right] = split(in, r);",
            "\tauto [left, root] = split(rest, l - 1);",
            "\tll out = getSum(root);",
            "\tin = merge(left, merge(root, right));",
            "\treturn out;",
            "}",
            "void add(node *in, int l, int r, ll val) {",
            "\tauto [rest, right] = split(in, r);",
            "\tauto [left, root] = split(rest, l - 1);",
            "\tpushNode(root, val);",
            "\tin = merge(merge(left, root), right);",
            "}"
        ],
        "prefix": [
            "hack_Treaps"
        ]
    },
    "TreeLifting.h": {
        "body": [
            "struct lift {",
            "\tvi d, p, j;",
            "\tlift(vector<vi>& adj): d(sz(adj)), p(d), j(d) {",
            "\t\tdfs(0, adj);",
            "\t}",
            "\tvoid dfs(int u, vector<vi>& adj) {",
            "\t\tint jmp = (d[u] + d[j[j[u]]] == 2 * d[j[u]]) ? j[j[u]] : u;",
            "\t\tfor (int v : adj[u])",
            "\t\t\tif (v != p[u])",
            "\t\t\t\td[v] = d[p[v] = u] + 1, j[v] = jmp, dfs(v, adj);",
            "\t}",
            "\tint lca(int u, int v) {",
            "\t\tif (d[u] < d[v]) swap(u, v);",
            "\t\twhile (d[u] > d[v]) u = d[j[u]] >= d[v] ? j[u] : p[u];",
            "\t\tif (u == v) return u;",
            "\t\twhile (p[u] != p[v])",
            "\t\t\tif (j[u] != j[v]) u = j[u], v = j[v];",
            "\t\t\telse u = p[u], v = p[v];",
            "\t\treturn p[u];",
            "\t}",
            "\tint kth(int u, int k) {",
            "\t\tif (k > d[u]) return -1;",
            "\t\tk = d[u] - k;",
            "\t\twhile (d[u] > k) u = d[j[u]] >= k ? j[u] : p[u];",
            "\t\treturn u;",
            "\t}",
            "};"
        ],
        "description": "Calculate jumps up a tree,\nto support fast upward jumps and LCAs.\nAssumes the root node points to itself.",
        "prefix": [
            "hack_TreeLifting"
        ]
    },
    "TwoEdgeCCs.h": {
        "body": [
            "vector<vector<pii>> ed;",
            "int preCnt, metaN, stkSz;",
            "vi pre, metaMap, stk;",
            "void pop(int stop) {",
            "\twhile (stkSz > 0) {",
            "\t\tint curr = stk[--stkSz];",
            "\t\tmetaMap[curr] = metaN;",
            "\t\tif (curr == stop) break;",
            "\t}",
            "\t++metaN;",
            "}",
            "int dfs(int idx, int par) {",
            "\tint low = pre[idx] = ++preCnt;",
            "\tstk[stkSz++] = idx;",
            "\tfor (auto [v, id] : ed[idx]) {",
            "\t\tif (id == par) continue;",
            "\t\tif (pre[v] != -1) low = min(low, pre[v]); // back edge",
            "\t\telse {",
            "\t\t\tint get = dfs(v, id);",
            "\t\t\tlow = min(low, get);",
            "\t\t\tif (get == pre[v]) pop(v); // bridge",
            "\t\t}",
            "\t}",
            "\tif (par == -1 && stkSz) pop(idx); // root case",
            "\treturn low;",
            "}",
            "vector<vector<pii>> getMeta() {",
            "\tint n = sz(ed);",
            "\tpreCnt = -1;",
            "\tmetaN = 0;",
            "\tpre.assign(n, -1);",
            "\tmetaMap.resize(n);",
            "\tstk.resize(n);",
            "\tstkSz = 0;",
            "\trep(i, 0, n) if (pre[i] == -1) dfs(i, -1);",
            "\tvector<vector<pii>> metaEdges(metaN);",
            "\trep(u, 0, n) for (auto [v, id] : ed[u]) if (",
            "\t\tmetaMap[u] != metaMap[v]) metaEdges[metaMap[u]]",
            "\t\t.emplace_back(metaMap[v], id);",
            "\treturn metaEdges;",
            "}"
        ],
        "description": "Finds all Two Edge Connected Components and\nconstructs a meta graph. The meta tree constructed has all\nnodes of the same 2ECC compressed into one, with bridges\nconnecting them. Multi-edges are NOT bridges.",
        "prefix": [
            "hack_TwoEdgeCCs"
        ]
    },
    "TwoVertexCCs.h": {
        "body": [
            "vi num, st;",
            "vector<vector<pii>> ed;",
            "int Time;",
            "template<class F> int dfs(int at, int par, F& f) {",
            "\tint me = num[at] = ++Time, e, y, top = me;",
            "\tfor (auto pa : ed[at])",
            "\t\tif (pa.second != par) {",
            "\t\t\ttie(y, e) = pa;",
            "\t\t\tif (num[y]) {",
            "\t\t\t\ttop = min(top, num[y]);",
            "\t\t\t\tif (num[y] < me) st.push_back(e);",
            "\t\t\t} else {",
            "\t\t\t\tint si = sz(st);",
            "\t\t\t\tint up = dfs(y, e, f);",
            "\t\t\t\ttop = min(top, up);",
            "\t\t\t\tif (up == me) {",
            "\t\t\t\t\tst.push_back(e);",
            "\t\t\t\t\tf(vi(st.begin() + si, st.end()));",
            "\t\t\t\t\tst.resize(si);",
            "\t\t\t\t} else if (up < me) st.push_back(e);",
            "\t\t\t\telse { /* e is a bridge */ }",
            "\t\t\t}",
            "\t\t}",
            "\treturn top;",
            "}",
            "template<class F> void twoVCCs(F f) {",
            "\tnum.assign(sz(ed), 0);",
            "\trep(i, 0, sz(ed)) if (!num[i]) dfs(i, -1, f);",
            "}"
        ],
        "description": "Finds all Two Vertex Connected Components and\nruns a callback for the edges in each. Note that a node can\nbe in several components. An edge which is not in a component is a bridge,\ni.e., not part of any cycle.",
        "prefix": [
            "hack_TwoVertexCCs"
        ]
    },
    "WeightedMatching.h": {
        "body": [
            "pair<int, vi> hungarian(const vector<vi> &a) {",
            "\tif (a.empty()) return {0, {}};",
            "\tint n = sz(a) + 1, m = sz(a[0]) + 1;",
            "\tvi u(n), v(m), p(m), ans(n - 1);",
            "\trep(i, 1, n) {",
            "\t\tp[0] = i;",
            "\t\tint j0 = 0; // add \"dummy\" worker 0",
            "\t\tvi dist(m, INT_MAX), pre(m, -1);",
            "\t\tvector<bool> done(m + 1);",
            "\t\tdo { // dijkstra",
            "\t\t\tdone[j0] = true;",
            "\t\t\tint i0 = p[j0], j1, delta = INT_MAX;",
            "\t\t\trep(j, 1, m) if (!done[j]) {",
            "\t\t\t\tauto cur = a[i0 - 1][j - 1] - u[i0] - v[j];",
            "\t\t\t\tif (cur < dist[j]) dist[j] = cur, pre[j] = j0;",
            "\t\t\t\tif (dist[j] < delta) delta = dist[j], j1 = j;",
            "\t\t\t}",
            "\t\t\trep(j, 0, m) {",
            "\t\t\t\tif (done[j]) u[p[j]] += delta, v[j] -= delta;",
            "\t\t\t\telse dist[j] -= delta;",
            "\t\t\t}",
            "\t\t\tj0 = j1;",
            "\t\t} while (p[j0]);",
            "\t\twhile (j0) { // update alternating path",
            "\t\t\tint j1 = pre[j0];",
            "\t\t\tp[j0] = p[j1], j0 = j1;",
            "\t\t}",
            "\t}",
            "\trep(j, 1, m) if (p[j]) ans[p[j] - 1] = j - 1;",
            "\treturn {-v[0], ans}; // min cost",
            "}"
        ],
        "description": "Given a weighted bipartite graph, matches every node on\nthe left with a node on the right such that no\nnodes are in two matchings and the sum of the edge weights is minimal. Takes\ncost[N][M], where cost[i][j] = cost for L[i] to be matched with R[j] and\nreturns (min cost, match), where L[i] is matched with\nR[match[i]]. Negate costs for max cost. Requires $N \\le M$.",
        "prefix": [
            "hack_WeightedMatching"
        ]
    },
    "YoinkedWavelet.h": {
        "body": [
            "template<typename T> struct WaveletTree {",
            "\tvector<size_t> build_idxs(size_t n) {",
            "\t\tvector<size_t> _idxs(n);",
            "\t\tiota(_idxs.begin(), _idxs.end(), 0);",
            "\t\treturn _idxs;",
            "\t}",
            "\tWaveletTree(const vector<T>& v, const vector<size_t>& idxs,",
            "\t\tT lo, T hi):",
            "\t\tlo(lo),",
            "\t\thi(hi), idxs(idxs), left_sum(1, 0) {",
            "\t\tif (is_leaf()) return;",
            "\t\tT mid = (lo + hi) / 2;",
            "\t\tvector<size_t> lo_idxs, hi_idxs;",
            "\t\tleft_sum.reserve(idxs.size() + 1);",
            "\t\tfor (size_t idx : idxs) {",
            "\t\t\tif (v[idx] < mid) {",
            "\t\t\t\tlo_idxs.push_back(idx);",
            "\t\t\t\tleft_sum.push_back(left_sum.back() + 1);",
            "\t\t\t} else {",
            "\t\t\t\thi_idxs.push_back(idx);",
            "\t\t\t\tleft_sum.push_back(left_sum.back());",
            "\t\t\t}",
            "\t\t}",
            "\t\tchildren[0] =",
            "\t\t\tmake_unique<WaveletTree>(v, lo_idxs, lo, mid);",
            "\t\tchildren[1] =",
            "\t\t\tmake_unique<WaveletTree>(v, hi_idxs, mid, hi);",
            "\t}",
            "\tWaveletTree(const vector<T>& v):",
            "\t\tWaveletTree(v, build_idxs(v.size()),",
            "\t\t\t*min_element(v.begin(), v.end()),",
            "\t\t\t*max_element(v.begin(), v.end()) + 1) {}",
            "\tbool is_leaf() const { return lo + 1 == hi || idxs.empty(); }",
            "\t// Find the index of the k-th smallest value in the range [l, r)",
            "\t// k is 0 indexed.",
            "\t// Returns -1 on failure",
            "\tssize_t kth(size_t l, size_t r, size_t k) {",
            "\t\tif (is_leaf()) return k < idxs.size() ? idxs[k] : -1;",
            "\t\tint32_t in_left = left_sum[r] - left_sum[l];",
            "\t\tif (k < in_left) {",
            "\t\t\treturn children[0]->kth(left_sum[l], left_sum[r], k);",
            "\t\t} else {",
            "\t\t\treturn children[1]->kth(l - left_sum[l], r - left_sum[r],",
            "\t\t\t\tk - in_left);",
            "\t\t}",
            "\t}",
            "\tT lo;",
            "\tT hi;",
            "\tvector<size_t> idxs;",
            "\t// left_sum[i] = # of the first i indexes <= mid",
            "\tvector<int32_t> left_sum;",
            "\tarray<unique_ptr<WaveletTree>, 2> children;",
            "};"
        ],
        "prefix": [
            "hack_YoinkedWavelet"
        ]
    },
    "ZValues.h": {
        "body": [
            "vector<int> zValues(string& s) {",
            "\tint n = (int)s.length();",
            "\tvector<int> z(n);",
            "\tfor (int i = 1, L = 0, R = 0; i < n; ++i) {",
            "\t\tif (i <= R) z[i] = min(R - i + 1, z[i - L]);",
            "\t\twhile (i + z[i] < n && s[z[i]] == s[i + z[i]]) ++z[i];",
            "\t\tif (i + z[i] - 1 > R) L = i, R = i + z[i] - 1;",
            "\t}",
            "\treturn z;",
            "}"
        ],
        "prefix": [
            "hack_ZValues"
        ]
    },
    "ahocorasick.h": {
        "body": [
            "const int ALPHA = 26;",
            "struct AhoCorasick {",
            "\tint nodeCount;",
            "\tvector<vector<int>> transition, children;",
            "\tvector<int> term, leaf;",
            "\tqueue<int> q;",
            "\tAhoCorasick() {}",
            "\tAhoCorasick(vector<string> &strs) {",
            "\t\tint maxNodes = 1;",
            "\t\tfor (string &s : strs) maxNodes += (int)s.length();",
            "\t\ttransition.resize(ALPHA);",
            "\t\tchildren.resize(ALPHA, vector<int>(maxNodes));",
            "\t\tleaf.resize(maxNodes);",
            "\t\tnodeCount = 1;",
            "\t\tfor (string &s : strs) {",
            "\t\t\tint node = 0;",
            "\t\t\tfor (char &ch : s) {",
            "\t\t\t\tint c = ch - 'a';",
            "\t\t\t\tif (children[c][node] == 0)",
            "\t\t\t\t\tchildren[c][node] = nodeCount++;",
            "\t\t\t\tnode = children[c][node];",
            "\t\t\t}",
            "\t\t\tleaf[node]++;",
            "\t\t}",
            "\t\tfor (int i = 0; i < ALPHA; ++i)",
            "\t\t\ttransition[i].resize(nodeCount);",
            "\t\tterm.resize(nodeCount);",
            "\t\tq.push(0), q.push(0);",
            "\t\twhile (q.size()) {",
            "\t\t\tint node = q.front();",
            "\t\t\tq.pop();",
            "\t\t\tint suffLink = q.front();",
            "\t\t\tq.pop();",
            "\t\t\tterm[node] = leaf[node] + term[suffLink];",
            "\t\t\tfor (int ch = 0; ch < ALPHA; ++ch) {",
            "\t\t\t\tif (children[ch][node] != 0) {",
            "\t\t\t\t\ttransition[ch][node] = children[ch][node];",
            "\t\t\t\t\tq.push(children[ch][node]);",
            "\t\t\t\t\tq.push(node == 0 ? 0 : transition[ch][suffLink]);",
            "\t\t\t\t} else {",
            "\t\t\t\t\ttransition[ch][node] = transition[ch][suffLink];",
            "\t\t\t\t}",
            "\t\t\t}",
            "\t\t}",
            "\t}",
            "};"
        ],
        "prefix": [
            "hack_ahocorasick"
        ]
    },
    "angleCmp.h": {
        "body": [
            "template<class P> bool sameDir(P s, P t) {",
            "\treturn s.cross(t) == 0 && s.dot(t) > 0;",
            "}",
            "// checks 180 <= s..t < 360?",
            "template<class P> bool isReflex(P s, P t) {",
            "\tauto c = s.cross(t);",
            "\treturn c ? (c < 0) : (s.dot(t) < 0);",
            "}",
            "// operator < (s,t) for angles in [base,base+2pi)",
            "template<class P> bool angleCmp(P base, P s, P t) {",
            "\tint r = isReflex(base, s) - isReflex(base, t);",
            "\treturn r ? (r < 0) : (0 < s.cross(t));",
            "}",
            "// is x in [s,t] taken ccw? 1/0/-1 for in/border/out",
            "template<class P> int angleBetween(P s, P t, P x) {",
            "\tif (sameDir(x, s) || sameDir(x, t)) return 0;",
            "\treturn angleCmp(s, x, t) ? 1 : -1;",
            "}"
        ],
        "description": "Useful utilities for dealing with angles of rays from origin.\nOK for integers, only uses cross product. Doesn't support (0,0).",
        "prefix": [
            "hack_angleCmp"
        ]
    },
    "binomialModPrime.h": {
        "body": [
            "ll chooseModP(ll n, ll m, int p, vi& fact, vi& invfact) {",
            "\tll c = 1;",
            "\twhile (n || m) {",
            "\t\tll a = n % p, b = m % p;",
            "\t\tif (a < b) return 0;",
            "\t\tc = c * fact[a] % p * invfact[b] % p * invfact[a - b] % p;",
            "\t\tn /= p, m /= p;",
            "\t}",
            "\treturn c;",
            "}"
        ],
        "description": "Lucas' thm: Let $n,m$ be non-negative integers and $p$ a prime.\nWrite $n=n_kp^k+...+n_1p+n_0$ and $m=m_kp^k+...+m_1p+m_0$.\nThen $\\binom{n}{m} \\equiv \\prod_{i=0}^k\\binom{n_i}{m_i} \\pmod{p}$.\nfact and invfact must hold pre-computed factorials / inverse factorials, e.g. from ModInverse.h.",
        "prefix": [
            "hack_binomialModPrime"
        ]
    },
    "circumcircle.h": {
        "body": [
            "typedef Point<double> P;",
            "double ccRadius(const P& A, const P& B, const P& C) {",
            "\treturn (B - A).dist() * (C - B).dist() * (A - C).dist() /",
            "\t\tabs((B - A).cross(C - A)) / 2;",
            "}",
            "P ccCenter(const P& A, const P& B, const P& C) {",
            "\tP b = C - A, c = B - A;",
            "\treturn A +",
            "\t\t(b * c.dist2() - c * b.dist2()).perp() / b.cross(c) / 2;",
            "}"
        ],
        "description": "\\\\\n\\begin{minipage}{75mm}\nThe circumcirle of a triangle is the circle intersecting all three vertices. ccRadius returns the radius of the circle going through points A, B and C and ccCenter returns the center of the same circle.\n\\end{minipage}\n\\begin{minipage}{15mm}\n\\vspace{-2mm}\n\\includegraphics[width=\\textwidth]{content/geometry/circumcircle}\n\\end{minipage}",
        "prefix": [
            "hack_circumcircle"
        ]
    },
    "dominatortree.cpp": {
        "body": [
            "struct DominatorTree {",
            "\tvector<vi> adj,",
            "\t\tans; // input edges, edges of dominator tree (directed tree downwards from root)",
            "\tvector<vi> radj, child, sdomChild;",
            "\tvi label, rlabel, sdom, dom;",
            "\tvi par, bes;",
            "\tint co = 0;",
            "\tDominatorTree(int n) {",
            "\t\tn += n;",
            "\t\tadj = ans = radj = child = sdomChild =",
            "\t\t\tvector<vector<int>>(n);",
            "\t\tlabel = rlabel = sdom = dom = par = bes = vector<int>(n);",
            "\t}",
            "\tvoid add_edge(int a, int b) { adj[a].pb(b); }",
            "\tint get(int x) {",
            "\t\tif (par[x] != x) {",
            "\t\t\tint t = get(par[x]);",
            "\t\t\tpar[x] = par[par[x]];",
            "\t\t\tif (sdom[t] < sdom[bes[x]]) bes[x] = t;",
            "\t\t}",
            "\t\treturn bes[x];",
            "\t}",
            "\tvoid dfs(int x) { // create DFS tree",
            "\t\tlabel[x] = ++co;",
            "\t\trlabel[co] = x;",
            "\t\tsdom[co] = par[co] = bes[co] = co;",
            "\t\tfor (auto y : adj[x]) {",
            "\t\t\tif (!label[y]) {",
            "\t\t\t\tdfs(y);",
            "\t\t\t\tchild[label[x]].pb(label[y]);",
            "\t\t\t}",
            "\t\t\tradj[label[y]].pb(label[x]);",
            "\t\t}",
            "\t}",
            "\tvoid init(int root) {",
            "\t\tdfs(root);",
            "\t\tfor (int i = co; i >= 1; --i) {",
            "\t\t\tfor (auto j : radj[i])",
            "\t\t\t\tsdom[i] = min(sdom[i], sdom[get(j)]);",
            "\t\t\tif (i > 1) sdomChild[sdom[i]].pb(i);",
            "\t\t\tfor (auto j : sdomChild[i]) {",
            "\t\t\t\tint k = get(j);",
            "\t\t\t\tif (sdom[j] == sdom[k]) dom[j] = sdom[j];",
            "\t\t\t\telse dom[j] = k;",
            "\t\t\t}",
            "\t\t\tfor (auto j : child[i]) par[j] = i;",
            "\t\t}",
            "\t\tfor (int i = 2; i < co + 1; ++i) {",
            "\t\t\tif (dom[i] != sdom[i]) dom[i] = dom[dom[i]];",
            "\t\t\tans[rlabel[dom[i]]].pb(rlabel[i]);",
            "\t\t}",
            "\t}",
            "};"
        ],
        "prefix": [
            "hack_dominatortree"
        ]
    },
    "eertree.h": {
        "body": [
            "struct eertree {",
            "\tvi s, rem;",
            "\tstruct node {",
            "\t\tint len = 0, link = 0, from = 0, cnt = 0;",
            "\t\tint visit = -1;",
            "\t\tarray<int, 26> to{};",
            "\t};",
            "\tvector<node> T;",
            "\tint last, n;",
            "\tint head = 1, overall = 0;",
            "\teertree(): s(1), T(2), rem(2, -1), last(0), n(1) {",
            "\t\ts.reserve(1e6 + 5), T.reserve(1e6 + 5),",
            "\t\t\trem.reserve(1e6 + 5);",
            "\t\ts[0] = -1;",
            "\t\tT[0].link = T[1].link = 1;",
            "\t\tT[1].len = -1;",
            "\t\tT[0].cnt = T[1].cnt = 1;",
            "\t}",
            "\tint get_link(int v) {",
            "\t\twhile (s[n - T[v].len - 2] != s[n - 1]) v = T[v].link;",
            "\t\treturn v;",
            "\t}",
            "\tvoid update(int u, int p) {",
            "\t\tif (u < 2) return;",
            "\t\tauto& x = T[u];",
            "\t\tif (p > x.visit) x.visit = p;",
            "\t\tif (!x.cnt &&",
            "\t\t\t(rem[x.visit] == -1 || T[rem[x.visit]].len < x.len))",
            "\t\t\trem[x.visit] = u;",
            "\t}",
            "\tvoid add(char ch) {",
            "\t\tint c = ch - 'a';",
            "\t\ts.push_back(c), rem.push_back(0);",
            "\t\tn++;",
            "\t\tlast = get_link(last);",
            "\t\tif (T[last].to[c] == 0) {",
            "\t\t\tauto& nd = T.emplace_back();",
            "\t\t\tnd.len = T[last].len + 2;",
            "\t\t\tnd.link = T[get_link(T[last].link)].to[c];",
            "\t\t\tnd.from = last;",
            "\t\t\tT[last].to[c] = sz(T) - 1;",
            "\t\t\tT[nd.from].cnt++, T[nd.link].cnt++;",
            "\t\t\toverall++;",
            "\t\t}",
            "\t\tlast = T[last].to[c];",
            "\t\tupdate(last, n - T[last].len);",
            "\t}",
            "\tvoid pop() {",
            "\t\tint node = rem[head], c = s[head];",
            "\t\ts[head++] = -1;",
            "\t\tif (node < 2) return;",
            "\t\tauto& nd = T[node];",
            "\t\tif (nd.cnt || nd.visit != head - 1) return;",
            "\t\tif (n - head + 1 == T[last].len) last = T[last].link;",
            "\t\toverall--;",
            "\t\tT[nd.from].to[c] = 0;",
            "\t\tT[nd.from].cnt--, T[nd.link].cnt--;",
            "\t\tupdate(nd.from, head);",
            "\t\tupdate(nd.link, head - 1 + nd.len - T[nd.link].len);",
            "\t}",
            "};"
        ],
        "prefix": [
            "hack_eertree"
        ]
    },
    "factorialMod.h": {
        "body": [
            "int factmod(int n, int p) {",
            "\tvector<int> f(p);",
            "\tf[0] = 1;",
            "\tfor (int i = 1; i < p; i++) f[i] = f[i - 1] * i % p;",
            "\tint res = 1;",
            "\twhile (n > 1) {",
            "\t\tif ((n / p) % 2) res = p - res;",
            "\t\tres = res * f[n % p] % p;",
            "\t\tn /= p;",
            "\t}",
            "\treturn res;",
            "}",
            "int multiplicityFactorial(int n, int p) {",
            "\tint count = 0;",
            "\tdo {",
            "\t\tn /= p;",
            "\t\tcount += n;",
            "\t} while (n);",
            "\treturn count;",
            "}"
        ],
        "prefix": [
            "hack_factorialMod"
        ]
    },
    "halfPlane.h": {
        "body": [
            "#define eps 1e-8",
            "typedef Point<double> P;",
            "struct Line {",
            "\tP P1, P2;",
            "\t// Right hand side of the ray P1 -> P2",
            "\texplicit Line(P a = P(), P b = P()): P1(a), P2(b){};",
            "\tP intpo(Line y) {",
            "\t\tP r;",
            "\t\tassert(lineIntersection(P1, P2, y.P1, y.P2, r) == 1);",
            "\t\treturn r;",
            "\t}",
            "\tP dir() { return P2 - P1; }",
            "\tbool contains(P x) { return (P2 - P1).cross(x - P1) < eps; }",
            "\tbool out(P x) { return !contains(x); }",
            "};",
            "template<class T> bool mycmp(Point<T> a, Point<T> b) {",
            "\t// return atan2(a.y, a.x) < atan2(b.y, b.x);",
            "\tif (a.x * b.x < 0) return a.x < 0;",
            "\tif (abs(a.x) < eps) {",
            "\t\tif (abs(b.x) < eps) return a.y > 0 && b.y < 0;",
            "\t\tif (b.x < 0) return a.y > 0;",
            "\t\tif (b.x > 0) return true;",
            "\t}",
            "\tif (abs(b.x) < eps) {",
            "\t\tif (a.x < 0) return b.y < 0;",
            "\t\tif (a.x > 0) return false;",
            "\t}",
            "\treturn a.cross(b) > 0;",
            "}",
            "bool cmp(Line a, Line b) { return mycmp(a.dir(), b.dir()); }",
            "double Intersection_Area(vector<Line> b) {",
            "\tsort(b.begin(), b.end(), cmp);",
            "\tint n = b.size();",
            "\tint q = 1, h = 0, i;",
            "\tvector<Line> c(b.size() + 10);",
            "\tfor (i = 0; i < n; i++) {",
            "\t\twhile (q < h && b[i].out(c[h].intpo(c[h - 1]))) h--;",
            "\t\twhile (q < h && b[i].out(c[q].intpo(c[q + 1]))) q++;",
            "\t\tc[++h] = b[i];",
            "\t\tif (q < h && abs(c[h].dir().cross(c[h - 1].dir())) < eps) {",
            "\t\t\tif (c[h].dir().dot(c[h - 1].dir()) > 0) {",
            "\t\t\t\th--;",
            "\t\t\t\tif (b[i].out(c[h].P1)) c[h] = b[i];",
            "\t\t\t} else {",
            "\t\t\t\t// The area is either 0 or infinite.",
            "\t\t\t\t// If you have a bounding box, then the area is definitely 0.",
            "\t\t\t\treturn 0;",
            "\t\t\t}",
            "\t\t}",
            "\t}",
            "\twhile (q < h - 1 && c[q].out(c[h].intpo(c[h - 1]))) h--;",
            "\twhile (q < h - 1 && c[h].out(c[q].intpo(c[q + 1]))) q++;",
            "\t// Intersection is empty. This is sometimes different from the case when",
            "\t// the intersection area is 0.",
            "\tif (h - q <= 1) return 0;",
            "\tc[h + 1] = c[q];",
            "\tvector<P> s;",
            "\tfor (i = q; i <= h; i++) s.push_back(c[i].intpo(c[i + 1]));",
            "\ts.push_back(s[0]);",
            "\tdouble ans = 0;",
            "\tfor (i = 0; i < (int)s.size() - 1; i++)",
            "\t\tans += s[i].cross(s[i + 1]);",
            "\treturn ans / 2;",
            "}"
        ],
        "description": "Halfplane intersection area",
        "prefix": [
            "hack_halfPlane"
        ]
    },
    "hopcroftKarp.h": {
        "body": [
            "bool dfs(int a, int L, vector<vi>& g, vi& btoa, vi& A, vi& B) {",
            "\tif (A[a] != L) return 0;",
            "\tA[a] = -1;",
            "\tfor (int b : g[a])",
            "\t\tif (B[b] == L + 1) {",
            "\t\t\tB[b] = 0;",
            "\t\t\tif (btoa[b] == -1 || dfs(btoa[b], L + 1, g, btoa, A, B))",
            "\t\t\t\treturn btoa[b] = a, 1;",
            "\t\t}",
            "\treturn 0;",
            "}",
            "int hopcroftKarp(vector<vi>& g, vi& btoa) {",
            "\tint res = 0;",
            "\tvi A(g.size()), B(btoa.size()), cur, next;",
            "\tfor (;;) {",
            "\t\tfill(all(A), 0);",
            "\t\tfill(all(B), 0);",
            "\t\tcur.clear();",
            "\t\tfor (int a : btoa)",
            "\t\t\tif (a != -1) A[a] = -1;",
            "\t\trep(a, 0, sz(g)) if (A[a] == 0) cur.push_back(a);",
            "\t\tfor (int lay = 1;; lay++) {",
            "\t\t\tbool islast = 0;",
            "\t\t\tnext.clear();",
            "\t\t\tfor (int a : cur)",
            "\t\t\t\tfor (int b : g[a]) {",
            "\t\t\t\t\tif (btoa[b] == -1) {",
            "\t\t\t\t\t\tB[b] = lay;",
            "\t\t\t\t\t\tislast = 1;",
            "\t\t\t\t\t} else if (btoa[b] != a && !B[b]) {",
            "\t\t\t\t\t\tB[b] = lay;",
            "\t\t\t\t\t\tnext.push_back(btoa[b]);",
            "\t\t\t\t\t}",
            "\t\t\t\t}",
            "\t\t\tif (islast) break;",
            "\t\t\tif (next.empty()) return res;",
            "\t\t\tfor (int a : next) A[a] = lay;",
            "\t\t\tcur.swap(next);",
            "\t\t}",
            "\t\trep(a, 0, sz(g)) res += dfs(a, 0, g, btoa, A, B);",
            "\t}",
            "}"
        ],
        "description": "Fast bipartite matching algorithm. Graph $g$ should be a list\nof neighbors of the left partition, and $btoa$ should be a vector full of\n-1's of the same size as the right partition. Returns the size of\nthe matching. $btoa[i]$ will be the match for vertex $i$ on the right side,\nor $-1$ if it's not matched.",
        "prefix": [
            "hack_hopcroftKarp"
        ]
    },
    "implicittreap.cpp": {
        "body": [
            "namespace ImplicitTreap {",
            "mt19937 rng(696969420);",
            "struct node {",
            "\tint val;",
            "\tint count, prio;",
            "\tnode *l, *r, *p;",
            "\tstring debug(int index) {",
            "\t\treturn \"(\" + to_string(index) + \",\" + to_string(val) + \")\";",
            "\t}",
            "};",
            "static int getCount(node* root) {",
            "\treturn root ? root->count : 0;",
            "}",
            "void update(node* root) {",
            "\tif (!root) return;",
            "\troot->p = NULL;",
            "\tif (root->l) root->l->p = root;",
            "\tif (root->r) root->r->p = root;",
            "\troot->count = 1 + getCount(root->l) + getCount(root->r);",
            "}",
            "void merge(node*& t, node* l, node* r) {",
            "\tif (!l || !r) t = l ? l : r;",
            "\telse if (l->prio > r->prio) merge(l->r, l->r, r), t = l;",
            "\telse merge(r->l, l, r->l), t = r;",
            "\tupdate(t);",
            "}",
            "//splits s.t. l < index && r >= index",
            "void split(node* t, node*& l, node*& r, int index,",
            "\tint add = 0) {",
            "\tif (!t) return void(l = r = NULL);",
            "\tint cur_index = add + getCount(t->l);",
            "\tif (index <= cur_index)",
            "\t\tsplit(t->l, l, t->l, index, add), r = t;",
            "\telse",
            "\t\tsplit(t->r, t->r, r, index, add + 1 + getCount(t->l)),",
            "\t\t\tl = t;",
            "\tupdate(t);",
            "}",
            "node* remove(node*& t, int index) {",
            "\tnode *l, *r, *del;",
            "\tsplit(t, l, r, index);",
            "\tsplit(r, del, r, 1);",
            "\tmerge(t, l, r);",
            "\treturn del;",
            "}",
            "void insert(node*& t, node* item, int index) {",
            "\tnode *l, *r;",
            "\tsplit(t, l, r, index);",
            "\tmerge(l, l, item), merge(t, l, r);",
            "}",
            "node* insert(node*& root, int index, int val) {",
            "\tnode* item = new node();",
            "\titem->val = val;",
            "\titem->count = 1;",
            "\titem->prio = rng();",
            "\titem->l = item->r = item->p = NULL;",
            "\tinsert(root, item, index);",
            "\treturn item;",
            "}",
            "node* get(node* t, int index, int add = 0) {",
            "\tint cur_index = add + getCount(t->l);",
            "\tif (index < cur_index) return get(t->l, index, add);",
            "\tif (index > cur_index)",
            "\t\treturn get(t->r, index, add + 1 + getCount(t->l));",
            "\treturn t;",
            "}",
            "int get_index(node* t) {",
            "\tint leq = getCount(t->l) + 1;",
            "\twhile (t->p) {",
            "\t\tif (t->p->r == t) leq += getCount(t->p->l) + 1;",
            "\t\tt = t->p;",
            "\t}",
            "\treturn leq - 1;",
            "}",
            "void print(node* t, int& index, bool isRoot) {",
            "\tif (!t) return;",
            "\tprint(t->l, index, false);",
            "\tcerr << t->debug(index++) << ' ';",
            "\tprint(t->r, index, false);",
            "\tif (isRoot) cout << endl;",
            "}",
            "void print(node* t) {",
            "\tint index = 0;",
            "\tprint(t, index, true);",
            "}",
            "};"
        ],
        "prefix": [
            "hack_implicittreap"
        ]
    },
    "javamcmf.h": {
        "body": [
            "struct MinCostFlow4 {",
            "\tstruct Edge {",
            "\t\tint u, v;",
            "\t\tll cap, cost;",
            "\t\tEdge* rev;",
            "\t\tEdge(int s, int e, ll cap, ll c):",
            "\t\t\tu(s), v(e), cap(cap), cost(c), rev(nullptr) {}",
            "\t};",
            "\tstruct Node {",
            "\t\tint id;",
            "\t\tll d;",
            "\t\tNode(int i, ll dd): id(i), d(dd) {}",
            "\t\tbool operator<(const Node& o) const { return d > o.d; }",
            "\t};",
            "\tll INF1 = 1000000000;",
            "\tll INF2 = 100000000;",
            "\tvector<vector<Edge*>> adj;",
            "\tint s, t, mS, mT;",
            "\tvector<Edge*> previous;",
            "\tvector<ll> w, pi;",
            "\tMinCostFlow4() {}",
            "\tMinCostFlow4(int n) {",
            "\t\ts = n++;",
            "\t\tt = n++;",
            "\t\tmS = n++;",
            "\t\tmT = n++;",
            "\t\tadj.resize(n);",
            "\t}",
            "\tEdge* add(int a, int b, ll cap, ll c) {",
            "\t\tEdge* e1 = new Edge(a, b, cap, c);",
            "\t\tEdge* e2 = new Edge(b, a, 0, -c);",
            "\t\te1->rev = e2;",
            "\t\te2->rev = e1;",
            "\t\tadj[a].pb(e1);",
            "\t\tadj[b].pb(e2);",
            "\t\treturn e1;",
            "\t}",
            "\tpll minCostMaxFlowNegCycles() {",
            "\t\tEdge* f = add(t, s, INF1, -INF2);",
            "\t\tll c = minCostFlow();",
            "\t\treturn {INF1 - f->cap, c + INF2 * (INF1 - f->cap)};",
            "\t}",
            "\tll minCostFlow() {",
            "\t\tll res = 0;",
            "\t\tvector<ll> val(sz(adj));",
            "\t\tfor (int i = 0; i < sz(adj); i++) {",
            "\t\t\tfor (Edge* e : adj[i]) {",
            "\t\t\t\tif (e->cap > 0 && e->cost < 0) {",
            "\t\t\t\t\tres += e->cap * e->cost;",
            "\t\t\t\t\tval[e->u] -= e->cap, val[e->v] += e->cap;",
            "\t\t\t\t\te->rev->cap = e->cap;",
            "\t\t\t\t\te->cap = 0;",
            "\t\t\t\t}",
            "\t\t\t}",
            "\t\t}",
            "\t\tfor (int i = 0; i < sz(val); i++)",
            "\t\t\tif (val[i] > 0) add(mS, i, val[i], 0);",
            "\t\t\telse if (val[i] < 0) add(i, mT, -val[i], 0);",
            "\t\t// add(sink, source, INF1, 0);\t// for min cost flow with source and sink",
            "\t\ts = mS;",
            "\t\tt = mT;",
            "\t\treturn res + minCostMaxFlow().second;",
            "\t}",
            "\tpll minCostMaxFlow() {",
            "\t\tll flow = 0, cost = 0;",
            "\t\tgetPotential();",
            "\t\twhile (findPath()) {",
            "\t\t\tflow += w[t];",
            "\t\t\tcost += update();",
            "\t\t}",
            "\t\treturn {flow, cost};",
            "\t}",
            "\tvoid getPotential() {",
            "\t\tpi.assign(adj.size(), INF1);",
            "\t\tpi[s] = 0;",
            "\t\tfor (int i = 0; i < sz(adj) - 1; i++) {",
            "\t\t\tbool upd = false;",
            "\t\t\tfor (int j = 0; j < sz(adj); j++) {",
            "\t\t\t\tfor (Edge* e : adj[j]) {",
            "\t\t\t\t\tif (e->cap > 0 && pi[e->u] + e->cost < pi[e->v]) {",
            "\t\t\t\t\t\tpi[e->v] = pi[e->u] + e->cost;",
            "\t\t\t\t\t\tupd = true;",
            "\t\t\t\t\t}",
            "\t\t\t\t}",
            "\t\t\t}",
            "\t\t\tif (!upd) break;",
            "\t\t}",
            "\t}",
            "\tbool findPath() {",
            "\t\tvector<ll> d(sz(adj), INF1);",
            "\t\td[s] = 0;",
            "\t\tprevious.assign(sz(adj), nullptr);",
            "\t\tw.assign(sz(adj), INF1);",
            "\t\tpriority_queue<Node> pq;",
            "\t\tpq.emplace(s, 0);",
            "\t\twhile (sz(pq)) {",
            "\t\t\tNode node = pq.top();",
            "\t\t\tpq.pop();",
            "\t\t\tif (node.d == d[node.id]) {",
            "\t\t\t\tfor (Edge* e : adj[node.id]) {",
            "\t\t\t\t\tll nd = d[node.id] + e->cost + pi[e->u] - pi[e->v];",
            "\t\t\t\t\tif (e->cap > 0 && nd < d[e->v]) {",
            "\t\t\t\t\t\td[e->v] = nd;",
            "\t\t\t\t\t\tprevious[e->v] = e;",
            "\t\t\t\t\t\tw[e->v] = min(w[node.id], e->cap);",
            "\t\t\t\t\t\tpq.emplace(e->v, nd);",
            "\t\t\t\t\t}",
            "\t\t\t\t}",
            "\t\t\t}",
            "\t\t}",
            "\t\tfor (int i = 0; i < sz(pi); i++) pi[i] += d[i];",
            "\t\treturn d[t] < INF1;",
            "\t}",
            "\tll update() {",
            "\t\tint v = t;",
            "\t\tll cur = 0;",
            "\t\twhile (previous[v] != nullptr) {",
            "\t\t\tprevious[v]->cap -= w[t];",
            "\t\t\tprevious[v]->rev->cap += w[t];",
            "\t\t\tcur += w[t] * previous[v]->cost;",
            "\t\t\tv = previous[v]->u;",
            "\t\t}",
            "\t\treturn cur;",
            "\t}",
            "};"
        ],
        "prefix": [
            "hack_javamcmf"
        ]
    },
    "kdTree.h": {
        "body": [
            "typedef long long T;",
            "typedef Point<T> P;",
            "const T INF = numeric_limits<T>::max();",
            "bool on_x(const P& a, const P& b) { return a.x < b.x; }",
            "bool on_y(const P& a, const P& b) { return a.y < b.y; }",
            "struct Node {",
            "\tP pt; // if this is a leaf, the single point in it",
            "\tT x0 = INF, x1 = -INF, y0 = INF, y1 = -INF; // bounds",
            "\tNode *first = 0, *second = 0;",
            "\tT distance(const P& p) { // min squared distance to a point",
            "\t\tT x = (p.x < x0 ? x0 : p.x > x1 ? x1 : p.x);",
            "\t\tT y = (p.y < y0 ? y0 : p.y > y1 ? y1 : p.y);",
            "\t\treturn (P(x, y) - p).dist2();",
            "\t}",
            "\tNode(vector<P>&& vp): pt(vp[0]) {",
            "\t\tfor (P p : vp) {",
            "\t\t\tx0 = min(x0, p.x), x1 = max(x1, p.x);",
            "\t\t\ty0 = min(y0, p.y), y1 = max(y1, p.y);",
            "\t\t}",
            "\t\tif (vp.size() > 1) {",
            "\t\t\t// split on x if width >= height (not ideal...)",
            "\t\t\tsort(all(vp), x1 - x0 >= y1 - y0 ? on_x : on_y);",
            "\t\t\t// divide by taking half the array for each child (not",
            "\t\t\t// best performance with many duplicates in the middle)",
            "\t\t\tint half = sz(vp) / 2;",
            "\t\t\tfirst = new Node({vp.begin(), vp.begin() + half});",
            "\t\t\tsecond = new Node({vp.begin() + half, vp.end()});",
            "\t\t}",
            "\t}",
            "};",
            "struct KDTree {",
            "\tNode* root;",
            "\tKDTree(const vector<P>& vp): root(new Node({all(vp)})) {}",
            "\tpair<T, P> search(Node* node, const P& p) {",
            "\t\tif (!node->first) {",
            "\t\t\t// uncomment if we should not find the point itself:",
            "\t\t\t// if (p == node->pt) return {INF, P()};",
            "\t\t\treturn make_pair((p - node->pt).dist2(), node->pt);",
            "\t\t}",
            "\t\tNode *f = node->first, *s = node->second;",
            "\t\tT bfirst = f->distance(p), bsec = s->distance(p);",
            "\t\tif (bfirst > bsec) swap(bsec, bfirst), swap(f, s);",
            "\t\t// search closest side first, other side if needed",
            "\t\tauto best = search(f, p);",
            "\t\tif (bsec < best.first) best = min(best, search(s, p));",
            "\t\treturn best;",
            "\t}",
            "\t// find nearest point to a point, and its squared distance",
            "\t// (requires an arbitrary operator< for Point)",
            "\tpair<T, P> nearest(const P& p) { return search(root, p); }",
            "};"
        ],
        "description": "KD-tree (2d, can be extended to 3d)",
        "prefix": [
            "hack_kdTree"
        ]
    },
    "lineDistance.h": {
        "body": [
            "template<class P>",
            "double lineDist(const P& a, const P& b, const P& p) {",
            "\treturn (double)(b - a).cross(p - a) / (b - a).dist();",
            "}"
        ],
        "description": "\\\\\n\\begin{minipage}{75mm}\nReturns the signed distance between point p and the line containing points a and b. Positive value on left side and negative on right as seen from a towards b. a==b gives nan. P is supposed to be Point<T> or Point3D<T> where T is e.g. double or long long. It uses products in intermediate steps so watch out for overflow if using int or long long. Using Point3D will always give a non-negative distance. For Point3D, call .dist on the result of the cross product.\n\\end{minipage}\n\\begin{minipage}{15mm}\n\\includegraphics[width=\\textwidth]{content/geometry/lineDistance}\n\\end{minipage}",
        "prefix": [
            "hack_lineDistance"
        ]
    },
    "lineIntersection.h": {
        "body": [
            "template<class P>",
            "pair<int, P> lineInter(P s1, P e1, P s2, P e2) {",
            "\tauto d = (e1 - s1).cross(e2 - s2);",
            "\tif (d == 0) // if parallel",
            "\t\treturn {-(s1.cross(e1, s2) == 0), P(0, 0)};",
            "\tauto p = s2.cross(e1, e2), q = s2.cross(e2, s1);",
            "\treturn {1, (s1 * p + e1 * q) / d};",
            "}"
        ],
        "description": "\\\\\n\\begin{minipage}{75mm}\nIf a unique intersection point of the lines going through s1,e1 and s2,e2 exists \\{1, point\\} is returned.\nIf no intersection point exists \\{0, (0,0)\\} is returned and if infinitely many exists \\{-1, (0,0)\\} is returned.\nThe wrong position will be returned if P is Point<ll> and the intersection point does not have integer coordinates.\nProducts of three coordinates are used in intermediate steps so watch out for overflow if using int or ll.\n\\end{minipage}\n\\begin{minipage}{15mm}\n\\includegraphics[width=\\textwidth]{content/geometry/lineIntersection}\n\\end{minipage}",
        "prefix": [
            "hack_lineIntersection"
        ]
    },
    "linearTransformation.h": {
        "body": [
            "typedef Point<double> P;",
            "P linearTransformation(const P& p0, const P& p1, const P& q0,",
            "\tconst P& q1, const P& r) {",
            "\tP dp = p1 - p0, dq = q1 - q0, num(dp.cross(dq), dp.dot(dq));",
            "\treturn q0 +",
            "\t\tP((r - p0).cross(num), (r - p0).dot(num)) / dp.dist2();",
            "}"
        ],
        "description": "\\\\\n\\begin{minipage}{75mm}\nApply the linear transformation (translation, rotation and scaling) which takes line p0-p1 to line q0-q1 to point r.\n\\end{minipage}\n\\begin{minipage}{15mm}\n\\vspace{-8mm}\n\\includegraphics[width=\\textwidth]{content/geometry/linearTransformation}\n\\vspace{-2mm}\n\\end{minipage}",
        "prefix": [
            "hack_linearTransformation"
        ]
    },
    "mitfft.h": {
        "body": [
            "namespace fft {",
            "#if FFT",
            "// FFT",
            "using dbl = double;",
            "struct num {",
            "\tdbl x, y;",
            "\tnum(dbl x_ = 0, dbl y_ = 0): x(x_), y(y_) {}",
            "};",
            "inline num operator+(num a, num b) {",
            "\treturn num(a.x + b.x, a.y + b.y);",
            "}",
            "inline num operator-(num a, num b) {",
            "\treturn num(a.x - b.x, a.y - b.y);",
            "}",
            "inline num operator*(num a, num b) {",
            "\treturn num(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);",
            "}",
            "inline num conj(num a) { return num(a.x, -a.y); }",
            "inline num inv(num a) {",
            "\tdbl n = (a.x * a.x + a.y * a.y);",
            "\treturn num(a.x / n, -a.y / n);",
            "}",
            "#else",
            "// NTT",
            "const int mod = 998244353, g = 3;",
            "// For p < 2^30 there is also (5 << 25, 3), (7 << 26, 3),",
            "// (479 << 21, 3) and (483 << 21, 5). Last two are > 10^9.",
            "struct num {",
            "\tint v;",
            "\tnum(ll v_ = 0): v(int(v_ % mod)) {",
            "\t\tif (v < 0) v += mod;",
            "\t}",
            "\texplicit operator int() const { return v; }",
            "};",
            "inline num operator+(num a, num b) { return num(a.v + b.v); }",
            "inline num operator-(num a, num b) {",
            "\treturn num(a.v + mod - b.v);",
            "}",
            "inline num operator*(num a, num b) {",
            "\treturn num(1ll * a.v * b.v);",
            "}",
            "inline num pow(num a, int b) {",
            "\tnum r = 1;",
            "\tdo {",
            "\t\tif (b & 1) r = r * a;",
            "\t\ta = a * a;",
            "\t} while (b >>= 1);",
            "\treturn r;",
            "}",
            "inline num inv(num a) { return pow(a, mod - 2); }",
            "#endif",
            "using vn = vector<num>;",
            "vi rev({0, 1});",
            "vn rt(2, num(1)), fa, fb;",
            "inline void init(int n) {",
            "\tif (n <= sz(rt)) return;",
            "\trev.resize(n);",
            "\trep(i, 0, n) rev[i] = (rev[i >> 1] | ((i & 1) * n)) >> 1;",
            "\trt.reserve(n);",
            "\tfor (int k = sz(rt); k < n; k *= 2) {",
            "\t\trt.resize(2 * k);",
            "#if FFT",
            "\t\tdouble a = M_PI / k;",
            "\t\tnum z(cos(a), sin(a)); // FFT",
            "#else",
            "\t\tnum z = pow(num(g), (mod - 1) / (2 * k)); // NTT",
            "#endif",
            "\t\trep(i, k / 2, k) rt[2 * i] = rt[i],",
            "\t\t\t\t\t\t\t\t\t\t\t\t\t\trt[2 * i + 1] = rt[i] * z;",
            "\t}",
            "}",
            "inline void fft(vector<num>& a, int n) {",
            "\tinit(n);",
            "\tint s = __builtin_ctz(sz(rev) / n);",
            "\trep(i, 0, n) if (i < rev[i] >> s) swap(a[i], a[rev[i] >> s]);",
            "\tfor (int k = 1; k < n; k *= 2)",
            "\t\tfor (int i = 0; i < n; i += 2 * k) rep(j, 0, k) {",
            "\t\t\t\tnum t = rt[j + k] * a[i + j + k];",
            "\t\t\t\ta[i + j + k] = a[i + j] - t;",
            "\t\t\t\ta[i + j] = a[i + j] + t;",
            "\t\t\t}",
            "}",
            "// Complex/NTT",
            "vn multiply(vn a, vn b) {",
            "\tint s = sz(a) + sz(b) - 1;",
            "\tif (s <= 0) return {};",
            "\tint L = s > 1 ? 32 - __builtin_clz(s - 1) : 0, n = 1 << L;",
            "\ta.resize(n), b.resize(n);",
            "\tfft(a, n);",
            "\tfft(b, n);",
            "\tnum d = inv(num(n));",
            "\trep(i, 0, n) a[i] = a[i] * b[i] * d;",
            "\treverse(a.begin() + 1, a.end());",
            "\tfft(a, n);",
            "\ta.resize(s);",
            "\treturn a;",
            "}",
            "// Complex/NTT power-series inverse",
            "// Doubles b as b[:n] = (2 - a[:n] * b[:n/2]) * b[:n/2]",
            "vn inverse(const vn& a) {",
            "\tif (a.empty()) return {};",
            "\tvn b({inv(a[0])});",
            "\tb.reserve(2 * a.size());",
            "\twhile (sz(b) < sz(a)) {",
            "\t\tint n = 2 * sz(b);",
            "\t\tb.resize(2 * n, 0);",
            "\t\tif (sz(fa) < 2 * n) fa.resize(2 * n);",
            "\t\tfill(fa.begin(), fa.begin() + 2 * n, 0);",
            "\t\tcopy(a.begin(), a.begin() + min(n, sz(a)), fa.begin());",
            "\t\tfft(b, 2 * n);",
            "\t\tfft(fa, 2 * n);",
            "\t\tnum d = inv(num(2 * n));",
            "\t\trep(i, 0, 2 * n) b[i] = b[i] * (2 - fa[i] * b[i]) * d;",
            "\t\treverse(b.begin() + 1, b.end());",
            "\t\tfft(b, 2 * n);",
            "\t\tb.resize(n);",
            "\t}",
            "\tb.resize(a.size());",
            "\treturn b;",
            "}",
            "#if FFT",
            "// Double multiply (num = complex)",
            "using vd = vector<double>;",
            "vd multiply(const vd& a, const vd& b) {",
            "\tint s = sz(a) + sz(b) - 1;",
            "\tif (s <= 0) return {};",
            "\tint L = s > 1 ? 32 - __builtin_clz(s - 1) : 0, n = 1 << L;",
            "\tif (sz(fa) < n) fa.resize(n);",
            "\tif (sz(fb) < n) fb.resize(n);",
            "\tfill(fa.begin(), fa.begin() + n, 0);",
            "\trep(i, 0, sz(a)) fa[i].x = a[i];",
            "\trep(i, 0, sz(b)) fa[i].y = b[i];",
            "\tfft(fa, n);",
            "\ttrav(x, fa) x = x * x;",
            "\trep(i, 0, n) fb[i] = fa[(n - i) & (n - 1)] - conj(fa[i]);",
            "\tfft(fb, n);",
            "\tvd r(s);",
            "\trep(i, 0, s) r[i] = fb[i].y / (4 * n);",
            "\treturn r;",
            "}",
            "// Integer multiply mod m (num = complex)",
            "vi multiply_mod(const vi& a, const vi& b, int m) {",
            "\tint s = sz(a) + sz(b) - 1;",
            "\tif (s <= 0) return {};",
            "\tint L = s > 1 ? 32 - __builtin_clz(s - 1) : 0, n = 1 << L;",
            "\tif (sz(fa) < n) fa.resize(n);",
            "\tif (sz(fb) < n) fb.resize(n);",
            "\trep(i, 0, sz(a)) fa[i] =",
            "\t\tnum(a[i] & ((1 << 15) - 1), a[i] >> 15);",
            "\tfill(fa.begin() + sz(a), fa.begin() + n, 0);",
            "\trep(i, 0, sz(b)) fb[i] =",
            "\t\tnum(b[i] & ((1 << 15) - 1), b[i] >> 15);",
            "\tfill(fb.begin() + sz(b), fb.begin() + n, 0);",
            "\tfft(fa, n);",
            "\tfft(fb, n);",
            "\tdouble r0 = 0.5 / n; // 1/2n",
            "\trep(i, 0, n / 2 + 1) {",
            "\t\tint j = (n - i) & (n - 1);",
            "\t\tnum g0 = (fb[i] + conj(fb[j])) * r0;",
            "\t\tnum g1 = (fb[i] - conj(fb[j])) * r0;",
            "\t\tswap(g1.x, g1.y);",
            "\t\tg1.y *= -1;",
            "\t\tif (j != i) {",
            "\t\t\tswap(fa[j], fa[i]);",
            "\t\t\tfb[j] = fa[j] * g1;",
            "\t\t\tfa[j] = fa[j] * g0;",
            "\t\t}",
            "\t\tfb[i] = fa[i] * conj(g1);",
            "\t\tfa[i] = fa[i] * conj(g0);",
            "\t}",
            "\tfft(fa, n);",
            "\tfft(fb, n);",
            "\tvi r(s);",
            "\trep(i, 0, s) r[i] =",
            "\t\tint((ll(fa[i].x + 0.5) + (ll(fa[i].y + 0.5) % m << 15) +",
            "\t\t\t\t\t(ll(fb[i].x + 0.5) % m << 15) +",
            "\t\t\t\t\t(ll(fb[i].y + 0.5) % m << 30)) %",
            "\t\t\tm);",
            "\treturn r;",
            "}",
            "#endif",
            "} // namespace fft",
            "// For multiply_mod, use num = modnum, poly = vector<num>",
            "using fft::num;",
            "using poly = fft::vn;",
            "using fft::multiply;",
            "using fft::inverse;",
            "poly& operator+=(poly& a, const poly& b) {",
            "\tif (sz(a) < sz(b)) a.resize(b.size());",
            "\trep(i, 0, sz(b)) a[i] = a[i] + b[i];",
            "\treturn a;",
            "}",
            "poly operator+(const poly& a, const poly& b) {",
            "\tpoly r = a;",
            "\tr += b;",
            "\treturn r;",
            "}",
            "poly& operator-=(poly& a, const poly& b) {",
            "\tif (sz(a) < sz(b)) a.resize(b.size());",
            "\trep(i, 0, sz(b)) a[i] = a[i] - b[i];",
            "\treturn a;",
            "}",
            "poly operator-(const poly& a, const poly& b) {",
            "\tpoly r = a;",
            "\tr -= b;",
            "\treturn r;",
            "}",
            "poly operator*(const poly& a, const poly& b) {",
            "\t// TODO: small-case?",
            "\treturn multiply(a, b);",
            "}",
            "poly& operator*=(poly& a, const poly& b) { return a = a * b; }",
            "poly& operator*=(poly& a, const num& b) { // Optional",
            "\ttrav(x, a) x = x * b;",
            "\treturn a;",
            "}",
            "poly operator*(const poly& a, const num& b) {",
            "\tpoly r = a;",
            "\tr *= b;",
            "\treturn r;",
            "}",
            "// Polynomial floor division; no leading 0's plz",
            "poly operator/(poly a, poly b) {",
            "\tif (sz(a) < sz(b)) return {};",
            "\tint s = sz(a) - sz(b) + 1;",
            "\treverse(a.begin(), a.end());",
            "\treverse(b.begin(), b.end());",
            "\ta.resize(s);",
            "\tb.resize(s);",
            "\ta = a * inverse(move(b));",
            "\ta.resize(s);",
            "\treverse(a.begin(), a.end());",
            "\treturn a;",
            "}",
            "poly& operator/=(poly& a, const poly& b) { return a = a / b; }",
            "poly& operator%=(poly& a, const poly& b) {",
            "\tif (sz(a) >= sz(b)) {",
            "\t\tpoly c = (a / b) * b;",
            "\t\ta.resize(sz(b) - 1);",
            "\t\trep(i, 0, sz(a)) a[i] = a[i] - c[i];",
            "\t}",
            "\treturn a;",
            "}",
            "poly operator%(const poly& a, const poly& b) {",
            "\tpoly r = a;",
            "\tr %= b;",
            "\treturn r;",
            "}",
            "// Log/exp/pow",
            "poly deriv(const poly& a) {",
            "\tif (a.empty()) return {};",
            "\tpoly b(sz(a) - 1);",
            "\trep(i, 1, sz(a)) b[i - 1] = a[i] * i;",
            "\treturn b;",
            "}",
            "poly integ(const poly& a) {",
            "\tpoly b(sz(a) + 1);",
            "\tb[1] = 1; // mod p",
            "\trep(i, 2, sz(b)) b[i] =",
            "\t\tb[fft::mod % i] * (-fft::mod / i); // mod p",
            "\trep(i, 1, sz(b)) b[i] = a[i - 1] * b[i]; // mod p",
            "\t//rep(i,1,sz(b)) b[i]=a[i-1]*inv(num(i)); // else",
            "\treturn b;",
            "}",
            "poly log(const poly& a) { // a[0] == 1",
            "\tpoly b = integ(deriv(a) * inverse(a));",
            "\tb.resize(a.size());",
            "\treturn b;",
            "}",
            "poly exp(const poly& a) { // a[0] == 0",
            "\tpoly b(1, num(1));",
            "\tif (a.empty()) return b;",
            "\twhile (sz(b) < sz(a)) {",
            "\t\tint n = min(sz(b) * 2, sz(a));",
            "\t\tb.resize(n);",
            "\t\tpoly v = poly(a.begin(), a.begin() + n) - log(b);",
            "\t\tv[0] = v[0] + num(1);",
            "\t\tb *= v;",
            "\t\tb.resize(n);",
            "\t}",
            "\treturn b;",
            "}",
            "poly pow(const poly& a, int m) { // m >= 0",
            "\tpoly b(a.size());",
            "\tif (!m) {",
            "\t\tb[0] = 1;",
            "\t\treturn b;",
            "\t}",
            "\tint p = 0;",
            "\twhile (p < sz(a) && a[p].v == 0) ++p;",
            "\tif (1ll * m * p >= sz(a)) return b;",
            "\tnum mu = pow(a[p], m), di = inv(a[p]);",
            "\tpoly c(sz(a) - m * p);",
            "\trep(i, 0, sz(c)) c[i] = a[i + p] * di;",
            "\tc = log(c);",
            "\ttrav(v, c) v = v * m;",
            "\tc = exp(c);",
            "\trep(i, 0, sz(c)) b[i + m * p] = c[i] * mu;",
            "\treturn b;",
            "}",
            "// Multipoint evaluation/interpolation",
            "vector<num> eval(const poly& a, const vector<num>& x) {",
            "\tint n = sz(x);",
            "\tif (!n) return {};",
            "\tvector<poly> up(2 * n);",
            "\trep(i, 0, n) up[i + n] = poly({0 - x[i], 1});",
            "\tper(i, 1, n) up[i] = up[2 * i] * up[2 * i + 1];",
            "\tvector<poly> down(2 * n);",
            "\tdown[1] = a % up[1];",
            "\trep(i, 2, 2 * n) down[i] = down[i / 2] % up[i];",
            "\tvector<num> y(n);",
            "\trep(i, 0, n) y[i] = down[i + n][0];",
            "\treturn y;",
            "}",
            "poly interp(const vector<num>& x, const vector<num>& y) {",
            "\tint n = sz(x);",
            "\tassert(n);",
            "\tvector<poly> up(n * 2);",
            "\trep(i, 0, n) up[i + n] = poly({0 - x[i], 1});",
            "\tper(i, 1, n) up[i] = up[2 * i] * up[2 * i + 1];",
            "\tvector<num> a = eval(deriv(up[1]), x);",
            "\tvector<poly> down(2 * n);",
            "\trep(i, 0, n) down[i + n] = poly({y[i] * inv(a[i])});",
            "\tper(i, 1, n) down[i] =",
            "\t\tdown[i * 2] * up[i * 2 + 1] + down[i * 2 + 1] * up[i * 2];",
            "\treturn down[1];",
            "}"
        ],
        "description": "FFT/NTT, polynomial mod/log/exp",
        "prefix": [
            "hack_mitfft"
        ]
    },
    "mitlineIntersection.h": {
        "body": [
            "template<class P>",
            "int lineIntersection(const P& s1, const P& e1, const P& s2,",
            "\tconst P& e2, P& r) {",
            "\tif ((e1 - s1).cross(e2 - s2)) { //if not parallell",
            "\t\tr = s2 -",
            "\t\t\t(e2 - s2) * (e1 - s1).cross(s2 - s1) /",
            "\t\t\t\t(e1 - s1).cross(e2 - s2);",
            "\t\treturn 1;",
            "\t} else return -((e1 - s1).cross(s2 - s1) == 0 || s2 == e2);",
            "}"
        ],
        "description": "If a unique intersection point of the lines going through s1,e1 and s2,e2 exists r is set to this point and 1 is returned. If no intersection point exists 0 is returned and if infinitely many exists -1 is returned. If s1==e1 or s2==e2 -1 is returned. The wrong position will be returned if P is Point<int> and the intersection point does not have integer coordinates. Products of three coordinates are used in intermediate steps so watch out for overflow if using int or long long.",
        "prefix": [
            "hack_mitlineIntersection"
        ]
    },
    "multinomial.h": {
        "body": [
            "ll multinomial(vi& v) {",
            "\tll c = 1, m = v.empty() ? 1 : v[0];",
            "\trep(i, 1, sz(v)) rep(j, 0, v[i]) c = c * ++m / (j + 1);",
            "\treturn c;",
            "}"
        ],
        "description": "Computes $\\displaystyle \\binom{k_1 + \\dots + k_n}{k_1, k_2, \\dots, k_n} = \\frac{(\\sum k_i)!}{k_1!k_2!...k_n!}$.",
        "prefix": [
            "hack_multinomial"
        ]
    },
    "phiFunction.h": {
        "body": [
            "const int LIM = 5000000;",
            "int phi[LIM];",
            "void calculatePhi() {",
            "\trep(i, 0, LIM) phi[i] = i & 1 ? i : i / 2;",
            "\tfor (int i = 3; i < LIM; i += 2)",
            "\t\tif (phi[i] == i)",
            "\t\t\tfor (int j = i; j < LIM; j += i) phi[j] -= phi[j] / i;",
            "}"
        ],
        "description": "\\emph{Euler's $\\phi$} function is defined as $\\phi(n):=\\#$ of positive integers $\\leq n$ that are coprime with $n$.\n$\\phi(1)=1$, $p$ prime $\\Rightarrow \\phi(p^k)=(p-1)p^{k-1}$, $m,n$ coprime $\\Rightarrow \\phi(mn)=\\phi(m)\\phi(n)$.\nIf $n=p_1^{k_1}p_2^{k_2} ... p_r^{k_r}$ then $\\phi(n) = (p_1-1)p_1^{k_1-1}...(p_r-1)p_r^{k_r-1}$.\n$\\phi(n)=n \\cdot \\prod_{p|n}(1-1/p)$.\n\n$\\sum_{d|n} \\phi(d) = n$, $\\sum_{1\\leq k \\leq n, \\gcd(k,n)=1} k = n \\phi(n)/2, n>1$\n\n\\textbf{Euler's thm}: $a,n$ coprime $\\Rightarrow a^{\\phi(n)} \\equiv 1 \\pmod{n}$.\n\n\\textbf{Fermat's little thm}: $p$ prime $\\Rightarrow a^{p-1} \\equiv 1 \\pmod{p}$ $\\forall a$.",
        "prefix": [
            "hack_phiFunction"
        ]
    },
    "polynomial.cpp": {
        "body": [
            "using namespace std;",
            "namespace algebra {",
            "const int inf = 1e9;",
            "const int magic =",
            "\t500; // threshold for sizes to run the naive algo",
            "namespace fft {",
            "const int maxn = 1 << 18;",
            "typedef double ftype;",
            "typedef complex<ftype> point;",
            "point w[maxn];",
            "const ftype pi = acos(-1);",
            "bool initiated = 0;",
            "void init() {",
            "\tif (!initiated) {",
            "\t\tfor (int i = 1; i < maxn; i *= 2)",
            "\t\t\tfor (int j = 0; j < i; j++)",
            "\t\t\t\tw[i + j] = polar(ftype(1), pi * j / i);",
            "\t\tinitiated = 1;",
            "\t}",
            "}",
            "template<typename T>",
            "void fft(T *in, point *out, int n, int k = 1) {",
            "\tif (n == 1) {",
            "\t\t*out = *in;",
            "\t} else {",
            "\t\tn /= 2;",
            "\t\tfft(in, out, n, 2 * k);",
            "\t\tfft(in + k, out + n, n, 2 * k);",
            "\t\tfor (int i = 0; i < n; i++) {",
            "\t\t\tauto t = out[i + n] * w[i + n];",
            "\t\t\tout[i + n] = out[i] - t;",
            "\t\t\tout[i] += t;",
            "\t\t}",
            "\t}",
            "}",
            "template<typename T>",
            "void mul_slow(vector<T> &a, const vector<T> &b) {",
            "\tvector<T> res(a.size() + b.size() - 1);",
            "\tfor (size_t i = 0; i < a.size(); i++)",
            "\t\tfor (size_t j = 0; j < b.size(); j++)",
            "\t\t\tres[i + j] += a[i] * b[j];",
            "\ta = res;",
            "}",
            "template<typename T>",
            "void mul(vector<T> &a, const vector<T> &b) {",
            "\tif (min(a.size(), b.size()) < magic) {",
            "\t\tmul_slow(a, b);",
            "\t\treturn;",
            "\t}",
            "\tinit();",
            "\tstatic const int shift = 15, mask = (1 << shift) - 1;",
            "\tsize_t n = a.size() + b.size() - 1;",
            "\twhile (__builtin_popcount(n) != 1) n++;",
            "\ta.resize(n);",
            "\tstatic point A[maxn], B[maxn];",
            "\tstatic point C[maxn], D[maxn];",
            "\tfor (size_t i = 0; i < n; i++) {",
            "\t\tA[i] = point(a[i] & mask, a[i] >> shift);",
            "\t\tif (i < b.size()) B[i] = point(b[i] & mask, b[i] >> shift);",
            "\t\telse B[i] = 0;",
            "\t}",
            "\tfft(A, C, n);",
            "\tfft(B, D, n);",
            "\tfor (size_t i = 0; i < n; i++) {",
            "\t\tpoint c0 = C[i] + conj(C[(n - i) % n]);",
            "\t\tpoint c1 = C[i] - conj(C[(n - i) % n]);",
            "\t\tpoint d0 = D[i] + conj(D[(n - i) % n]);",
            "\t\tpoint d1 = D[i] - conj(D[(n - i) % n]);",
            "\t\tA[i] = c0 * d0 - point(0, 1) * c1 * d1;",
            "\t\tB[i] = c0 * d1 + d0 * c1;",
            "\t}",
            "\tfft(A, C, n);",
            "\tfft(B, D, n);",
            "\treverse(C + 1, C + n);",
            "\treverse(D + 1, D + n);",
            "\tint t = 4 * n;",
            "\tfor (size_t i = 0; i < n; i++) {",
            "\t\tint64_t A0 = llround(real(C[i]) / t);",
            "\t\tT A1 = llround(imag(D[i]) / t);",
            "\t\tT A2 = llround(imag(C[i]) / t);",
            "\t\ta[i] = A0 + (A1 << shift) + (A2 << 2 * shift);",
            "\t}",
            "\treturn;",
            "}",
            "}",
            "template<typename T> T bpow(T x, size_t n) {",
            "\treturn n ? n % 2 ? x * bpow(x, n - 1) : bpow(x * x, n / 2)",
            "\t\t\t\t\t : T(1);",
            "}",
            "template<typename T> T bpow(T x, size_t n, T m) {",
            "\treturn n ? n % 2 ? x * bpow(x, n - 1, m) % m",
            "\t\t\t\t\t\t\t\t\t : bpow(x * x % m, n / 2, m)",
            "\t\t\t\t\t : T(1);",
            "}",
            "template<typename T> T gcd(const T &a, const T &b) {",
            "\treturn b == T(0) ? a : gcd(b, a % b);",
            "}",
            "template<typename T> T nCr(T n, int r) { // runs in O(r)",
            "\tT res(1);",
            "\tfor (int i = 0; i < r; i++) {",
            "\t\tres *= (n - T(i));",
            "\t\tres /= (i + 1);",
            "\t}",
            "\treturn res;",
            "}",
            "template<int m> struct modular {",
            "\tint64_t r;",
            "\tmodular(): r(0) {}",
            "\tmodular(int64_t rr): r(rr) {",
            "\t\tif (abs(r) >= m) r %= m;",
            "\t\tif (r < 0) r += m;",
            "\t}",
            "\tmodular inv() const { return bpow(*this, m - 2); }",
            "\tmodular operator*(const modular &t) const {",
            "\t\treturn (r * t.r) % m;",
            "\t}",
            "\tmodular operator/(const modular &t) const {",
            "\t\treturn *this * t.inv();",
            "\t}",
            "\tmodular operator+=(const modular &t) {",
            "\t\tr += t.r;",
            "\t\tif (r >= m) r -= m;",
            "\t\treturn *this;",
            "\t}",
            "\tmodular operator-=(const modular &t) {",
            "\t\tr -= t.r;",
            "\t\tif (r < 0) r += m;",
            "\t\treturn *this;",
            "\t}",
            "\tmodular operator+(const modular &t) const {",
            "\t\treturn modular(*this) += t;",
            "\t}",
            "\tmodular operator-(const modular &t) const {",
            "\t\treturn modular(*this) -= t;",
            "\t}",
            "\tmodular operator*=(const modular &t) {",
            "\t\treturn *this = *this * t;",
            "\t}",
            "\tmodular operator/=(const modular &t) {",
            "\t\treturn *this = *this / t;",
            "\t}",
            "\tbool operator==(const modular &t) const { return r == t.r; }",
            "\tbool operator!=(const modular &t) const { return r != t.r; }",
            "\toperator int64_t() const { return r; }",
            "};",
            "template<int T>",
            "istream &operator>>(istream &in, modular<T> &x) {",
            "\treturn in >> x.r;",
            "}",
            "template<typename T> struct poly {",
            "\tvector<T> a;",
            "\tvoid normalize() { // get rid of leading zeroes",
            "\t\twhile (!a.empty() && a.back() == T(0)) a.pop_back();",
            "\t}",
            "\tpoly() {}",
            "\tpoly(T a0): a{a0} { normalize(); }",
            "\tpoly(vector<T> t): a(t) { normalize(); }",
            "\tpoly operator+=(const poly &t) {",
            "\t\ta.resize(max(a.size(), t.a.size()));",
            "\t\tfor (size_t i = 0; i < t.a.size(); i++) a[i] += t.a[i];",
            "\t\tnormalize();",
            "\t\treturn *this;",
            "\t}",
            "\tpoly operator-=(const poly &t) {",
            "\t\ta.resize(max(a.size(), t.a.size()));",
            "\t\tfor (size_t i = 0; i < t.a.size(); i++) a[i] -= t.a[i];",
            "\t\tnormalize();",
            "\t\treturn *this;",
            "\t}",
            "\tpoly operator+(const poly &t) const {",
            "\t\treturn poly(*this) += t;",
            "\t}",
            "\tpoly operator-(const poly &t) const {",
            "\t\treturn poly(*this) -= t;",
            "\t}",
            "\tpoly mod_xk(size_t k) const { // get same polynomial mod x^k",
            "\t\tk = min(k, a.size());",
            "\t\treturn vector<T>(begin(a), begin(a) + k);",
            "\t}",
            "\tpoly mul_xk(size_t k) const { // multiply by x^k",
            "\t\tpoly res(*this);",
            "\t\tres.a.insert(begin(res.a), k, 0);",
            "\t\treturn res;",
            "\t}",
            "\tpoly div_xk(",
            "\t\tsize_t k) const { // divide by x^k, dropping coefficients",
            "\t\tk = min(k, a.size());",
            "\t\treturn vector<T>(begin(a) + k, end(a));",
            "\t}",
            "\tpoly substr(size_t l,",
            "\t\tsize_t r) const { // return mod_xk(r).div_xk(l)",
            "\t\tl = min(l, a.size());",
            "\t\tr = min(r, a.size());",
            "\t\treturn vector<T>(begin(a) + l, begin(a) + r);",
            "\t}",
            "\tpoly inv(size_t n) const { // get inverse series mod x^n",
            "\t\tassert(!is_zero());",
            "\t\tpoly ans = a[0].inv();",
            "\t\tsize_t a = 1;",
            "\t\twhile (a < n) {",
            "\t\t\tpoly C = (ans * mod_xk(2 * a)).substr(a, 2 * a);",
            "\t\t\tans -= (ans * C).mod_xk(a).mul_xk(a);",
            "\t\t\ta *= 2;",
            "\t\t}",
            "\t\treturn ans.mod_xk(n);",
            "\t}",
            "\tpoly operator*=(const poly &t) {",
            "\t\tfft::mul(a, t.a);",
            "\t\tnormalize();",
            "\t\treturn *this;",
            "\t}",
            "\tpoly operator*(const poly &t) const {",
            "\t\treturn poly(*this) *= t;",
            "\t}",
            "\tpoly reverse(size_t n,",
            "\t\tbool rev = 0) const { // reverses and leaves only n terms",
            "\t\tpoly res(*this);",
            "\t\tif (rev) // If rev = 1 then tail goes to head",
            "\t\t\tres.a.resize(max(n, res.a.size()));",
            "\t\tstd::reverse(res.a.begin(), res.a.end());",
            "\t\treturn res.mod_xk(n);",
            "\t}",
            "\tpair<poly, poly> divmod_slow(",
            "\t\tconst poly &b) const { // when divisor or quotient is small",
            "\t\tvector<T> A(a);",
            "\t\tvector<T> res;",
            "\t\twhile (A.size() >= b.a.size()) {",
            "\t\t\tres.push_back(A.back() / b.a.back());",
            "\t\t\tif (res.back() != T(0)) {",
            "\t\t\t\tfor (size_t i = 0; i < b.a.size(); i++) {",
            "\t\t\t\t\tA[A.size() - i - 1] -=",
            "\t\t\t\t\t\tres.back() * b.a[b.a.size() - i - 1];",
            "\t\t\t\t}",
            "\t\t\t}",
            "\t\t\tA.pop_back();",
            "\t\t}",
            "\t\tstd::reverse(begin(res), end(res));",
            "\t\treturn {res, A};",
            "\t}",
            "\tpair<poly, poly> divmod(const poly &b)",
            "\t\tconst { // returns quotiend and remainder of a mod b",
            "\t\tif (deg() < b.deg()) return {poly{0}, *this};",
            "\t\tint d = deg() - b.deg();",
            "\t\tif (min(d, b.deg()) < magic) return divmod_slow(b);",
            "\t\tpoly D = (reverse(d + 1) * b.reverse(d + 1).inv(d + 1))",
            "\t\t\t\t\t\t\t .mod_xk(d + 1)",
            "\t\t\t\t\t\t\t .reverse(d + 1, 1);",
            "\t\treturn {D, *this - D * b};",
            "\t}",
            "\tpoly operator/(const poly &t) const {",
            "\t\treturn divmod(t).first;",
            "\t}",
            "\tpoly operator%(const poly &t) const {",
            "\t\treturn divmod(t).second;",
            "\t}",
            "\tpoly operator/=(const poly &t) {",
            "\t\treturn *this = divmod(t).first;",
            "\t}",
            "\tpoly operator%=(const poly &t) {",
            "\t\treturn *this = divmod(t).second;",
            "\t}",
            "\tpoly operator*=(const T &x) {",
            "\t\tfor (auto &it : a) it *= x;",
            "\t\tnormalize();",
            "\t\treturn *this;",
            "\t}",
            "\tpoly operator/=(const T &x) {",
            "\t\tfor (auto &it : a) it /= x;",
            "\t\tnormalize();",
            "\t\treturn *this;",
            "\t}",
            "\tpoly operator*(const T &x) const { return poly(*this) *= x; }",
            "\tpoly operator/(const T &x) const { return poly(*this) /= x; }",
            "\tvoid print() const {",
            "\t\tfor (auto it : a) cout << it << ' ';",
            "\t\tcout << endl;",
            "\t}",
            "\tT eval(T x) const { // evaluates in single point x",
            "\t\tT res(0);",
            "\t\tfor (int i = int(a.size()) - 1; i >= 0; i--) {",
            "\t\t\tres *= x;",
            "\t\t\tres += a[i];",
            "\t\t}",
            "\t\treturn res;",
            "\t}",
            "\tT &lead() { // leading coefficient",
            "\t\treturn a.back();",
            "\t}",
            "\tint deg() const { // degree",
            "\t\treturn a.empty() ? -inf : a.size() - 1;",
            "\t}",
            "\tbool is_zero() const { // is polynomial zero",
            "\t\treturn a.empty();",
            "\t}",
            "\tT operator[](int idx) const {",
            "\t\treturn idx >= (int)a.size() || idx < 0 ? T(0) : a[idx];",
            "\t}",
            "\tT &coef(size_t idx) { // mutable reference at coefficient",
            "\t\treturn a[idx];",
            "\t}",
            "\tbool operator==(const poly &t) const { return a == t.a; }",
            "\tbool operator!=(const poly &t) const { return a != t.a; }",
            "\tpoly deriv() { // calculate derivative",
            "\t\tvector<T> res;",
            "\t\tfor (int i = 1; i <= deg(); i++)",
            "\t\t\tres.push_back(T(i) * a[i]);",
            "\t\treturn res;",
            "\t}",
            "\tpoly integr() { // calculate integral with C = 0",
            "\t\tvector<T> res = {0};",
            "\t\tfor (int i = 0; i <= deg(); i++)",
            "\t\t\tres.push_back(a[i] / T(i + 1));",
            "\t\treturn res;",
            "\t}",
            "\tsize_t leading_xk()",
            "\t\tconst { // Let p(x) = x^k * t(x), return k",
            "\t\tif (is_zero()) return inf;",
            "\t\tint res = 0;",
            "\t\twhile (a[res] == T(0)) res++;",
            "\t\treturn res;",
            "\t}",
            "\tpoly log(size_t n) { // calculate log p(x) mod x^n",
            "\t\tassert(a[0] == T(1));",
            "\t\treturn (deriv().mod_xk(n) * inv(n)).integr().mod_xk(n);",
            "\t}",
            "\tpoly exp(size_t n) { // calculate exp p(x) mod x^n",
            "\t\tif (is_zero()) return T(1);",
            "\t\tassert(a[0] == T(0));",
            "\t\tpoly ans = T(1);",
            "\t\tsize_t a = 1;",
            "\t\twhile (a < n) {",
            "\t\t\tpoly C = ans.log(2 * a).div_xk(a) - substr(a, 2 * a);",
            "\t\t\tans -= (ans * C).mod_xk(a).mul_xk(a);",
            "\t\t\ta *= 2;",
            "\t\t}",
            "\t\treturn ans.mod_xk(n);",
            "\t}",
            "\tpoly pow_slow(size_t k, size_t n) { // if k is small",
            "\t\treturn k ? k % 2",
            "\t\t\t\t? (*this * pow_slow(k - 1, n)).mod_xk(n)",
            "\t\t\t\t: (*this * *this).mod_xk(n).pow_slow(k / 2, n)",
            "\t\t\t\t\t\t : T(1);",
            "\t}",
            "\tpoly pow(size_t k, size_t n) { // calculate p^k(n) mod x^n",
            "\t\tif (is_zero()) return *this;",
            "\t\tif (k < magic) return pow_slow(k, n);",
            "\t\tint i = leading_xk();",
            "\t\tT j = a[i];",
            "\t\tpoly t = div_xk(i) / j;",
            "\t\treturn bpow(j, k) *",
            "\t\t\t(t.log(n) * T(k)).exp(n).mul_xk(i * k).mod_xk(n);",
            "\t}",
            "\tpoly mulx(T x) { // component-wise multiplication with x^k",
            "\t\tT cur = 1;",
            "\t\tpoly res(*this);",
            "\t\tfor (int i = 0; i <= deg(); i++) {",
            "\t\t\tres.coef(i) *= cur;",
            "\t\t\tcur *= x;",
            "\t\t}",
            "\t\treturn res;",
            "\t}",
            "\tpoly mulx_sq(",
            "\t\tT x) { // component-wise multiplication with x^{k^2}",
            "\t\tT cur = x;",
            "\t\tT total = 1;",
            "\t\tT xx = x * x;",
            "\t\tpoly res(*this);",
            "\t\tfor (int i = 0; i <= deg(); i++) {",
            "\t\t\tres.coef(i) *= total;",
            "\t\t\ttotal *= cur;",
            "\t\t\tcur *= xx;",
            "\t\t}",
            "\t\treturn res;",
            "\t}",
            "\tvector<T> chirpz_even(T z,",
            "\t\tint n) { // P(1), P(z^2), P(z^4), ..., P(z^2(n-1))",
            "\t\tint m = deg();",
            "\t\tif (is_zero()) return vector<T>(n, 0);",
            "\t\tvector<T> vv(m + n);",
            "\t\tT zi = z.inv();",
            "\t\tT zz = zi * zi;",
            "\t\tT cur = zi;",
            "\t\tT total = 1;",
            "\t\tfor (int i = 0; i <= max(n - 1, m); i++) {",
            "\t\t\tif (i <= m) vv[m - i] = total;",
            "\t\t\tif (i < n) vv[m + i] = total;",
            "\t\t\ttotal *= cur;",
            "\t\t\tcur *= zz;",
            "\t\t}",
            "\t\tpoly w = (mulx_sq(z) * vv).substr(m, m + n).mulx_sq(z);",
            "\t\tvector<T> res(n);",
            "\t\tfor (int i = 0; i < n; i++) res[i] = w[i];",
            "\t\treturn res;",
            "\t}",
            "\tvector<T> chirpz(T z,",
            "\t\tint n) { // P(1), P(z), P(z^2), ..., P(z^(n-1))",
            "\t\tauto even = chirpz_even(z, (n + 1) / 2);",
            "\t\tauto odd = mulx(z).chirpz_even(z, n / 2);",
            "\t\tvector<T> ans(n);",
            "\t\tfor (int i = 0; i < n / 2; i++) {",
            "\t\t\tans[2 * i] = even[i];",
            "\t\t\tans[2 * i + 1] = odd[i];",
            "\t\t}",
            "\t\tif (n % 2 == 1) ans[n - 1] = even.back();",
            "\t\treturn ans;",
            "\t}",
            "\ttemplate<typename iter>",
            "\tvector<T> eval(vector<poly> &tree, int v, iter l,",
            "\t\titer r) { // auxiliary evaluation function",
            "\t\tif (r - l == 1) {",
            "\t\t\treturn {eval(*l)};",
            "\t\t} else {",
            "\t\t\tauto m = l + (r - l) / 2;",
            "\t\t\tauto A = (*this % tree[2 * v]).eval(tree, 2 * v, l, m);",
            "\t\t\tauto B =",
            "\t\t\t\t(*this % tree[2 * v + 1]).eval(tree, 2 * v + 1, m, r);",
            "\t\t\tA.insert(end(A), begin(B), end(B));",
            "\t\t\treturn A;",
            "\t\t}",
            "\t}",
            "\tvector<T> eval(",
            "\t\tvector<T> x) { // evaluate polynomial in (x1, ..., xn)",
            "\t\tint n = x.size();",
            "\t\tif (is_zero()) return vector<T>(n, T(0));",
            "\t\tvector<poly> tree(4 * n);",
            "\t\tbuild(tree, 1, begin(x), end(x));",
            "\t\treturn eval(tree, 1, begin(x), end(x));",
            "\t}",
            "\ttemplate<typename iter>",
            "\tpoly inter(vector<poly> &tree, int v, iter l, iter r,",
            "\t\titer ly, iter ry) { // auxiliary interpolation function",
            "\t\tif (r - l == 1) {",
            "\t\t\treturn {*ly / a[0]};",
            "\t\t} else {",
            "\t\t\tauto m = l + (r - l) / 2;",
            "\t\t\tauto my = ly + (ry - ly) / 2;",
            "\t\t\tauto A =",
            "\t\t\t\t(*this % tree[2 * v]).inter(tree, 2 * v, l, m, ly, my);",
            "\t\t\tauto B = (*this % tree[2 * v + 1])",
            "\t\t\t\t\t\t\t\t .inter(tree, 2 * v + 1, m, r, my, ry);",
            "\t\t\treturn A * tree[2 * v + 1] + B * tree[2 * v];",
            "\t\t}",
            "\t}",
            "};",
            "template<typename T>",
            "poly<T> operator*(const T &a, const poly<T> &b) {",
            "\treturn b * a;",
            "}",
            "template<typename T> poly<T> xk(int k) { // return x^k",
            "\treturn poly<T>{1}.mul_xk(k);",
            "}",
            "template<typename T>",
            "T resultant(poly<T> a,",
            "\tpoly<T> b) { // computes resultant of a and b",
            "\tif (b.is_zero()) {",
            "\t\treturn 0;",
            "\t} else if (b.deg() == 0) {",
            "\t\treturn bpow(b.lead(), a.deg());",
            "\t} else {",
            "\t\tint pw = a.deg();",
            "\t\ta %= b;",
            "\t\tpw -= a.deg();",
            "\t\tT mul =",
            "\t\t\tbpow(b.lead(), pw) * T((b.deg() & a.deg() & 1) ? -1 : 1);",
            "\t\tT ans = resultant(b, a);",
            "\t\treturn ans * mul;",
            "\t}",
            "}",
            "template<typename iter>",
            "poly<typename iter::value_type> kmul(iter L,",
            "\titer",
            "\t\tR) { // computes (x-a1)(x-a2)...(x-an) without building tree",
            "\tif (R - L == 1) {",
            "\t\treturn vector<typename iter::value_type>{-*L, 1};",
            "\t} else {",
            "\t\titer M = L + (R - L) / 2;",
            "\t\treturn kmul(L, M) * kmul(M, R);",
            "\t}",
            "}",
            "template<typename T, typename iter>",
            "poly<T> build(vector<poly<T>> &res, int v, iter L,",
            "\titer R) { // builds evaluation tree for (x-a1)(x-a2)...(x-an)",
            "\tif (R - L == 1) {",
            "\t\treturn res[v] = vector<T>{-*L, 1};",
            "\t} else {",
            "\t\titer M = L + (R - L) / 2;",
            "\t\treturn res[v] = build(res, 2 * v, L, M) *",
            "\t\t\tbuild(res, 2 * v + 1, M, R);",
            "\t}",
            "}",
            "template<typename T>",
            "poly<T> inter(vector<T> x,",
            "\tvector<T>",
            "\t\ty) { // interpolates minimum polynomial from (xi, yi) pairs",
            "\tint n = x.size();",
            "\tvector<poly<T>> tree(4 * n);",
            "\treturn build(tree, 1, begin(x), end(x))",
            "\t\t.deriv()",
            "\t\t.inter(tree, 1, begin(x), end(x), begin(y), end(y));",
            "}",
            "};",
            "using namespace algebra;",
            "const int mod = 1e9 + 7;",
            "typedef modular<mod> base;",
            "typedef poly<base> polyn;",
            "using namespace algebra;",
            "signed main() {",
            "\tios::sync_with_stdio(0);",
            "\tcin.tie(0);",
            "\tint n = 100000;",
            "\tpolyn a;",
            "\tvector<base> x;",
            "\tfor (int i = 0; i <= n; i++) {",
            "\t\ta.a.push_back(1 + rand() % 100);",
            "\t\tx.push_back(1 + rand() % (2 * n));",
            "\t}",
            "\tsort(begin(x), end(x));",
            "\tx.erase(unique(begin(x), end(x)), end(x));",
            "\tauto b = a.eval(x);",
            "\tcout << clock() / double(CLOCKS_PER_SEC) << endl;",
            "\tauto c = inter(x, b);",
            "\tpolyn md = kmul(begin(x), end(x));",
            "\tcout << clock() / double(CLOCKS_PER_SEC) << endl;",
            "\tassert(c == a % md);",
            "\treturn 0;",
            "}"
        ],
        "prefix": [
            "hack_polynomial"
        ]
    },
    "schreier-sims.cpp": {
        "body": [
            "struct Perm {",
            "\tint a[N];",
            "\tPerm() {",
            "\t\tfor (int i = 1; i <= n; ++i) a[i] = i;",
            "\t}",
            "\tfriend Perm operator*(const Perm &lhs, const Perm &rhs) {",
            "\t\tstatic Perm res;",
            "\t\tfor (int i = 1; i <= n; ++i) res.a[i] = lhs.a[rhs.a[i]];",
            "\t\treturn res;",
            "\t}",
            "\tfriend Perm inv(const Perm &cur) {",
            "\t\tstatic Perm res;",
            "\t\tfor (int i = 1; i <= n; ++i) res.a[cur.a[i]] = i;",
            "\t\treturn res;",
            "\t}",
            "};",
            "class Group {",
            "\tbool flag[N];",
            "\tPerm w[N];",
            "\tstd::vector<Perm> x;",
            "public:",
            "\tvoid clear(int p) {",
            "\t\tmemset(flag, 0, sizeof flag);",
            "\t\tfor (int i = 1; i <= n; ++i) w[i] = Perm();",
            "\t\tflag[p] = true;",
            "\t\tx.clear();",
            "\t}",
            "\tfriend bool check(const Perm &, int);",
            "\tfriend void insert(const Perm &, int);",
            "\tfriend void updateX(const Perm &, int);",
            "} g[N];",
            "bool check(const Perm &cur, int k) {",
            "\tif (!k) return true;",
            "\tint t = cur.a[k];",
            "\treturn g[k].flag[t] ? check(g[k].w[t] * cur, k - 1) : false;",
            "}",
            "void updateX(const Perm &, int);",
            "void insert(const Perm &cur, int k) {",
            "\tif (check(cur, k)) return;",
            "\tg[k].x.push_back(cur);",
            "\tfor (int i = 1; i <= n; ++i)",
            "\t\tif (g[k].flag[i]) updateX(cur * inv(g[k].w[i]), k);",
            "}",
            "void updateX(const Perm &cur, int k) {",
            "\tint t = cur.a[k];",
            "\tif (g[k].flag[t]) {",
            "\t\tinsert(g[k].w[t] * cur, k - 1);",
            "\t} else {",
            "\t\tg[k].w[t] = inv(cur);",
            "\t\tg[k].flag[t] = true;",
            "\t\tfor (int i = 0; i < g[k].x.size(); ++i)",
            "\t\t\tupdateX(g[k].x[i] * cur, k);",
            "\t}",
            "}"
        ],
        "description": "Check group membership of permutation groups",
        "prefix": [
            "hack_schreier-sims"
        ]
    },
    "sideOf.h": {
        "body": [
            "template<class P> int sideOf(P s, P e, P p) {",
            "\treturn sgn(s.cross(e, p));",
            "}",
            "template<class P>",
            "int sideOf(const P& s, const P& e, const P& p, double eps) {",
            "\tauto a = (e - s).cross(p - s);",
            "\tdouble l = (e - s).dist() * eps;",
            "\treturn (a > l) - (a < -l);",
            "}"
        ],
        "description": "Returns where $p$ is as seen from $s$ towards $e$. 1/0/-1 $\\Leftrightarrow$ left/on line/right. If the optional argument $eps$ is given 0 is returned if $p$ is within distance $eps$ from the line. P is supposed to be Point<T> where T is e.g. double or long long. It uses products in intermediate steps so watch out for overflow if using int or long long.",
        "prefix": [
            "hack_sideOf"
        ]
    },
    "sphericalDistance.h": {
        "body": [
            "double sphericalDistance(double f1, double t1, double f2,",
            "\tdouble t2, double radius) {",
            "\tdouble dx = sin(t2) * cos(f2) - sin(t1) * cos(f1);",
            "\tdouble dy = sin(t2) * sin(f2) - sin(t1) * sin(f1);",
            "\tdouble dz = cos(t2) - cos(t1);",
            "\tdouble d = sqrt(dx * dx + dy * dy + dz * dz);",
            "\treturn radius * 2 * asin(d / 2);",
            "}"
        ],
        "description": "Returns the shortest distance on the sphere with radius radius between the points with azimuthal angles (longitude) f1 ($\\phi_1$) and f2 ($\\phi_2$) from x axis and zenith angles (latitude) t1 ($\\theta_1$) and t2 ($\\theta_2$) from z axis (0 = north pole). All angles measured in radians. The algorithm starts by converting the spherical coordinates to cartesian coordinates so if that is what you have you can use only the two last rows. dx*radius is then the difference between the two points in the x direction and d*radius is the total distance between the points.",
        "prefix": [
            "hack_sphericalDistance"
        ]
    },
    "stackhack.cpp": {
        "body": [
            "/*",
            "\tstackhack.cpp",
            "\tUse this shit when sparta is being annoying",
            "*/",
            "int main(void) {",
            "\tconst rlim_t kStackSize = 1024 * 1024 * 1024;",
            "\tstruct rlimit rl;",
            "\tint result;",
            "\tresult = getrlimit(RLIMIT_STACK, &rl);",
            "\tif (result == 0) {",
            "\t\t// std::cerr << rl.rlim_cur << std::endl;",
            "\t\tif (rl.rlim_cur < kStackSize) {",
            "\t\t\trl.rlim_cur = kStackSize;",
            "\t\t\tresult = setrlimit(RLIMIT_STACK, &rl);",
            "\t\t\t// if (result != 0)",
            "\t\t\t// \tstd::cerr << \"setrlimit returned result = \" << result << \"\\n\";",
            "\t\t}",
            "\t}",
            "\treturn 0;",
            "}"
        ],
        "prefix": [
            "hack_stackhack"
        ]
    },
    "template.cpp": {
        "body": [
            "using namespace std;",
            "#define rep(i, a, b) for (int i = a; i < (b); ++i)",
            "#define all(x) begin(x), end(x)",
            "#define sz(x) (int)(x).size()",
            "using ll = long long;",
            "using pii = pair<int, int>;",
            "using vi = vector<int>;",
            "int main() {",
            "\tcin.tie(0)->sync_with_stdio(0);",
            "\tcin.exceptions(cin.failbit);",
            "}"
        ],
        "prefix": [
            "hack_template"
        ]
    }
}