{
	// Place your CP workspace snippets here. Each snippet is defined under a snippet name and has a scope, prefix, body and 
	// description. Add comma separated ids of the languages where the snippet is applicable in the scope field. If scope 
	// is left empty or omitted, the snippet gets applied to all languages. The prefix is what is 
	// used to trigger the snippet and the body will be expanded and inserted. Possible variables are: 
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. 
	// Placeholders with the same ids are connected.
	// Example:
	// "Print to console": {
	// \t"scope": "javascript,typescript",
	// \t"prefix": "log",
	// \t"body": [
	// \t\t"console.log('$1');",
	// \t\t"$2"
	// \t],
	// \t"description": "Log output to console"
	// }


	"RecursiveSegtree.cpp": {
	"prefix": "hack_RecursiveSegtree",
	"body": [
	"struct SegmentTree {",
	"\t// TO CHANGE",
	"",
	"\tstruct Node { // set default values",
	"\t\t..",
	"$1",
	"\t\ttemplate<typename T>",
	"\t\tvoid apply(int l, int r, T val) { // update value and save push",
	"\t\t\t$2...",
	"\t\t}",
	"\t};",
	"",
	"\tNode merge(const Node& left, const Node& right) {",
	"\t\t$3...",
	"\t}",
	"",
	"\tvoid push(int v, int l, int r) {",
	"\t\tif (tree[v].??? != $4...) {",
	"\t\t\tint mid = (r + l) >> 1;",
	"\t\t\tint vl = v + 1, vr = v + ((mid - l) << 1);",
	"\t\t\ttree[vl].apply(l, mid, tree[v].???);",
	"\t\t\ttree[vr].apply(mid, r, tree[v].???);",
	"\t\t\ttree[v].??? = $5...;",
	"\t\t}",
	"\t}",
	"",
	"\t// DEFAULT PART",
	"",
	"\tvector<Node> tree;",
	"\tint n;",
	"",
	"\ttemplate<typename T>",
	"\tvoid build(int v, int l, int r, const vector<T>& arr) {",
	"\t\tif (l + 1 == r) {",
	"\t\t\ttree[v].apply(l, r, arr[l]);",
	"\t\t\treturn;",
	"\t\t}",
	"\t\tint mid = (r + l) >> 1;",
	"\t\tint vl = v + 1, vr = v + ((mid - l) << 1);",
	"\t\tbuild(vl, l, mid, arr);",
	"\t\tbuild(vr, mid, r, arr);",
	"\t\ttree[v] = merge(tree[vl], tree[vr]);",
	"\t}",
	"",
	"\tvoid build(int v, int l, int r) {",
	"\t\tif (l + 1 == r) {",
	"\t\t\treturn;",
	"\t\t}",
	"\t\tint mid = (r + l) >> 1;",
	"\t\tint vl = v + 1, vr = v + ((mid - l) << 1);",
	"\t\tbuild(vl, l, mid);",
	"\t\tbuild(vr, mid, r);",
	"\t\ttree[v] = merge(tree[vl], tree[vr]);",
	"\t}",
	"",
	"\tNode find(int v, int l, int r, int ql, int qr) {",
	"\t\tif (ql <= l && r <= qr) {",
	"\t\t\treturn tree[v];",
	"\t\t}",
	"\t\tpush(v, l, r);",
	"\t\tint mid = (r + l) >> 1;",
	"\t\tint vl = v + 1, vr = v + ((mid - l) << 1);",
	"\t\tif (qr <= mid) {",
	"\t\t\treturn find(vl, l, mid, ql, qr);",
	"\t\t} else if (ql >= mid) {",
	"\t\t\treturn find(vr, mid, r, ql, qr);",
	"\t\t} else {",
	"\t\t\treturn merge(find(vl, l, mid, ql, qr), find(vr, mid, r, ql, qr));",
	"\t\t}",
	"\t}",
	"",
	"\ttemplate<typename T>",
	"\tvoid update(int v, int l, int r, int ql, int qr, const T& newval) {",
	"\t\tif (ql <= l && r <= qr) {",
	"\t\t\ttree[v].apply(l, r, newval);",
	"\t\t\treturn;",
	"\t\t}",
	"\t\tpush(v, l, r);",
	"\t\tint mid = (r + l) >> 1;",
	"\t\tint vl = v + 1, vr = v + ((mid - l) << 1);",
	"\t\tif (ql < mid) {",
	"\t\t\tupdate(vl, l, mid, ql, qr, newval);",
	"\t\t}",
	"\t\tif (qr > mid) {",
	"\t\t\tupdate(vr, mid, r, ql, qr, newval);",
	"\t\t}",
	"\t\ttree[v] = merge(tree[vl], tree[vr]);",
	"\t}",
	"",
	"\tint find_first(int v, int l, int r, int ql, int qr, const function<bool(const Node&)>& predicate) {",
	"\t\tif (!predicate(tree[v])) {",
	"\t\t\treturn -1;",
	"\t\t}",
	"\t\tif (l + 1 == r) {",
	"\t\t\treturn l;",
	"\t\t}",
	"\t\tpush(v, l, r);",
	"\t\tint mid = (r + l) >> 1;",
	"\t\tint vl = v + 1, vr = v + ((mid - l) << 1);",
	"\t\tif (ql < mid) {",
	"\t\t\tint lans = find_first(vl, l, mid, ql, qr, predicate);",
	"\t\t\tif (lans != -1) {",
	"\t\t\t\treturn lans;",
	"\t\t\t}",
	"\t\t}",
	"\t\tif (qr > mid) {",
	"\t\t\tint rans = find_first(vr, mid, r, ql, qr, predicate);",
	"\t\t\tif (rans != -1) {",
	"\t\t\t\treturn rans;",
	"\t\t\t}",
	"\t\t}",
	"\t\treturn -1;",
	"\t}",
	"",
	"\t// INTERFACE",
	"",
	"\tSegmentTree(int n) : n(n) { // build from size with default values",
	"\t\ttree.resize(2 * n - 1);",
	"\t\tbuild(0, 0, n);",
	"\t}",
	"",
	"\ttemplate<typename T>",
	"\tSegmentTree(const vector<T>& arr) { // build from vector",
	"\t\tn = arr.size();",
	"\t\ttree.resize(2 * n - 1);",
	"\t\tbuild(0, 0, n, arr);",
	"\t}",
	"",
	"\tNode find(int ql, int qr) { // find value on [ql, qr)",
	"\t\treturn find(0, 0, n, ql, qr);",
	"\t}",
	"",
	"\tNode find(int qi) { // find value of position qi",
	"\t\treturn find(0, 0, n, qi,qi+1);",
	"\t}",
	"",
	"\ttemplate<typename T>",
	"\tvoid update(int ql, int qr, const T& newval) { // update [ql, qr) with newval",
	"\t\tupdate(0, 0, n, ql, qr, newval);",
	"\t}",
	"",
	"\ttemplate<typename T>",
	"\tvoid update(int qi, const T& newval) { // update position qi with newval",
	"\t\tupdate(0, 0, n, qi, qi + 1, newval);",
	"\t}",
	"",
	"\tint find_first(int ql, int qr, const function<bool(const Node&)>& predicate) { // find first index on [ql, qr) that satisfies predicate or -1 if none",
	"\t\treturn find_first(0, 0, n, ql, qr, predicate);",
	"\t}",
	"",
	"\tint find_first(int ql, const function<bool(const Node&)>& predicate) { // find first index >= ql that satisfies predicate or -1 if none",
	"\t\treturn find_first(0, 0, n, ql, n, predicate);",
	"\t}",
	"",
	"\tint find_first(const function<bool(const Node&)>& predicate) { // find first index that satisfies predicate or -1 if none",
	"\t\treturn find_first(0, 0, n, 0, n, predicate);",
	"\t}",
	"};"
	],
	"description": "Use the apply function to apply the operation on the variable inside the node, sum+=val, the variable considering sum if it is not zero we will apply push operation and set it to zero after applying the push operation"
}
}